var Ch = Object.defineProperty;
var Th = (r, a, n) => a in r ? Ch(r, a, { enumerable: !0, configurable: !0, writable: !0, value: n }) : r[a] = n;
var le = (r, a, n) => (Th(r, typeof a != "symbol" ? a + "" : a, n), n);
let Fh = 0;
const xs = () => Fh++, Ss = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2FkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCh7ZGF0YTp0fSk9Pntjb25zdCBzPXtpZDp0LmlkfTtzZXRUaW1lb3V0KHBvc3RNZXNzYWdlLHQudGltZW91dCxzKX0pfSkoKTsK", So = typeof window < "u" && window.Blob && new Blob([atob(Ss)], { type: "text/javascript;charset=utf-8" });
function Rh() {
  let r;
  try {
    if (r = So && (window.URL || window.webkitURL).createObjectURL(So), !r)
      throw "";
    return new Worker(r);
  } catch {
    return new Worker("data:application/javascript;base64," + Ss);
  } finally {
    r && (window.URL || window.webkitURL).revokeObjectURL(r);
  }
}
let An;
const Ti = /* @__PURE__ */ new Map(), Cs = (r, a) => {
  const n = xs(), l = { id: n, timeout: a };
  return Ti.set(l.id, r), An || (An = new Rh(), An.onmessage = ({ data: _ }) => {
    const v = Ti.get(_.id);
    Ti.delete(_.id), v();
  }), An.postMessage(l), n;
}, Ah = 60, Co = 1e3 / Ah, In = [];
let To = 0;
const Ts = (r) => {
  const a = xs();
  if (In.length === 0) {
    const n = performance.now(), l = Co - (n - To) % Co;
    Cs(() => {
      const _ = To = performance.now(), v = [...In];
      In.length = 0, v.forEach((w) => w(_));
    }, l);
  }
  return In.push(r), a;
}, Ih = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  requestAnimationFrame: Ts,
  setTimeout: Cs
}, Symbol.toStringTag, { value: "Module" })), Ph = (...r) => window.setTimeout(...r), On = /* @__PURE__ */ new Map(), kh = (r) => {
  const a = window.requestAnimationFrame((...n) => {
    On.delete(a), r(...n);
  });
  return On.set(a, r), a;
};
typeof document < "u" && document.addEventListener("visibilitychange", () => {
  document.visibilityState !== "visible" && On.forEach((r, a) => {
    On.delete(a), cancelAnimationFrame(a), Ts(r);
  });
});
const Dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  requestAnimationFrame: kh,
  setTimeout: Ph
}, Symbol.toStringTag, { value: "Module" })), Lh = typeof document < "u" ? document : { visibilityState: "hidden" }, Fs = () => Lh.visibilityState === "visible" ? Dh : Ih, Zr = (r) => Fs().requestAnimationFrame(r), Rs = (r, a) => Fs().setTimeout(r, a), As = (r) => Promise.resolve().then(r), da = {
  requestAnimationFrame: Zr,
  setTimeout: Rs
}, Ab = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nextTick: As,
  requestAnimationFrame: Zr,
  setTimeout: Rs,
  timers: da
}, Symbol.toStringTag, { value: "Module" })), Mh = () => new Promise((r) => Zr(r)), ha = (r = -1) => function(a, n, l) {
  const _ = l, v = _.value;
  return { ..._, value: async function* (...D) {
    const L = v.apply(this, D);
    let O = 0, J = 0;
    for (; ; ) {
      const ae = 1e3 / r, q = 0.1 * ae;
      for (; (J = performance.now()) - O < ae - q; )
        await Mh();
      O = J;
      const { done: K, value: pe } = await L.next();
      if (K)
        return pe;
      const he = yield pe;
      typeof he < "u" && (r = he);
    }
  } };
}, $n = async (r, a = {}) => new Promise((n) => {
  const l = document.createElement("video");
  if (l.muted = !0, l.controls = !1, l.playsInline = !0, Object.assign(l, a), r instanceof globalThis.MediaStream)
    l.srcObject = r, l.addEventListener("ended", () => l.srcObject = null, { once: !0 }), r.addEventListener("inactive", () => l.dispatchEvent(new CustomEvent("ended")), {
      once: !0
    });
  else {
    if (typeof r != "string") {
      const v = r = URL.createObjectURL(r);
      l.addEventListener("emptied", () => URL.revokeObjectURL(v), { once: !0 });
    }
    l.crossOrigin = "anonymous", l.src = r, l.addEventListener("ended", () => l.src = "", { once: !0 });
  }
  l.style.position = "fixed", l.style.zIndex = "-9999999", l.style.opacity = "0.0000000001", document.body.appendChild(l), l.addEventListener("emptied", () => l.remove(), { once: !0 });
  const _ = setInterval(() => l.readyState, 300);
  l.addEventListener("play", () => clearInterval(_), { once: !0 }), l.addEventListener("play", () => n(l), { once: !0 }), l.addEventListener("loadedmetadata", () => l.play(), { once: !0 });
}), Bh = (r) => new Promise((a, n) => {
  const l = document.createElement("img");
  l.onload = () => a(l), l.onerror = n, l.crossOrigin = "anonymous", l.src = typeof r == "string" ? r : URL.createObjectURL(r);
}), Fo = /* @__PURE__ */ new Map(), Nh = (r, a, n) => r * (1 - n) + a * n, Zi = (r) => `webar::${r}:start`, Fi = (r) => `webar::${r}:end`, pa = (r) => {
  let a = { internalName: r + ":" + Math.random() };
  return performance.mark(Zi(a.internalName)), a;
}, ma = (r) => {
  const a = r.internalName;
  performance.mark(Fi(a));
  let n = performance.measure(a, Zi(a), Fi(a));
  n || (n = performance.getEntriesByName(a)[0]), performance.clearMarks(Zi(a)), performance.clearMarks(Fi(a)), performance.clearMeasures(a);
  const { duration: l } = n, _ = a.split(":")[0];
  let { averagedDuration: v = 0 } = Fo.get(_) || {};
  return v = Nh(v, l, 0.05), Fo.set(_, { averagedDuration: v }), { instantDuration: l, averagedDuration: v };
}, Is = (r, a = (n) => console.warn(n)) => function(n, l, _) {
  const v = _.value;
  if (typeof v != "function")
    throw new TypeError("Only functions can be marked as deprecated");
  return { ..._, value: function(...D) {
    return a.call(
      this,
      `DEPRECATION: ${n.constructor.name}.${l}() is deprecated. ${r}`
    ), v.call(this, ...D);
  } };
};
let qr = class {
  constructor() {
    le(this, "_emitter", new EventTarget());
  }
  addEventListener(a, n, l) {
    this._emitter.addEventListener(a, n, l);
  }
  removeEventListener(a, n, l) {
    this._emitter.removeEventListener(a, n, l);
  }
  dispatchEvent(a) {
    return this._emitter.dispatchEvent(a);
  }
  removeAllEventListeners() {
    this._emitter = new EventTarget();
  }
};
const Oh = (r, a, n) => fetch(r, a).then((l) => {
  if (!l.body)
    return l;
  let _ = 0;
  const v = Number(l.headers.get("content-length") || 0), w = l.body.getReader();
  return new Response(
    new ReadableStream({
      async start(m) {
        for (; ; ) {
          const { done: D, value: L } = await w.read();
          if (D ? _ = v : _ += L.byteLength, n?.onProgress?.({ total: v, transferred: _ }), D)
            break;
          m.enqueue(L);
        }
        m.close();
      }
    }),
    l
  );
}), jh = () => (
  // The meta.env.SUPPORTED_BROWSERS will be replaced during build with RegExp, see vite.config.js
  /Edge?\/(79|[89]\d|\d{3,})(\.\d+|)(\.\d+|)|Firefox\/(6[5-9]|[7-9]\d|\d{3,})\.\d+(\.\d+|)|Chrom(ium|e)\/(5[7-9]|[6-9]\d|\d{3,})\.\d+(\.\d+|)([\d.]+$|.*Safari\/(?![\d.]+ Edge\/[\d.]+$))|Maci.* Version\/(1[5-9]|[2-9]\d|\d{3,})\.\d+([,.]\d+|)( Mobile\/\w+|) Safari\/|Chrome.+OPR\/(4[4-9]|[5-9]\d|\d{3,})\.\d+\.\d+|(CPU[ +]OS|iPhone[ +]OS|CPU[ +]iPhone|CPU IPhone OS|CPU iPad OS)[ +]+(1[5-9]|[2-9]\d|\d{3,})[._]\d+([._]\d+|)|Mobile Safari.+OPR\/(7[2-9]|[89]\d|\d{3,})\.\d+\.\d+|Android.+Chrom(ium|e)\/(10[7-9]|1[1-9]\d|[2-9]\d{2}|\d{4,})\.\d+(\.\d+|)|Android.+(UC? ?Browser|UCWEB|U3)[ /]?(1[3-9]|[2-9]\d|\d{3,})\.\d+\.\d+|SamsungBrowser\/([7-9]|\d{2,})\.\d+|Android.+MQ{2}Browser\/(1[3-9]|[2-9]\d|\d{3,})(\.\d+|)(\.\d+|)|baidubrowser[\s/](1[3-9]|[2-9]\d|\d{3,})(\.\d+|)(\.\d+|)/.test(navigator.userAgent)
), Uh = typeof window < "u" && /^((?!chrome|android).)*safari/i.test(window.navigator?.userAgent), Ps = typeof OffscreenCanvas < "u" && !Uh, ks = {
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#avoid_alphafalse_which_can_be_expensive
  alpha: !0,
  antialias: !1,
  depth: !1,
  // since this context is designed to process video, it's better to be synchronized with the browser renderer
  desynchronized: !1,
  // avoid setting `powerPreference` to `"high-performance"` - it highly increases GPU usage
  // powerPreference: "high-performance",
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  stencil: !1
};
let oe;
const Wh = (() => {
  if (typeof window > "u" || !jh())
    return !1;
  oe ?? (oe = Ds().getContext("webgl2", ks));
  const r = oe.createTexture();
  oe.bindTexture(oe.TEXTURE_2D, r), oe.texImage2D(oe.TEXTURE_2D, 0, oe.RGB, 1, 1, 0, oe.RGB, oe.UNSIGNED_BYTE, null);
  const a = oe.createFramebuffer();
  oe.bindFramebuffer(oe.FRAMEBUFFER, a), oe.framebufferTexture2D(oe.FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_2D, r, 0);
  const n = oe.getParameter(oe.IMPLEMENTATION_COLOR_READ_FORMAT);
  return oe.bindFramebuffer(oe.FRAMEBUFFER, null), oe.bindTexture(oe.TEXTURE_2D, null), oe.deleteFramebuffer(a), oe.deleteTexture(r), n === oe.RGB;
})(), $h = async (r, a, n, l = "RGBA") => {
  oe ?? (oe = Ds().getContext("webgl2", ks)), oe.canvas.width = r.width, oe.canvas.height = r.height, l === "RGB" && oe.pixelStorei(oe.PACK_ALIGNMENT, 1);
  const _ = oe.createTexture();
  oe.bindTexture(oe.TEXTURE_2D, _), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MIN_FILTER, oe.NEAREST), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MAG_FILTER, oe.LINEAR), oe.texImage2D(oe.TEXTURE_2D, 0, oe[l], oe[l], oe.UNSIGNED_BYTE, r);
  const v = oe.createFramebuffer();
  oe.bindFramebuffer(oe.FRAMEBUFFER, v), oe.framebufferTexture2D(oe.FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_2D, _, 0);
  const w = oe.createBuffer();
  oe.bindBuffer(oe.PIXEL_PACK_BUFFER, w), oe.bufferData(oe.PIXEL_PACK_BUFFER, a.byteLength, oe.STREAM_READ), oe.readPixels(
    n.x,
    n.y,
    n.width,
    n.height,
    oe[l],
    oe.UNSIGNED_BYTE,
    0
  ), oe.bindBuffer(oe.PIXEL_PACK_BUFFER, null), oe.bindFramebuffer(oe.FRAMEBUFFER, null), oe.deleteFramebuffer(v), oe.bindTexture(oe.TEXTURE_2D, null), oe.deleteTexture(_);
  const m = oe.fenceSync(oe.SYNC_GPU_COMMANDS_COMPLETE, 0);
  oe.flush(), await Gh(oe, m).finally(() => oe.deleteSync(m)), oe.bindBuffer(oe.PIXEL_PACK_BUFFER, w), oe.getBufferSubData(
    oe.PIXEL_PACK_BUFFER,
    0,
    new DataView(a.buffer()),
    a.byteOffset,
    a.byteLength
  ), oe.bindBuffer(oe.PIXEL_PACK_BUFFER, null), oe.deleteBuffer(w);
}, Gh = (r, a) => new Promise(
  (n, l) => function _() {
    const v = r.clientWaitSync(a, 0, 0);
    if (v === r.WAIT_FAILED)
      return l(new Error("GPU operations complete wait failed"));
    if (v === r.CONDITION_SATISFIED || v === r.ALREADY_SIGNALED)
      return n();
    da.setTimeout(_, 2);
  }()
);
function Vh(r = 256, a = 128) {
  const n = document.createElement("canvas");
  return n.width = r, n.height = a, n;
}
function zh(r = 256, a = 128) {
  return new OffscreenCanvas(r, a);
}
function Ds(r = 256, a = 128) {
  return Ps ? zh(r, a) : Vh(r, a);
}
const _a = (r = {}) => {
  const a = ({ displayWidth: l, displayHeight: _, visibleRect: v = null }) => {
    let w = v?.x ?? 0, m = v?.y ?? 0, D = v?.width ?? l, L = v?.height ?? _;
    if (r.crop) {
      const [O, J, ae, q] = r.crop(D, L);
      [w, m, D, L] = [w + O, m + J, ae, q];
    }
    return [l, _] = [D, L], {
      visibleRect: { x: w, y: m, width: D, height: L },
      displayWidth: l,
      displayHeight: _,
      horizontalFlip: !!r.horizontalFlip
    };
  };
  return { getSourceOptions: (l) => {
    let _ = l instanceof HTMLVideoElement ? l.videoWidth : l.width, v = l instanceof HTMLVideoElement ? l.videoHeight : l.height;
    return a({ displayWidth: _, displayHeight: v });
  }, getFrameOptions: a };
};
class Gn {
  constructor(a, n = {}, l = null) {
    le(this, "_source", null);
    le(this, "_visibleRect", { x: 0, y: 0, width: 0, height: 0 });
    le(this, "_deleter");
    le(this, "horizontalFlip", !1);
    const _ = a instanceof HTMLVideoElement ? a.videoWidth : a.width, v = a instanceof HTMLVideoElement ? a.videoHeight : a.height;
    this._visibleRect.x = n.visibleRect?.x ?? 0, this._visibleRect.y = n.visibleRect?.y ?? 0, this._visibleRect.width = n.visibleRect?.width ?? _, this._visibleRect.height = n.visibleRect?.height ?? v, this.horizontalFlip = n.horizontalFlip ?? this.horizontalFlip, a.width = _, a.height = v, this._source = a, this._deleter = l;
  }
  /** @internal */
  get texture() {
    return this._source?.width == this.displayWidth && this._source?.height == this.displayHeight ? this._source : null;
  }
  get displayWidth() {
    return this._visibleRect.width;
  }
  get displayHeight() {
    return this._visibleRect.height;
  }
  /** Pixel format of the Frame */
  get format() {
    return this._source ? Wh ? "RGB" : "RGBA" : null;
  }
  /** @returns The number of bytes required to hold the Frame pixels */
  allocationSize() {
    if (!this.format)
      throw new Error("Failed to execute 'allocationSize' on 'Frame': Frame is closed.");
    const { width: a, height: n } = { width: this._visibleRect.width, height: this._visibleRect.height };
    return a * n * this.format.length;
  }
  /** Copies the Frame pixels to the destination */
  async copyTo(a) {
    if (!this._source)
      throw new Error("Failed to execute 'copyTo' on 'Frame': Frame is closed.");
    return await $h(this._source, a, this._visibleRect, this.format), [];
  }
  /** Releases GPU resources held by the Frame */
  close() {
    this._deleter && this._deleter(), this._source = null;
  }
}
var Hh = Object.defineProperty, Kh = Object.getOwnPropertyDescriptor, Yh = (r, a, n, l) => {
  for (var _ = l > 1 ? void 0 : l ? Kh(a, n) : a, v = r.length - 1, w; v >= 0; v--)
    (w = r[v]) && (_ = (l ? w(a, n, _) : w(_)) || _);
  return l && _ && Hh(a, n, _), _;
}, Ls;
let Xh = class {
  constructor(a) {
    le(this, "_src");
    /** @internal */
    le(this, "kind", "image");
    this._src = a;
  }
  async *[Ls = Symbol.asyncIterator](a) {
    const n = await Bh(this._src), l = _a(a);
    yield new Gn(n, l.getSourceOptions(n), () => {
      URL.revokeObjectURL(n.src), n.src = "";
    });
  }
};
Yh([
  ha(30)
], Xh.prototype, Ls, 1);
var Zh = Object.defineProperty, qh = Object.getOwnPropertyDescriptor, Qh = (r, a, n, l) => {
  for (var _ = l > 1 ? void 0 : l ? qh(a, n) : a, v = r.length - 1, w; v >= 0; v--)
    (w = r[v]) && (_ = (l ? w(a, n, _) : w(_)) || _);
  return l && _ && Zh(a, n, _), _;
}, Ms, Gt;
const Bs = (Gt = class {
  /**
   * Creates MediaStream input from {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/MediaStream | MediaStream}
   * @example
   * ```ts
   * const stream = new MediaStream(
   *  await navigator.mediaDevices.getUserMedia({ video: true })
   * )
   * ```
   */
  constructor(a) {
    // @ts-expect-error: Property '_stream' has no initializer and is not definitely assigned in the constructor.
    le(this, "_stream");
    /** @internal */
    le(this, "kind", "stream");
    if (!Gt.cache.has(a))
      Gt.cache.set(a, this);
    else
      return Gt.cache.get(a);
    this._stream = a;
  }
  async *[Ms = Symbol.asyncIterator](a) {
    const n = _a(a);
    if ("MediaStreamTrackProcessor" in window) {
      const _ = new MediaStreamTrackProcessor({ track: this._stream.getVideoTracks()[0] }).readable.getReader();
      try {
        for (; ; ) {
          const { done: v, value: w } = await _.read();
          if (v)
            return;
          const m = new VideoFrame(w, n.getFrameOptions(w));
          m.horizontalFlip = a?.horizontalFlip ?? !0, w.close(), yield m;
        }
      } finally {
        _.releaseLock();
      }
    } else {
      const l = await $n(this._stream), _ = "requestVideoFrameCallback" in l ? l.requestVideoFrameCallback.bind(l) : requestAnimationFrame;
      for (; !l.paused; )
        await new Promise(_), yield new Gn(l, n.getSourceOptions(l));
      URL.revokeObjectURL(l.src), l.src = "", l.srcObject = null;
    }
  }
  /** Stops underlying media stream */
  stop() {
    for (const a of this._stream.getVideoTracks())
      a.stop();
    this._stream && Gt.cache.delete(this._stream);
  }
}, le(Gt, "cache", /* @__PURE__ */ new WeakMap()), Gt);
Qh([
  ha(30)
], Bs.prototype, Ms, 1);
let Ri = Bs;
var Jh = Object.defineProperty, ep = Object.getOwnPropertyDescriptor, tp = (r, a, n, l) => {
  for (var _ = l > 1 ? void 0 : l ? ep(a, n) : a, v = r.length - 1, w; v >= 0; v--)
    (w = r[v]) && (_ = (l ? w(a, n, _) : w(_)) || _);
  return l && _ && Jh(a, n, _), _;
}, Ns;
const rp = {
  loop: !1
};
class np {
  /** @param options - options to be merged with {@link defaultVideoOptions} */
  constructor(a, n) {
    le(this, "_src");
    le(this, "_options");
    le(this, "_video", null);
    /** @internal */
    le(this, "kind", "video");
    this._src = a, this._options = {
      ...rp,
      ...n
    };
  }
  async *[Ns = Symbol.asyncIterator](a) {
    const n = await (this._video ?? (this._video = $n(this._src, this._options))), l = _a(a), _ = "requestVideoFrameCallback" in n ? n.requestVideoFrameCallback.bind(n) : requestAnimationFrame;
    for (; !n.paused; )
      await new Promise(_), yield new Gn(n, l.getSourceOptions(n));
  }
  /** Stops underlying video */
  stop() {
    this._video && this._video.then(
      (a) => (URL.revokeObjectURL(a.src), a.src = "", a.srcObject = null)
    ), this._video = null;
  }
}
tp([
  ha(30)
], np.prototype, Ns, 1);
const ip = `#define GLSLIFY 1
attribute vec2 a_position;
varying vec2 v_tex_uv;

void main() {
  v_tex_uv.x = (a_position.x + 1.) * .5;
  v_tex_uv.y = 1. - (a_position.y + 1.) * .5;
  gl_Position = vec4(a_position, 0., 1.);
}
`, ap = `precision highp float;
#define GLSLIFY 1

varying vec2 v_tex_uv;

uniform sampler2D u_texture;
uniform vec2 u_viewsize;

/**
 * u_filters.x - denoising algorithm to use
 *   1 - FSR
 *   2 - Bilateral
 *   any other value - none
 * u_filters.y - light correction coefficient in [0, 2]
 *   1 - no light correction
 */
uniform vec2 u_filters;

// https://github.com/glslify/glslify#importing-a-glsl-module
// https://github.com/glslify/glslify#passing-references-between-modules
// Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// FidelityFX FSR v1.0.2 by AMD
// ported to mpv by agyild - https://gist.github.com/agyild/82219c545228d70c5604f865ce0b0ce5
// ported to WebGL by goingdigital - https://www.shadertoy.com/view/stXSWB
// using colorspace functions from tobspr - https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl

#define SHARPENING 2.0 // Sharpening intensity: Adjusts sharpening intensity by averaging the original pixels to the sharpened result. 1.0 is the unmodified default. 0.0 to 1.0.
#define CONTRAST 2.0 // Adjusts the range the shader adapts to high contrast (0 is not all the way off). Higher values = more high contrast sharpening. 0.0 to 1.0.
#define PERFORMANCE 1 // Whether to use optimizations for performance with loss of quality

// Used to convert from linear RGB to XYZ space
const mat3 RGB_2_XYZ_2717090884 = (mat3(
  0.4124564, 0.2126729, 0.0193339,
  0.3575761, 0.7151522, 0.1191920,
  0.1804375, 0.0721750, 0.9503041
));

// Used to convert from XYZ to linear RGB space
const mat3 XYZ_2_RGB_2717090884 = (mat3(
   3.2404542,-0.9692660, 0.0556434,
  -1.5371385, 1.8760108,-0.2040259,
  -0.4985314, 0.0415560, 1.0572252
));
// Converts a color from linear RGB to XYZ space
vec3 rgb_to_xyz_2717090884(vec3 rgb) {
  return RGB_2_XYZ_2717090884 * rgb;
}

// Converts a color from XYZ to linear RGB space
vec3 xyz_to_rgb_2717090884(vec3 xyz) {
  return XYZ_2_RGB_2717090884 * xyz;
}

/* EASU stage
*
* This takes a reduced resolution source, and scales it up while preserving detail.
*
* Updates:
*   stretch definition fixed. Thanks nehon for the bug report!
*/

vec3 FsrEasuCF(vec2 p) {
  vec2 uv = (p + .5) / u_viewsize;
  vec4 color = texture2D(u_texture, uv);
    return rgb_to_xyz_2717090884(color.rgb);
}

/**** EASU ****/
void FsrEasuCon(
  out vec4 con0,
  out vec4 con1,
  out vec4 con2,
  out vec4 con3,
  // This the rendered image resolution being upscaled
  vec2 inputViewportInPixels,
  // This is the resolution of the resource containing the input image (useful for dynamic resolution)
  vec2 inputSizeInPixels,
  // This is the display resolution which the input image gets upscaled to
  vec2 outputSizeInPixels
)
{
  // Output integer position to a pixel position in viewport.
  con0 = vec4(
    inputViewportInPixels.x/outputSizeInPixels.x,
    inputViewportInPixels.y/outputSizeInPixels.y,
    .5*inputViewportInPixels.x/outputSizeInPixels.x-.5,
    .5*inputViewportInPixels.y/outputSizeInPixels.y-.5
  );
  // Viewport pixel position to normalized image space.
  // This is used to get upper-left of 'F' tap.
  con1 = vec4(1.,1.,1.,-1.)/inputSizeInPixels.xyxy;
  // Centers of gather4, first offset from upper-left of 'F'.
  //      +---+---+
  //      |   |   |
  //      +--(0)--+
  //      | b | c |
  //  +---F---+---+---+
  //  | e | f | g | h |
  //  +--(1)--+--(2)--+
  //  | i | j | k | l |
  //  +---+---+---+---+
  //      | n | o |
  //      +--(3)--+
  //      |   |   |
  //      +---+---+
  // These are from (0) instead of 'F'.
  con2 = vec4(-1.,2.,1.,2.)/inputSizeInPixels.xyxy;
  con3 = vec4(0.,4.,0.,0.)/inputSizeInPixels.xyxy;
}

// Filtering for a given tap for the scalar.
void FsrEasuTapF(
  inout vec3 aC, // Accumulated color, with negative lobe.
  inout float aW, // Accumulated weight.
  vec2 off_0, // Pixel offset from resolve position to tap.
  vec2 dir_0, // Gradient direction.
  vec2 len_0, // Length.
  float lob_0, // Negative lobe strength.
  float clp_0, // Clipping point.
  vec3 c_0
)
{
  // Tap color.
  // Rotate offset by direction.
  vec2 v = vec2(dot(off_0, dir_0), dot(off_0,vec2(-dir_0.y,dir_0.x)));
  // Anisotropy.
  v *= len_0;
  // Compute distance^2.
  float d2 = min(dot(v,v),clp_0);
  // Limit to the window as at corner, 2 taps can easily be outside.
  // Approximation of lancos2 without sin() or rcp(), or sqrt() to get x.
  //  (25/16 * (2/5 * x^2 - 1)^2 - (25/16 - 1)) * (1/4 * x^2 - 1)^2
  //  |_______________________________________|   |_______________|
  //                   base                             window
  // The general form of the 'base' is,
  //  (a*(b*x^2-1)^2-(a-1))
  // Where 'a=1/(2*b-b^2)' and 'b' moves around the negative lobe.
  float wB = .4 * d2 - 1.;
  float wA = lob_0 * d2 -1.;
  wB *= wB;
  wA *= wA;
  wB = 1.5625*wB-.5625;
  float w=  wB * wA;
  // Do weighted average.
  aC += c_0*w;
  aW += w;
}

//------------------------------------------------------------------------------------------------------------------------------
// Accumulate direction and length.
void FsrEasuSetF(
    inout vec2 dir,
    inout float len,
    float w,
    float lA,float lB,float lC,float lD,float lE
)
{
  // Direction is the '+' diff.
  //    a
  //  b c d
  //    e
  // Then takes magnitude from abs average of both sides of 'c'.
  // Length converts gradient reversal to 0, smoothly to non-reversal at 1, shaped, then adding horz and vert terms.
  float lenX = max(abs(lD - lC), abs(lC - lB));
  float dirX = lD - lB;
  dir.x += dirX * w;
  lenX = clamp(abs(dirX)/lenX,0.,1.);
  lenX *= lenX;
  len += lenX * w;
  // Repeat for the y axis.
  float lenY = max(abs(lE - lC), abs(lC - lA));
  float dirY = lE - lA;
  dir.y += dirY * w;
  lenY = clamp(abs(dirY) / lenY,0.,1.);
  lenY *= lenY;
  len += lenY * w;
}

//------------------------------------------------------------------------------------------------------------------------------
void FsrEasuF(
  out vec3 pix,
  vec2 ip, // Integer pixel position in output.
  // Constants generated by FsrEasuCon().
  vec4 con0, // xy = output to input scale, zw = first pixel offset correction
  vec4 con1_0,
  vec4 con2_0,
  vec4 con3_0
)
{
  //------------------------------------------------------------------------------------------------------------------------------
  // Get position of 'f'.
  vec2 pp = ip * con0.xy + con0.zw; // Corresponding input pixel/subpixel
  vec2 fp = floor(pp);// fp = source nearest pixel
  pp -= fp; // pp = source subpixel

  //------------------------------------------------------------------------------------------------------------------------------
  // 12-tap kernel.
  //    b c
  //  e f g h
  //  i j k l
  //    n o
  // Gather 4 ordering.
  //  a b
  //  r g
  vec2 p0 = fp * con1_0.xy + con1_0.zw;
  
  // These are from p0 to avoid pulling two constants on pre-Navi hardware.
  vec2 p1 = p0 + con2_0.xy;
  vec2 p2 = p0 + con2_0.zw;
  vec2 p3 = p0 + con3_0.xy;

  // TextureGather is not available on WebGL2
  vec4 off = vec4(-.5,.5,-.5,.5)*con1_0.xxyy;
  // textureGather to texture offsets
  // x=west y=east z=north w=south
  vec3 bC = FsrEasuCF(p0 + off.xw); float bL = bC.g + 0.5 *(bC.r + bC.b);
  vec3 cC = FsrEasuCF(p0 + off.yw); float cL = cC.g + 0.5 *(cC.r + cC.b);
  vec3 iC = FsrEasuCF(p1 + off.xw); float iL = iC.g + 0.5 *(iC.r + iC.b);
  vec3 jC = FsrEasuCF(p1 + off.yw); float jL = jC.g + 0.5 *(jC.r + jC.b);
  vec3 fC = FsrEasuCF(p1 + off.yz); float fL = fC.g + 0.5 *(fC.r + fC.b);
  vec3 eC = FsrEasuCF(p1 + off.xz); float eL = eC.g + 0.5 *(eC.r + eC.b);
  vec3 kC = FsrEasuCF(p2 + off.xw); float kL = kC.g + 0.5 *(kC.r + kC.b);
  vec3 lC = FsrEasuCF(p2 + off.yw); float lL = lC.g + 0.5 *(lC.r + lC.b);
  vec3 hC = FsrEasuCF(p2 + off.yz); float hL = hC.g + 0.5 *(hC.r + hC.b);
  vec3 gC = FsrEasuCF(p2 + off.xz); float gL = gC.g + 0.5 *(gC.r + gC.b);
  vec3 oC = FsrEasuCF(p3 + off.yz); float oL = oC.g + 0.5 *(oC.r + oC.b);
  vec3 nC = FsrEasuCF(p3 + off.xz); float nL = nC.g + 0.5 *(nC.r + nC.b);
 
  //------------------------------------------------------------------------------------------------------------------------------
  // Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).
  // Accumulate for bilinear interpolation.
  vec2 dir = vec2(0.);
  float len = 0.;

  FsrEasuSetF(dir, len, (1.-pp.x)*(1.-pp.y), bL, eL, fL, gL, jL);
  FsrEasuSetF(dir, len,    pp.x  *(1.-pp.y), cL, fL, gL, hL, kL);
  FsrEasuSetF(dir, len, (1.-pp.x)*  pp.y  , fL, iL, jL, kL, nL);
  FsrEasuSetF(dir, len,    pp.x  *  pp.y  , gL, jL, kL, lL, oL);

  //------------------------------------------------------------------------------------------------------------------------------
  // Normalize with approximation, and cleanup close to zero.
  vec2 dir2 = dir * dir;
  float dirR = dir2.x + dir2.y;
  bool zro = dirR < (1.0/32768.0);
  dirR = inversesqrt(dirR);
#if (PERFORMANCE == 1)
  if (zro) {
    vec4 w = vec4(0.0);
    w.x = (1.0 - pp.x) * (1.0 - pp.y);
    w.y =        pp.x  * (1.0 - pp.y);
    w.z = (1.0 - pp.x) *        pp.y;
    w.w =        pp.x  *        pp.y;
    pix.r = clamp(dot(w, vec4(fL, gL, jL, kL)), 0.0, 1.0);
    return;
  }
#elif (PERFORMANCE == 0)
  dirR = zro ? 1.0 : dirR;
  dir.x = zro ? 1.0 : dir.x;
#endif
  dir *= vec2(dirR);
  // Transform from {0 to 2} to {0 to 1} range, and shape with square.
  len = len * 0.5;
  len *= len;
  // Stretch kernel {1.0 vert|horz, to sqrt(2.0) on diagonal}.
  float stretch = dot(dir,dir) / (max(abs(dir.x), abs(dir.y)));
  // Anisotropic length after rotation,
  //  x := 1.0 lerp to 'stretch' on edges
  //  y := 1.0 lerp to 2x on edges
  vec2 len2 = vec2(1. +(stretch-1.0)*len, 1. -.5 * len);
  // Based on the amount of 'edge',
  // the window shifts from +/-{sqrt(2.0) to slightly beyond 2.0}.
  float lob = .5 - .29 * len;
  // Set distance^2 clipping point to the end of the adjustable window.
  float clp = 1./lob;

  //------------------------------------------------------------------------------------------------------------------------------
  // Accumulation mixed with min/max of 4 nearest.
  //    b c
  //  e f g h
  //  i j k l
  //    n o
  // Accumulation.
  vec3 aC = vec3(0);
  float aW = 0.;
  FsrEasuTapF(aC, aW, vec2( 0.,-1.)-pp, dir, len2, lob, clp, bC);
  FsrEasuTapF(aC, aW, vec2( 1.,-1.)-pp, dir, len2, lob, clp, cC);
  FsrEasuTapF(aC, aW, vec2(-1., 1.)-pp, dir, len2, lob, clp, iC);
  FsrEasuTapF(aC, aW, vec2( 0., 1.)-pp, dir, len2, lob, clp, jC);
  FsrEasuTapF(aC, aW, vec2( 0., 0.)-pp, dir, len2, lob, clp, fC);
  FsrEasuTapF(aC, aW, vec2(-1., 0.)-pp, dir, len2, lob, clp, eC);
  FsrEasuTapF(aC, aW, vec2( 1., 1.)-pp, dir, len2, lob, clp, kC);
  FsrEasuTapF(aC, aW, vec2( 2., 1.)-pp, dir, len2, lob, clp, lC);
  FsrEasuTapF(aC, aW, vec2( 2., 0.)-pp, dir, len2, lob, clp, hC);
  FsrEasuTapF(aC, aW, vec2( 1., 0.)-pp, dir, len2, lob, clp, gC);
  FsrEasuTapF(aC, aW, vec2( 1., 2.)-pp, dir, len2, lob, clp, oC);
  FsrEasuTapF(aC, aW, vec2( 0., 2.)-pp, dir, len2, lob, clp, nC);
  //------------------------------------------------------------------------------------------------------------------------------
  // Normalize and dering.
#if (PERFORMANCE == 1)
pix = aC/aW;
#elif (PERFORMANCE == 0)
  vec3 min4 = min(min(fC,gC),min(jC,kC));
  vec3 max4 = max(max(fC,gC),max(jC,kC));
  pix=min(max4,max(min4,aC/aW));
#endif
}

void EASU( out vec4 fragColor, in vec2 fragCoord )
{
  vec3 c;
  vec4 con0,con1,con2,con3;
  
  // "rendersize" refers to size of source image before upscaling.
  vec2 rendersize = u_viewsize;
  FsrEasuCon(
    con0, con1, con2, con3, rendersize, rendersize, rendersize
  );
  FsrEasuF(c, fragCoord, con0, con1, con2, con3);
  
  fragColor = vec4(xyz_to_rgb_2717090884(c.xyz), 1);
}

vec4 getPixel(vec2 pos) {
  vec2 coord = (pos + .5) / u_viewsize;
  coord.y = 1.0 - coord.y;
  return texture2D(u_texture, coord);
}

vec4 fsr_easu_2717090884(vec2 uv) {
  vec4 e = getPixel(gl_FragCoord.xy);

    
  vec4 e_xyz = vec4(rgb_to_xyz_2717090884(e.rgb), 1);
  EASU(e_xyz, (gl_FragCoord.xy + 0.5) / u_viewsize);  
  
  // fetch a 3x3 neighborhood around the pixel 'e',
  //  a b c
  //  d(e)f
  //  g h i 
  vec3 a = getPixel(gl_FragCoord.xy + vec2(-1.0,-1.0)).rgb;
  vec3 b = getPixel(gl_FragCoord.xy + vec2( 0.0,-1.0)).rgb;
  vec3 c = getPixel(gl_FragCoord.xy + vec2( 1.0,-1.0)).rgb;
  vec3 f = getPixel(gl_FragCoord.xy + vec2( 1.0, 0.0)).rgb;
  vec3 g = getPixel(gl_FragCoord.xy + vec2(-1.0, 1.0)).rgb;
  vec3 h = getPixel(gl_FragCoord.xy + vec2( 0.0, 1.0)).rgb;
  vec3 d = getPixel(gl_FragCoord.xy + vec2(-1.0, 0.0)).rgb;
  vec3 i = getPixel(gl_FragCoord.xy + vec2( 1.0, 1.0)).rgb;;
  // Soft min and max.
  //  a b c     b
  //  d e f * 0.5 + d e f * 0.5
  //  g h i     h
  // These are 2.0x bigger (factored out the extra multiply).

  vec3 mnRGB = min(min(min(d, e.rgb), min(f, b)), h);
  vec3 mnRGB2 = min(mnRGB, min(min(a, c), min(g, i)));
  mnRGB += mnRGB2;

  vec3 mxRGB = max(max(max(d, e.rgb), max(f, b)), h);
  vec3 mxRGB2 = max(mxRGB, max(max(a, c), max(g, i)));
  mxRGB += mxRGB2;

  // Smooth minimum distance to signal limit divided by smooth max.
  vec3 rcpMRGB = 1.0 / mxRGB;
  vec3 ampRGB = clamp(min(mnRGB, 2.0 - mxRGB) * rcpMRGB, 0.0, 1.0);

  // Shaping amount of sharpening.
  ampRGB = inversesqrt(ampRGB);

  float peak = -3.0 * clamp(CONTRAST, 0.0, 1.0) + 8.0;
  vec3 wRGB = -(1.0 / (ampRGB * peak));

  vec3 rcpWeightRGB = 1.0 / (4.0 * wRGB + 1.0);

  //          0 w 0
  //  Filter shape: w 1 w
  //          0 w 0
  vec3 window = (b + d) + (f + h);
  vec3 outColor = clamp((window * wRGB + e.rgb) * rcpWeightRGB, 0.0, 1.0);

  return vec4(mix(e.rgb, outColor, SHARPENING), e.a);
}

// https://github.com/glslify/glslify#exporting-a-glsl-module

#define DIFF 1.0
#define RADIUS 4.0

void bilateral_iter_3977570374(vec2 random_dir, vec2 radius, float diff, vec4 pixel, vec2 uv, inout vec3 result, inout float totalWeight)
{
  vec2 dir = random_dir * radius;
  vec3 randomPixel = texture2D(u_texture, uv + dir).xyz;
  vec3 delta = randomPixel - pixel.rgb;
  float weight = exp(-dot(delta, delta) / diff);
  result += randomPixel * weight;
  totalWeight += weight;
}

vec4 bilateral(vec2 uv)
{
  vec2 radius = (RADIUS / u_viewsize);
  float diff = DIFF / 255.0;
  vec4 pixel = texture2D(u_texture, uv);
  vec3 result = vec3(0.0, 0.0, 0.0);
  float totalWeight = 0.0;

  // uroll loop and substitute precalculated random vectors for GLSL 1.0 ES:

  bilateral_iter_3977570374(vec2(-0.886051297,0.447155535), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(0.270759493,0.537728608), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.896959424,0.440607518), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.804274619,0.125076547), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(0.373693645,0.240383312), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.850325704,-0.192106694), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.453608066,0.889671504), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.280496657,0.206442386), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(0.840040743,-0.36367026), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.151598319,-0.884027064), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.221440807,0.593896627), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.797481239,-0.243254974), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(0.48824361,0.225083455), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.0387817062,0.838459492), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(0.92897892,-0.133588716), radius, diff, pixel, uv, result, totalWeight);
  bilateral_iter_3977570374(vec2(-0.693672359,-0.706737161), radius, diff, pixel, uv, result, totalWeight);
  
  result = result / totalWeight;    
  return vec4(result, pixel.a);
}

// https://github.com/glslify/glslify#exporting-a-glsl-module

vec3 rgb2hsv(vec3 c)
{
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec4 light_correction_1117569599(vec4 c, float s)
{
  vec3 hsv = rgb2hsv(c.rgb);
  hsv.y = pow(hsv.y, pow(s, -0.5));
  hsv.z = pow(hsv.z, s);
  vec3 rgb = hsv2rgb(hsv);
  return vec4(rgb, c.a);
}

// https://github.com/glslify/glslify#exporting-a-glsl-module

void main() {
  vec4 c;

  if (u_filters.x == 1.)
    c = fsr_easu_2717090884(v_tex_uv);
  else if (u_filters.x == 2.)
    c = bilateral(v_tex_uv);
  else
    c = texture2D(u_texture, v_tex_uv);

  if (u_filters.y != 1.)
    c = light_correction_1117569599(c, u_filters.y);

  gl_FragColor = c;
}`, op = (r, a, n) => {
  const l = r.createProgram();
  return r.attachShader(l, a), r.attachShader(l, n), r.linkProgram(l), r.useProgram(l), l;
}, Ro = (r, a, n) => {
  const l = r.createShader(a);
  return r.shaderSource(l, n), r.compileShader(l), l;
}, sp = (r) => {
  const a = r.createTexture();
  return r.bindTexture(r.TEXTURE_2D, a), r.texImage2D(r.TEXTURE_2D, 0, r.RGB, 1, 1, 0, r.RGB, r.UNSIGNED_BYTE, null), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.bindTexture(r.TEXTURE_2D, null), a;
}, Ao = (r, a) => {
  let n = 0, l = 1;
  const _ = document.createElement("canvas"), v = _.captureStream(30), w = _.getContext("webgl"), m = Ro(w, w.VERTEX_SHADER, ip), D = Ro(w, w.FRAGMENT_SHADER, ap), L = op(w, m, D), O = sp(w);
  w.bindTexture(w.TEXTURE_2D, O);
  const J = w.getAttribLocation(L, "a_position"), ae = w.createBuffer();
  w.bindBuffer(w.ARRAY_BUFFER, ae), w.bufferData(
    w.ARRAY_BUFFER,
    // prettier-ignore
    new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]),
    w.STATIC_DRAW
  ), w.enableVertexAttribArray(J), w.vertexAttribPointer(J, 2, w.FLOAT, !1, 0, 0);
  const q = w.getUniformLocation(L, "u_viewsize"), K = w.getUniformLocation(L, "u_filters");
  w.uniform2fv(K, new Float32Array([n, l])), $n(r).then((he) => {
    const ce = he.requestVideoFrameCallback?.bind(he) || da.requestAnimationFrame;
    (function ee() {
      he.ended || !v.active || (ce(ee), w.texImage2D(w.TEXTURE_2D, 0, w.RGBA, w.RGBA, w.UNSIGNED_BYTE, he), (_.width !== he.videoWidth || _.height !== he.videoHeight) && (w.viewport(0, 0, _.width = he.videoWidth, _.height = he.videoHeight), w.uniform2fv(q, new Float32Array([_.width, _.height]))), w.drawArrays(w.TRIANGLES, 0, 6));
    })();
  }), w.deleteProgram(L), w.deleteShader(D), w.deleteShader(m);
  const pe = {
    /** Enhanced stream */
    stream: v,
    /**
     * @param {number} value - denoise algorithm to use
     *  - Pass 1 to use FSR algorithm
     *  - Pass 2 to use Bilateral algorithm
     *  - Pass any other number to disabled denoising
     */
    denoise(he) {
      w.uniform2fv(K, new Float32Array([n = he, l]));
    },
    /**
     * @param {number} value - exposure compensation coefficient in [0, 2] range
     *  - Pass value less than to 1 increase exposure
     *  - Pass value greater than 1 to reduce exposure
     * See the {@link https://fujifilm-dsc.com/en/manual/x-pro2/images/exp_exposure_480.gif | image} for visual example
     * Inspired by MediaTrackConstraints {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#exposurecompensation | Exposure compensation} parameter.
     */
    exposureCompensation(he) {
      w.uniform2fv(K, new Float32Array([n, l = he]));
    }
  };
  if (a)
    for (const [he, ce] of Object.entries(a))
      pe[he](ce);
  return pe;
}, up = typeof screen < "u" && screen.height > screen.width, qi = {
  facingMode: "user",
  width: { min: 640, ideal: 1280, max: 1920 },
  height: { min: 480, ideal: 720, max: 1080 },
  resizeMode: { ideal: "crop-and-scale" }
};
up && (delete qi.width, delete qi.height);
class kb {
  /**
   * @param videoConstraints - constraints to be merged with {@link defaultVideoConstraints}
   * and to be passed to {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia | navigator.mediaDevices.getUserMedia()}
   */
  constructor(a) {
    le(this, "_stream", null);
    le(this, "_constraints");
    le(this, "_preferences", {});
    le(this, "_enhancer", null);
    /** @internal */
    le(this, "kind", "stream");
    this._constraints = {
      ...qi,
      ...a
    };
  }
  /**
   * Specifies if the webcam is currently active.
   *
   * The webcam is considered active if it has been started and has not been stopped afterwards
   */
  get active() {
    return !!this._stream;
  }
  /**
   * @param {number} algorithm - denoise algorithm to use
   *  - Pass false or 0 to disabled denoising
   *  - Pass true or 1 to use FSR algorithm
   *  - Pass 2 to use Bilateral algorithm
   * @internal
   */
  denoise(a) {
    this._preferences.denoise = Number(a), this._enhancer?.denoise(this._preferences.denoise);
  }
  /**
   * @param {number} coefficient - exposure compensation coefficient in [0, 2] range
   *  - Pass value less than 1 to increase exposure
   *  - Pass value greater than 1 to reduce exposure
   * See the {@link https://fujifilm-dsc.com/en/manual/x-pro2/images/exp_exposure_480.gif | image} for visual example
   * @internal
   */
  setExposureCompensation(a) {
    this._preferences.exposureCompensation = a, this._enhancer?.exposureCompensation(this._preferences.exposureCompensation);
  }
  /**
   * Manually starts webcam
   *
   * > Ordinary webcam is lazily started during async iteration over it.
   * >
   * > But sometimes you may want to manually pre-start webcam e.g during parallel creation of a {@link Player} instance:
   * > ```ts
   * > const [webcam, player] = await Promise.all([
   * >  new Webcam().start(),
   * >  Player.create({ clientToken: "xxx-xxx-xxx" }),
   * > ])
   * >
   * > player.use(webcam)
   * > ```
   */
  async start() {
    return await (this._stream ?? (this._stream = Io(this._constraints))), this;
  }
  /**
   * Yields a sequence of {@link Frame | frames}
   * @internal
   */
  async *[Symbol.asyncIterator](a) {
    const n = await (this._stream ?? (this._stream = Io(this._constraints))), l = this._enhancer = Ai(this._preferences) ? Ao(n, this._preferences) : null;
    let v = new Ri(l ? l.stream : n)[Symbol.asyncIterator]({ horizontalFlip: !0, ...a }), w;
    for (; ; ) {
      if (!this._enhancer && Ai(this._preferences)) {
        const L = this._enhancer = Ao(n, this._preferences);
        v = new Ri(L.stream)[Symbol.asyncIterator]({ horizontalFlip: !0, ...a });
      }
      this._enhancer && !Ai(this._preferences) && (this._enhancer.stream.getTracks().forEach((O) => O.stop()), this._enhancer = null, v = new Ri(n)[Symbol.asyncIterator]({ horizontalFlip: !0, ...a }));
      const { done: m, value: D } = await v.next(w);
      if (m)
        break;
      w = yield D;
    }
    this.stop();
  }
  /** Turns off webcam */
  stop() {
    this._stream && this._stream.then((a) => a.getTracks().forEach((n) => n.stop())), this._enhancer && this._enhancer.stream.getTracks().forEach((a) => a.stop()), this._stream = null, this._enhancer = null;
  }
}
const Io = async (r) => {
  if (typeof navigator.mediaDevices > "u")
    throw new Error(
      `SecureContext is required to access webcam
Itâ€˜s likely you need to set up HTTPS/TLS for your website
See https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Encryption_based_security for details `
    );
  return await navigator.mediaDevices.getUserMedia({ video: r });
}, Ai = (r) => typeof r.exposureCompensation == "number" && r.exposureCompensation !== 1 || r.denoise === 1 || r.denoise === 2, Db = { createVideoElement: $n };
let lp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Os = (r = 21) => {
  let a = "", n = r;
  for (; n--; )
    a += lp[Math.random() * 64 | 0];
  return a;
};
const js = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBzPVVpbnQ4QXJyYXkseD1VaW50MTZBcnJheSxPPVVpbnQzMkFycmF5LEg9bmV3IHMoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0pLEk9bmV3IHMoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTMsMCwwXSksbDE9bmV3IHMoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxKPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPW5ldyB4KDMxKSxuPTA7bjwzMTsrK24pYVtuXT10Kz0xPDxyW24tMV07Zm9yKHZhciB2PW5ldyBPKGFbMzBdKSxuPTE7bjwzMDsrK24pZm9yKHZhciBpPWFbbl07aTxhW24rMV07KytpKXZbaV09aS1hW25dPDw1fG47cmV0dXJuW2Esdl19LEs9SihILDIpLFE9S1swXSxjMT1LWzFdO1FbMjhdPTI1OCxjMVsyNThdPTI4O2Zvcih2YXIgczE9SihJLDApLGQxPXMxWzBdLFU9bmV3IHgoMzI3NjgpLHU9MDt1PDMyNzY4OysrdSl7dmFyIEM9KHUmNDM2OTApPj4+MXwodSYyMTg0NSk8PDE7Qz0oQyY1MjQyOCk+Pj4yfChDJjEzMTA3KTw8MixDPShDJjYxNjgwKT4+PjR8KEMmMzg1NSk8PDQsVVt1XT0oKEMmNjUyODApPj4+OHwoQyYyNTUpPDw4KT4+PjF9Zm9yKHZhciB6PWZ1bmN0aW9uKHQsYSxuKXtmb3IodmFyIHY9dC5sZW5ndGgsaT0wLGM9bmV3IHgoYSk7aTx2OysraSl0W2ldJiYrK2NbdFtpXS0xXTt2YXIgZj1uZXcgeChhKTtmb3IoaT0wO2k8YTsrK2kpZltpXT1mW2ktMV0rY1tpLTFdPDwxO3ZhciBvO2lmKG4pe289bmV3IHgoMTw8YSk7dmFyIGU9MTUtYTtmb3IoaT0wO2k8djsrK2kpaWYodFtpXSlmb3IodmFyIGw9aTw8NHx0W2ldLGI9YS10W2ldLGQ9Zlt0W2ldLTFdKys8PGIseT1kfCgxPDxiKS0xO2Q8PXk7KytkKW9bVVtkXT4+PmVdPWx9ZWxzZSBmb3Iobz1uZXcgeCh2KSxpPTA7aTx2OysraSl0W2ldJiYob1tpXT1VW2ZbdFtpXS0xXSsrXT4+PjE1LXRbaV0pO3JldHVybiBvfSxCPW5ldyBzKDI4OCksdT0wO3U8MTQ0OysrdSlCW3VdPTg7Zm9yKHZhciB1PTE0NDt1PDI1NjsrK3UpQlt1XT05O2Zvcih2YXIgdT0yNTY7dTwyODA7Kyt1KUJbdV09Nztmb3IodmFyIHU9MjgwO3U8Mjg4OysrdSlCW3VdPTg7Zm9yKHZhciBWPW5ldyBzKDMyKSx1PTA7dTwzMjsrK3UpVlt1XT01O3ZhciBnMT16KEIsOSwxKSx3MT16KFYsNSwxKSxXPWZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1yWzBdLGE9MTthPHIubGVuZ3RoOysrYSlyW2FdPnQmJih0PXJbYV0pO3JldHVybiB0fSxoPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj10Lzh8MDtyZXR1cm4ocltuXXxyW24rMV08PDgpPj4odCY3KSZhfSxYPWZ1bmN0aW9uKHIsdCl7dmFyIGE9dC84fDA7cmV0dXJuKHJbYV18clthKzFdPDw4fHJbYSsyXTw8MTYpPj4odCY3KX0saDE9ZnVuY3Rpb24ocil7cmV0dXJuKHIrNykvOHwwfSxqPWZ1bmN0aW9uKHIsdCxhKXsodD09bnVsbHx8dDwwKSYmKHQ9MCksKGE9PW51bGx8fGE+ci5sZW5ndGgpJiYoYT1yLmxlbmd0aCk7dmFyIG49bmV3KHIuQllURVNfUEVSX0VMRU1FTlQ9PTI/eDpyLkJZVEVTX1BFUl9FTEVNRU5UPT00P086cykoYS10KTtyZXR1cm4gbi5zZXQoci5zdWJhcnJheSh0LGEpKSxufSxtMT1bInVuZXhwZWN0ZWQgRU9GIiwiaW52YWxpZCBibG9jayB0eXBlIiwiaW52YWxpZCBsZW5ndGgvbGl0ZXJhbCIsImludmFsaWQgZGlzdGFuY2UiLCJzdHJlYW0gZmluaXNoZWQiLCJubyBzdHJlYW0gaGFuZGxlciIsLCJubyBjYWxsYmFjayIsImludmFsaWQgVVRGLTggZGF0YSIsImV4dHJhIGZpZWxkIHRvbyBsb25nIiwiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5IiwiZmlsZW5hbWUgdG9vIGxvbmciLCJzdHJlYW0gZmluaXNoaW5nIiwiaW52YWxpZCB6aXAgZGF0YSJdLGc9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPW5ldyBFcnJvcih0fHxtMVtyXSk7aWYobi5jb2RlPXIsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKG4sZyksIWEpdGhyb3cgbjtyZXR1cm4gbn0sYjE9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPXIubGVuZ3RoO2lmKCFufHxhJiZhLmYmJiFhLmwpcmV0dXJuIHR8fG5ldyBzKDApO3ZhciB2PSF0fHxhLGk9IWF8fGEuaTthfHwoYT17fSksdHx8KHQ9bmV3IHMobiozKSk7dmFyIGM9ZnVuY3Rpb24odTEpe3ZhciB2MT10Lmxlbmd0aDtpZih1MT52MSl7dmFyIGYxPW5ldyBzKE1hdGgubWF4KHYxKjIsdTEpKTtmMS5zZXQodCksdD1mMX19LGY9YS5mfHwwLG89YS5wfHwwLGU9YS5ifHwwLGw9YS5sLGI9YS5kLGQ9YS5tLHk9YS5uLFI9bio4O2Rve2lmKCFsKXtmPWgocixvLDEpO3ZhciBZPWgocixvKzEsMyk7aWYobys9MyxZKWlmKFk9PTEpbD1nMSxiPXcxLGQ9OSx5PTU7ZWxzZSBpZihZPT0yKXt2YXIgUz1oKHIsbywzMSkrMjU3LHIxPWgocixvKzEwLDE1KSs0LHQxPVMraChyLG8rNSwzMSkrMTtvKz0xNDtmb3IodmFyIEY9bmV3IHModDEpLEc9bmV3IHMoMTkpLHc9MDt3PHIxOysrdylHW2wxW3ddXT1oKHIsbyt3KjMsNyk7bys9cjEqMztmb3IodmFyIGExPVcoRyksQjE9KDE8PGExKS0xLFIxPXooRyxhMSwxKSx3PTA7dzx0MTspe3ZhciBuMT1SMVtoKHIsbyxCMSldO28rPW4xJjE1O3ZhciBwPW4xPj4+NDtpZihwPDE2KUZbdysrXT1wO2Vsc2V7dmFyIFQ9MCxOPTA7Zm9yKHA9PTE2PyhOPTMraChyLG8sMyksbys9MixUPUZbdy0xXSk6cD09MTc/KE49MytoKHIsbyw3KSxvKz0zKTpwPT0xOCYmKE49MTEraChyLG8sMTI3KSxvKz03KTtOLS07KUZbdysrXT1UfX12YXIgaTE9Ri5zdWJhcnJheSgwLFMpLF89Ri5zdWJhcnJheShTKTtkPVcoaTEpLHk9VyhfKSxsPXooaTEsZCwxKSxiPXooXyx5LDEpfWVsc2UgZygxKTtlbHNle3ZhciBwPWgxKG8pKzQsTD1yW3AtNF18cltwLTNdPDw4LFo9cCtMO2lmKFo+bil7aSYmZygwKTticmVha312JiZjKGUrTCksdC5zZXQoci5zdWJhcnJheShwLFopLGUpLGEuYj1lKz1MLGEucD1vPVoqOCxhLmY9Zjtjb250aW51ZX1pZihvPlIpe2kmJmcoMCk7YnJlYWt9fXYmJmMoZSsxMzEwNzIpO2Zvcih2YXIgWTE9KDE8PGQpLTEsRjE9KDE8PHkpLTEsJD1vOzskPW8pe3ZhciBUPWxbWChyLG8pJlkxXSxrPVQ+Pj40O2lmKG8rPVQmMTUsbz5SKXtpJiZnKDApO2JyZWFrfWlmKFR8fGcoMiksazwyNTYpdFtlKytdPWs7ZWxzZSBpZihrPT0yNTYpeyQ9byxsPW51bGw7YnJlYWt9ZWxzZXt2YXIgbzE9ay0yNTQ7aWYoaz4yNjQpe3ZhciB3PWstMjU3LE09SFt3XTtvMT1oKHIsbywoMTw8TSktMSkrUVt3XSxvKz1NfXZhciBQPWJbWChyLG8pJkYxXSxEPVA+Pj40O1B8fGcoMyksbys9UCYxNTt2YXIgXz1kMVtEXTtpZihEPjMpe3ZhciBNPUlbRF07Xys9WChyLG8pJigxPDxNKS0xLG8rPU19aWYobz5SKXtpJiZnKDApO2JyZWFrfXYmJmMoZSsxMzEwNzIpO2Zvcih2YXIgZTE9ZStvMTtlPGUxO2UrPTQpdFtlXT10W2UtX10sdFtlKzFdPXRbZSsxLV9dLHRbZSsyXT10W2UrMi1fXSx0W2UrM109dFtlKzMtX107ZT1lMX19YS5sPWwsYS5wPSQsYS5iPWUsYS5mPWYsbCYmKGY9MSxhLm09ZCxhLmQ9YixhLm49eSl9d2hpbGUoIWYpO3JldHVybiBlPT10Lmxlbmd0aD90OmoodCwwLGUpfSx5MT1uZXcgcygwKSxFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHJbdF18clt0KzFdPDw4fSxtPWZ1bmN0aW9uKHIsdCl7cmV0dXJuKHJbdF18clt0KzFdPDw4fHJbdCsyXTw8MTZ8clt0KzNdPDwyNCk+Pj4wfSxxPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIG0ocix0KSttKHIsdCs0KSo0Mjk0OTY3Mjk2fTtmdW5jdGlvbiBFMShyLHQpe3JldHVybiBiMShyLHQpfXZhciBBPXR5cGVvZiBUZXh0RGVjb2RlcjwidSImJm5ldyBUZXh0RGVjb2RlcixwMT0wO3RyeXtBLmRlY29kZSh5MSx7c3RyZWFtOiEwfSkscDE9MX1jYXRjaHt9dmFyIEMxPWZ1bmN0aW9uKHIpe2Zvcih2YXIgdD0iIixhPTA7Oyl7dmFyIG49clthKytdLHY9KG4+MTI3KSsobj4yMjMpKyhuPjIzOSk7aWYoYSt2PnIubGVuZ3RoKXJldHVyblt0LGoocixhLTEpXTt2P3Y9PTM/KG49KChuJjE1KTw8MTh8KHJbYSsrXSY2Myk8PDEyfChyW2ErK10mNjMpPDw2fHJbYSsrXSY2MyktNjU1MzYsdCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxuPj4xMCw1NjMyMHxuJjEwMjMpKTp2JjE/dCs9U3RyaW5nLmZyb21DaGFyQ29kZSgobiYzMSk8PDZ8clthKytdJjYzKTp0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKChuJjE1KTw8MTJ8KHJbYSsrXSY2Myk8PDZ8clthKytdJjYzKTp0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pfX07ZnVuY3Rpb24gUzEocix0KXtpZih0KXtmb3IodmFyIGE9IiIsbj0wO248ci5sZW5ndGg7bis9MTYzODQpYSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHIuc3ViYXJyYXkobixuKzE2Mzg0KSk7cmV0dXJuIGF9ZWxzZXtpZihBKXJldHVybiBBLmRlY29kZShyKTt2YXIgdj1DMShyKSxpPXZbMF0sYz12WzFdO3JldHVybiBjLmxlbmd0aCYmZyg4KSxpfX12YXIgXzE9ZnVuY3Rpb24ocix0KXtyZXR1cm4gdCszMCtFKHIsdCsyNikrRShyLHQrMjgpfSx4MT1mdW5jdGlvbihyLHQsYSl7dmFyIG49RShyLHQrMjgpLHY9UzEoci5zdWJhcnJheSh0KzQ2LHQrNDYrbiksIShFKHIsdCs4KSYyMDQ4KSksaT10KzQ2K24sYz1tKHIsdCsyMCksZj1hJiZjPT00Mjk0OTY3Mjk1P1QxKHIsaSk6W2MsbShyLHQrMjQpLG0ocix0KzQyKV0sbz1mWzBdLGU9ZlsxXSxsPWZbMl07cmV0dXJuW0Uocix0KzEwKSxvLGUsdixpK0Uocix0KzMwKStFKHIsdCszMiksbF19LFQxPWZ1bmN0aW9uKHIsdCl7Zm9yKDtFKHIsdCkhPTE7dCs9NCtFKHIsdCsyKSk7cmV0dXJuW3Eocix0KzEyKSxxKHIsdCs0KSxxKHIsdCsyMCldfTtmdW5jdGlvbiBrMShyLHQpe2Zvcih2YXIgYT17fSxuPXIubGVuZ3RoLTIyO20ocixuKSE9MTAxMDEwMjU2Oy0tbikoIW58fHIubGVuZ3RoLW4+NjU1NTgpJiZnKDEzKTt2YXIgdj1FKHIsbis4KTtpZighdilyZXR1cm57fTt2YXIgaT1tKHIsbisxNiksYz1pPT00Mjk0OTY3Mjk1O2MmJihuPW0ocixuLTEyKSxtKHIsbikhPTEwMTA3NTc5MiYmZygxMyksdj1tKHIsbiszMiksaT1tKHIsbis0OCkpO2Zvcih2YXIgZj10JiZ0LmZpbHRlcixvPTA7bzx2Oysrbyl7dmFyIGU9eDEocixpLGMpLGw9ZVswXSxiPWVbMV0sZD1lWzJdLHk9ZVszXSxSPWVbNF0sWT1lWzVdLFM9XzEocixZKTtpPVIsKCFmfHxmKHtuYW1lOnksc2l6ZTpiLG9yaWdpbmFsU2l6ZTpkLGNvbXByZXNzaW9uOmx9KSkmJihsP2w9PTg/YVt5XT1FMShyLnN1YmFycmF5KFMsUytiKSxuZXcgcyhkKSk6ZygxNCwidW5rbm93biBjb21wcmVzc2lvbiB0eXBlICIrbCk6YVt5XT1qKHIsUyxTK2IpKX1yZXR1cm4gYX1jb25zdCB6MT1yPT5rMShyLHtmaWx0ZXI6KHtuYW1lOnR9KT0+ISh0LnN0YXJ0c1dpdGgoIl9fTUFDT1NYLyIpfHx0LmluY2x1ZGVzKCIuRFNfU3RvcmUiKSl9KTthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoe2RhdGE6cn0pPT57bGV0IHQ7dHJ5e3Q9e2lkOnIuaWQsZGF0YTp6MShyLmRhdGEpfX1jYXRjaChhKXt0PXtpZDpyLmlkLGVycm9yOmEubWVzc2FnZX19cG9zdE1lc3NhZ2UodCl9KX0pKCk7Cg==", Po = typeof window < "u" && window.Blob && new Blob([atob(js)], { type: "text/javascript;charset=utf-8" });
function fp() {
  let r;
  try {
    if (r = Po && (window.URL || window.webkitURL).createObjectURL(Po), !r)
      throw "";
    return new Worker(r);
  } catch {
    return new Worker("data:application/javascript;base64," + js);
  } finally {
    r && (window.URL || window.webkitURL).revokeObjectURL(r);
  }
}
let Wr;
const cp = async (r) => new Promise((a, n) => {
  const l = Os(), _ = new Uint8Array(r), v = { id: l, data: _ };
  Wr || (Wr = new fp());
  const w = ({ data: m }) => {
    m.id === v.id && (Wr.removeEventListener("message", w), "error" in m && n(new Error(m.error)), "data" in m && a(m.data));
  };
  Wr.addEventListener("message", w), Wr.postMessage(v, [r]);
}), Ii = "/";
class Us {
  constructor(a) {
    le(this, "_source", null);
    le(this, "_fs", null);
    le(this, "_mountpoint", Ii);
    le(this, "_data", {});
    this._source = a;
  }
  static async preload(a, n) {
    if (Array.isArray(a)) {
      const _ = n?.onProgress;
      return await Promise.all(
        a.map((v, w) => {
          const m = _ ? { onProgress: (...D) => _(w, ...D) } : {};
          return this.preload(v, m);
        })
      );
    }
    const l = new this(a);
    return await l.load(n), l;
  }
  /** Template method for data fetching */
  async _fetch(a, n) {
    return await Oh(a, {}, n).then((l) => {
      if (l.ok)
        return l.blob();
      throw new Error(
        `Failed to fetch ${a.url} ${l.status} (${l.statusText})`
      );
    }).then((l) => {
      if (l.size > 0)
        return l;
      throw new Error(`The source must not be empty. Received ${l.size} bytes size source.`);
    });
  }
  /** Template method for data decompression */
  async _unzip(a) {
    if (!a.type.includes("zip"))
      throw new TypeError(
        `The source type must be "application/zip"-like. Received: "${a.type}".`
      );
    return await a.arrayBuffer().then(cp).then((n) => Object.entries(n)).then((n) => Object.fromEntries(n));
  }
  /** Loads the resource data */
  async load(a) {
    let n = this._source;
    return typeof n == "string" && (n = new Request(n)), n instanceof Request && (n = await this._fetch(n, a)), n instanceof Blob && (n = await this._unzip(n)), n instanceof Object && n.constructor === Object && await Promise.all(
      Object.entries(n).map(([l, _]) => this.writeFile(l, _))
    ), this._source = null, this._data;
  }
  _fsWriteFile(a, n) {
    this._fs && (a = `${this._mountpoint}${a.startsWith("/") ? a.substring(1) : a}`, this._fs.writeFile(a, n));
  }
  async writeFile(a, n) {
    const l = new Uint8Array(n instanceof Blob ? await n.arrayBuffer() : n);
    this._data[a] = l, this._fsWriteFile(a, this._data[a]);
  }
  /** Mounts the resource to the supplied file system */
  mount(a, n = Ii) {
    this._fs = a, this._mountpoint = n.endsWith("/") ? n : `${n}/`, Object.entries(this._data).forEach(([l, _]) => this._fsWriteFile(l, _));
  }
  /** Unmounts the resource from the previously supplied file system */
  unmount() {
    this._fs = null, this._mountpoint = Ii;
  }
}
var dp = Object.defineProperty, hp = Object.getOwnPropertyDescriptor, pp = (r, a, n, l) => {
  for (var _ = l > 1 ? void 0 : l ? hp(a, n) : a, v = r.length - 1, w; v >= 0; v--)
    (w = r[v]) && (_ = (l ? w(a, n, _) : w(_)) || _);
  return l && _ && dp(a, n, _), _;
};
class mp {
  constructor(a) {
    /** @internal */
    le(this, "name", `effects/${Os()}`);
    le(this, "_player", null);
    le(this, "_resource");
    this._resource = new _p(a);
  }
  static async preload(a, n) {
    if (Array.isArray(a)) {
      const _ = n?.onProgress;
      return await Promise.all(
        a.map((v, w) => {
          const m = _ ? { onProgress: (...D) => _(w, ...D) } : {};
          return this.preload(v, m);
        })
      );
    }
    const l = new this(a);
    return await l._load(n), l;
  }
  /** Loads the effect data */
  async _load(a) {
    await this._resource.load(a);
  }
  /** Loads the effect data, mounts it to the playerâ€˜s file system */
  async _bind(a) {
    await this._resource.load(), this._player = a, this._resource.mount(this._player.FS, this.name);
  }
  /** Unmounts the effect data from the previously specified playerâ€˜s file system */
  _unbind() {
    this._resource.unmount(), this._player = null;
  }
  async writeFile(a, n) {
    return this._resource.writeFile(a, n);
  }
  callJsMethod(a, n = "") {
    if (!this._player) {
      console.warn("The method won't evaluate: the effect is not applied to a player.");
      return;
    }
    return this._player.callJsMethod(a, n);
  }
  /**
   * Evaluates JavaScript in context of the effect.
   *
   * The script won't evaluate if the effect is not applied to a player
   * @example
   * ```ts
   * const makeup = new Effect("/path/to/Makeup.zip")
   *
   * await player.applyEffect(makeup)
   *
   * // ...
   *
   * const electricBlueColor = "0.09 0.25 0.38"
   *
   * await makeup.evalJs(`Eyes.color("${electricBlueColor}")`)
   * ```
   */
  async evalJs(a) {
    if (!this._player) {
      console.warn("The script won't evaluate: the effect is not applied to a player.");
      return;
    }
    return await this._player.evalJs(a);
  }
}
pp([
  Is("Please, use Effect.evalJs() instead.")
], mp.prototype, "callJsMethod", 1);
class _p extends Us {
  async _unzip(a) {
    let n = await super._unzip(a);
    const _ = Object.keys(n).map((m) => m.split("/").find(Boolean)), v = _[0];
    return _.every((m) => m === v) && (n = Object.fromEntries(
      Object.entries(n).map(([m, D]) => [
        m.replace(`${v}/`, ""),
        D
      ])
    )), n;
  }
}
let Lb = class {
  constructor(a) {
    le(this, "_resource");
    this._resource = new Us(a);
  }
  static async preload(a, n) {
    if (Array.isArray(a)) {
      const _ = n?.onProgress;
      return await Promise.all(
        a.map((v, w) => {
          const m = _ ? { onProgress: (...D) => _(w, ...D) } : {};
          return this.preload(v, m);
        })
      );
    }
    const l = new this(a);
    return await l._load(n), l;
  }
  /** Loads the module data */
  async _load(a) {
    await this._resource.load(a);
  }
  /** Loads the module data, mounts it to the player's file system */
  async _bind(a) {
    await this._resource.load(), this._resource.mount(a.FS);
  }
};
var bp = (() => {
  var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(a = {}) {
    var n = a, l, _;
    n.ready = new Promise((e, t) => {
      l = e, _ = t;
    }), n.expectedDataFileDownloads || (n.expectedDataFileDownloads = 0), n.expectedDataFileDownloads++, function() {
      if (!(n.ENVIRONMENT_IS_PTHREAD || n.$ww)) {
        var e = function(t) {
          typeof window == "object" ? window.encodeURIComponent(window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/") : typeof process > "u" && typeof location < "u" && encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/");
          var i = "BanubaSDK.data", o = "BanubaSDK.data";
          typeof n.locateFilePackage == "function" && !n.locateFile && (n.locateFile = n.locateFilePackage, pe("warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)"));
          var s = n.locateFile ? n.locateFile(o, "") : o, c = t.remote_package_size;
          function h(P, W, U, G) {
            var re = new XMLHttpRequest();
            re.open("GET", P, !0), re.responseType = "arraybuffer", re.onprogress = function(se) {
              var fe = P, be = W;
              if (se.total && (be = se.total), se.loaded) {
                re.addedTotal ? n.dataFileDownloads[fe].loaded = se.loaded : (re.addedTotal = !0, n.dataFileDownloads || (n.dataFileDownloads = {}), n.dataFileDownloads[fe] = { loaded: se.loaded, total: be });
                var H = 0, ne = 0, ve = 0;
                for (var Se in n.dataFileDownloads) {
                  var ue = n.dataFileDownloads[Se];
                  H += ue.total, ne += ue.loaded, ve++;
                }
                H = Math.ceil(H * n.expectedDataFileDownloads / ve), n.setStatus && n.setStatus(`Downloading data... (${ne}/${H})`);
              } else
                n.dataFileDownloads || n.setStatus && n.setStatus("Downloading data...");
            }, re.onerror = function(se) {
              throw new Error("NetworkError for: " + P);
            }, re.onload = function(se) {
              if (re.status == 200 || re.status == 304 || re.status == 206 || re.status == 0 && re.response) {
                var fe = re.response;
                U(fe);
              } else
                throw new Error(re.statusText + " : " + re.responseURL);
            }, re.send(null);
          }
          var b = null, x = n.getPreloadedPackage ? n.getPreloadedPackage(s, c) : null;
          x || h(s, c, function(P) {
            b ? (b(P), b = null) : x = P;
          });
          function F() {
            function P(se, fe) {
              if (!se)
                throw fe + new Error().stack;
            }
            n.FS_createPath("/", "bnb_js", !0, !0), n.FS_createPath("/", "bnb_prefabs", !0, !0), n.FS_createPath("/bnb_prefabs", "audio", !0, !0), n.FS_createPath("/bnb_prefabs", "base", !0, !0), n.FS_createPath("/bnb_prefabs", "camera", !0, !0), n.FS_createPath("/bnb_prefabs/camera", "images", !0, !0), n.FS_createPath("/bnb_prefabs", "foreground", !0, !0), n.FS_createPath("/bnb_prefabs", "gltf", !0, !0), n.FS_createPath("/bnb_prefabs/gltf", "meshes", !0, !0), n.FS_createPath("/bnb_prefabs/gltf", "shaders", !0, !0), n.FS_createPath("/bnb_prefabs", "hint", !0, !0), n.FS_createPath("/bnb_prefabs/hint", "font", !0, !0), n.FS_createPath("/bnb_prefabs/hint", "meshes", !0, !0), n.FS_createPath("/bnb_prefabs/hint", "scripts", !0, !0), n.FS_createPath("/bnb_prefabs/hint", "shaders", !0, !0), n.FS_createPath("/bnb_prefabs", "lights", !0, !0), n.FS_createPath("/bnb_prefabs", "lut", !0, !0), n.FS_createPath("/bnb_prefabs/lut", "scripts", !0, !0), n.FS_createPath("/bnb_prefabs/lut", "shaders", !0, !0), n.FS_createPath("/bnb_prefabs/lut/shaders", "lut-filter", !0, !0), n.FS_createPath("/bnb_prefabs/lut", "textures", !0, !0), n.FS_createPath("/bnb_prefabs", "msaa", !0, !0), n.FS_createPath("/", "bnb_shaders", !0, !0), n.FS_createPath("/bnb_shaders", "bnb", !0, !0), n.FS_createPath("/bnb_shaders/bnb", "lib", !0, !0), n.FS_createPath("/", "frx", !0, !0);
            function W(se, fe, be) {
              this.start = se, this.end = fe, this.audio = be;
            }
            W.prototype = { requests: {}, open: function(se, fe) {
              this.name = fe, this.requests[fe] = this, n.addRunDependency(`fp ${this.name}`);
            }, send: function() {
            }, onload: function() {
              var se = this.byteArray.subarray(this.start, this.end);
              this.finish(se);
            }, finish: function(se) {
              var fe = this;
              n.FS_createDataFile(this.name, null, se, !0, !0, !0), n.removeRunDependency(`fp ${fe.name}`), this.requests[this.name] = null;
            } };
            for (var U = t.files, G = 0; G < U.length; ++G)
              new W(U[G].start, U[G].end, U[G].audio || 0).open("GET", U[G].filename);
            function re(se) {
              P(se, "Loading data file failed."), P(se.constructor.name === ArrayBuffer.name, "bad input to processPackageData");
              var fe = new Uint8Array(se);
              W.prototype.byteArray = fe;
              for (var be = t.files, H = 0; H < be.length; ++H)
                W.prototype.requests[be[H].filename].onload();
              n.removeRunDependency("datafile_BanubaSDK.data");
            }
            n.addRunDependency("datafile_BanubaSDK.data"), n.preloadResults || (n.preloadResults = {}), n.preloadResults[i] = { fromCache: !1 }, x ? (re(x), x = null) : b = re;
          }
          n.calledRun ? F() : (n.preRun || (n.preRun = []), n.preRun.push(F));
        };
        e({ files: [{ filename: "/bnb_js/.empty", start: 0, end: 20 }, { filename: "/bnb_js/background.js", start: 20, end: 3866 }, { filename: "/bnb_js/console.js", start: 3866, end: 4426 }, { filename: "/bnb_js/global.js", start: 4426, end: 4807 }, { filename: "/bnb_js/legacy.js", start: 4807, end: 9131 }, { filename: "/bnb_js/light_streaks.js", start: 9131, end: 18838 }, { filename: "/bnb_js/prefabs.js", start: 18838, end: 21147 }, { filename: "/bnb_js/timers.js", start: 21147, end: 24466 }, { filename: "/bnb_prefabs/audio/config.js", start: 24466, end: 25841 }, { filename: "/bnb_prefabs/audio/config.json", start: 25841, end: 25911 }, { filename: "/bnb_prefabs/audio/schema.json", start: 25911, end: 26467 }, { filename: "/bnb_prefabs/base/config.json", start: 26467, end: 27096 }, { filename: "/bnb_prefabs/camera/config.json", start: 27096, end: 28766 }, { filename: "/bnb_prefabs/camera/images/ibl_diff.ktx", start: 28766, end: 53410 }, { filename: "/bnb_prefabs/camera/images/ibl_spec.ktx", start: 53410, end: 348394 }, { filename: "/bnb_prefabs/camera/schema.json", start: 348394, end: 348474 }, { filename: "/bnb_prefabs/foreground/config.js", start: 348474, end: 349810 }, { filename: "/bnb_prefabs/foreground/config.json", start: 349810, end: 351003 }, { filename: "/bnb_prefabs/foreground/foreground.frag", start: 351003, end: 351191 }, { filename: "/bnb_prefabs/foreground/foreground.vert", start: 351191, end: 351441 }, { filename: "/bnb_prefabs/foreground/null_image.png", start: 351441, end: 351509 }, { filename: "/bnb_prefabs/foreground/schema.json", start: 351509, end: 352201 }, { filename: "/bnb_prefabs/gltf/config.js", start: 352201, end: 355868 }, { filename: "/bnb_prefabs/gltf/config.json", start: 355868, end: 358871 }, { filename: "/bnb_prefabs/gltf/meshes/cut.bsm2", start: 358871, end: 415148 }, { filename: "/bnb_prefabs/gltf/meshes/cut_ears.bsm2", start: 415148, end: 491309 }, { filename: "/bnb_prefabs/gltf/schema.json", start: 491309, end: 496083 }, { filename: "/bnb_prefabs/gltf/shaders/mat_cut.frag", start: 496083, end: 496169 }, { filename: "/bnb_prefabs/gltf/shaders/mat_cut.vert", start: 496169, end: 497877 }, { filename: "/bnb_prefabs/hint/config.json", start: 497877, end: 499561 }, { filename: "/bnb_prefabs/hint/font/NotoSans-Regular.ttf", start: 499561, end: 898529 }, { filename: "/bnb_prefabs/hint/meshes/quad.bsm2", start: 898529, end: 898807 }, { filename: "/bnb_prefabs/hint/schema.json", start: 898807, end: 899844 }, { filename: "/bnb_prefabs/hint/scripts/index.js", start: 899844, end: 902890 }, { filename: "/bnb_prefabs/hint/shaders/text.frag", start: 902890, end: 903120 }, { filename: "/bnb_prefabs/hint/shaders/text.vert", start: 903120, end: 903364 }, { filename: "/bnb_prefabs/lights/config.js", start: 903364, end: 904697 }, { filename: "/bnb_prefabs/lights/config.json", start: 904697, end: 905008 }, { filename: "/bnb_prefabs/lights/schema.json", start: 905008, end: 905814 }, { filename: "/bnb_prefabs/lut/config.json", start: 905814, end: 907297 }, { filename: "/bnb_prefabs/lut/schema.json", start: 907297, end: 907742 }, { filename: "/bnb_prefabs/lut/scripts/index.js", start: 907742, end: 909053 }, { filename: "/bnb_prefabs/lut/shaders/lut-filter/lut_filter.frag", start: 909053, end: 909504 }, { filename: "/bnb_prefabs/lut/shaders/lut-filter/lut_filter.vert", start: 909504, end: 909754 }, { filename: "/bnb_prefabs/lut/textures/_null_lut_.png", start: 909754, end: 914712 }, { filename: "/bnb_prefabs/msaa/config.js", start: 914712, end: 915135 }, { filename: "/bnb_prefabs/msaa/config.json", start: 915135, end: 915206 }, { filename: "/bnb_prefabs/msaa/schema.json", start: 915206, end: 915685 }, { filename: "/bnb_shaders/.empty", start: 915685, end: 915704 }, { filename: "/bnb_shaders/bnb/anim_transform.glsl", start: 915704, end: 915867 }, { filename: "/bnb_shaders/bnb/color_spaces.glsl", start: 915867, end: 921714 }, { filename: "/bnb_shaders/bnb/decode_int1010102.glsl", start: 921714, end: 922403 }, { filename: "/bnb_shaders/bnb/get_bone.glsl", start: 922403, end: 922825 }, { filename: "/bnb_shaders/bnb/get_transform.glsl", start: 922825, end: 923464 }, { filename: "/bnb_shaders/bnb/glsl.frag", start: 923464, end: 924026 }, { filename: "/bnb_shaders/bnb/glsl.vert", start: 924026, end: 924807 }, { filename: "/bnb_shaders/bnb/lib/apply_light_streaks.frag", start: 924807, end: 925119 }, { filename: "/bnb_shaders/bnb/lib/apply_light_streaks.vert", start: 925119, end: 925368 }, { filename: "/bnb_shaders/bnb/lib/auto_morph.frag", start: 925368, end: 925481 }, { filename: "/bnb_shaders/bnb/lib/auto_morph.vert", start: 925481, end: 926093 }, { filename: "/bnb_shaders/bnb/lib/auto_morph_fisheye.frag", start: 926093, end: 926206 }, { filename: "/bnb_shaders/bnb/lib/auto_morph_fisheye.vert", start: 926206, end: 926713 }, { filename: "/bnb_shaders/bnb/lib/beauty_morph.frag", start: 926713, end: 926827 }, { filename: "/bnb_shaders/bnb/lib/beauty_morph.vert", start: 926827, end: 927976 }, { filename: "/bnb_shaders/bnb/lib/bg_blur_downscale.frag", start: 927976, end: 928850 }, { filename: "/bnb_shaders/bnb/lib/bg_blur_downscale.vert", start: 928850, end: 929049 }, { filename: "/bnb_shaders/bnb/lib/bg_blur_upscale.frag", start: 929049, end: 930044 }, { filename: "/bnb_shaders/bnb/lib/bg_blur_upscale.vert", start: 930044, end: 930379 }, { filename: "/bnb_shaders/bnb/lib/bg_blur_upscale_apply.frag", start: 930379, end: 931584 }, { filename: "/bnb_shaders/bnb/lib/camera.frag", start: 931584, end: 932165 }, { filename: "/bnb_shaders/bnb/lib/camera.vert", start: 932165, end: 932484 }, { filename: "/bnb_shaders/bnb/lib/camera_bgmask.frag", start: 932484, end: 933243 }, { filename: "/bnb_shaders/bnb/lib/camera_bgmask.vert", start: 933243, end: 933632 }, { filename: "/bnb_shaders/bnb/lib/copy_pixels.frag", start: 933632, end: 933806 }, { filename: "/bnb_shaders/bnb/lib/copy_pixels.vert", start: 933806, end: 934055 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_0.frag", start: 934055, end: 935041 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_0.vert", start: 935041, end: 935626 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_1.frag", start: 935626, end: 936612 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_1.vert", start: 936612, end: 937197 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_2.frag", start: 937197, end: 938183 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_2.vert", start: 938183, end: 938768 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_3.frag", start: 938768, end: 939754 }, { filename: "/bnb_shaders/bnb/lib/filter_light_streaks_3.vert", start: 939754, end: 940339 }, { filename: "/bnb_shaders/bnb/lib/gltf.frag", start: 940339, end: 943072 }, { filename: "/bnb_shaders/bnb/lib/gltf.vert", start: 943072, end: 944786 }, { filename: "/bnb_shaders/bnb/lib/gltf_physics.vert", start: 944786, end: 946388 }, { filename: "/bnb_shaders/bnb/lib/gltf_spec_gloss.frag", start: 946388, end: 948201 }, { filename: "/bnb_shaders/bnb/lib/gltf_spec_gloss.vert", start: 948201, end: 949915 }, { filename: "/bnb_shaders/bnb/lib/gltf_spec_gloss_physics.vert", start: 949915, end: 951517 }, { filename: "/bnb_shaders/bnb/lib/gltf_transmissive.frag", start: 951517, end: 953795 }, { filename: "/bnb_shaders/bnb/lib/gltf_transmissive.vert", start: 953795, end: 955636 }, { filename: "/bnb_shaders/bnb/lib/gltf_transmissive_physics.vert", start: 955636, end: 957365 }, { filename: "/bnb_shaders/bnb/lib/init_light_streaks.frag", start: 957365, end: 957695 }, { filename: "/bnb_shaders/bnb/lib/init_light_streaks.vert", start: 957695, end: 957944 }, { filename: "/bnb_shaders/bnb/lib/mesh_morph.frag", start: 957944, end: 958058 }, { filename: "/bnb_shaders/bnb/lib/mesh_morph.vert", start: 958058, end: 959941 }, { filename: "/bnb_shaders/bnb/lib/morph_apply.frag", start: 959941, end: 960284 }, { filename: "/bnb_shaders/bnb/lib/morph_apply.vert", start: 960284, end: 962466 }, { filename: "/bnb_shaders/bnb/lib/morph_blur.frag", start: 962466, end: 963789 }, { filename: "/bnb_shaders/bnb/lib/morph_blur.vert", start: 963789, end: 964115 }, { filename: "/bnb_shaders/bnb/lib/retouch.frag", start: 964115, end: 967807 }, { filename: "/bnb_shaders/bnb/lib/retouch.vert", start: 967807, end: 968365 }, { filename: "/bnb_shaders/bnb/lib/static_pos.frag", start: 968365, end: 968476 }, { filename: "/bnb_shaders/bnb/lib/static_pos.vert", start: 968476, end: 968742 }, { filename: "/bnb_shaders/bnb/lib/uv_morph.frag", start: 968742, end: 968855 }, { filename: "/bnb_shaders/bnb/lib/uv_morph.vert", start: 968855, end: 969362 }, { filename: "/bnb_shaders/bnb/lib/vbg.frag", start: 969362, end: 970269 }, { filename: "/bnb_shaders/bnb/lib/vbg.vert", start: 970269, end: 971309 }, { filename: "/bnb_shaders/bnb/lut.glsl", start: 971309, end: 975838 }, { filename: "/bnb_shaders/bnb/math.glsl", start: 975838, end: 975838 }, { filename: "/bnb_shaders/bnb/matrix_operations.glsl", start: 975838, end: 976322 }, { filename: "/bnb_shaders/bnb/morph_transform.glsl", start: 976322, end: 977380 }, { filename: "/bnb_shaders/bnb/pbr.glsl", start: 977380, end: 980972 }, { filename: "/bnb_shaders/bnb/quat_rotation.glsl", start: 980972, end: 982366 }, { filename: "/bnb_shaders/bnb/sample_camera.glsl", start: 982366, end: 983303 }, { filename: "/bnb_shaders/bnb/samplers_declaration.glsl", start: 983303, end: 986047 }, { filename: "/bnb_shaders/bnb/texture_bicubic.glsl", start: 986047, end: 987405 }, { filename: "/bnb_shaders/bnb/textures_lookup.glsl", start: 987405, end: 988605 }, { filename: "/bnb_shaders/bnb/transform_uv.glsl", start: 988605, end: 991042 }, { filename: "/bnb_shaders/bnb/version.glsl", start: 991042, end: 991264 }, { filename: "/frx/frx.js", start: 991264, end: 994181 }, { filename: "/modules.json", start: 994181, end: 1007839 }, { filename: "/resources-versions.txt", start: 1007839, end: 1010560 }, { filename: "/watermark.png", start: 1010560, end: 1013046 }, { filename: "/watermark_blurred.png", start: 1013046, end: 1035479 }], remote_package_size: 1035479 });
      }
    }();
    var v = Object.assign({}, n), w = "./this.program", m = (e, t) => {
      throw t;
    }, D = !0, L = !1, O = "";
    function J(e) {
      return n.locateFile ? n.locateFile(e, O) : O + e;
    }
    var ae, q;
    typeof document < "u" && document.currentScript && (O = document.currentScript.src), r && (O = r), O.indexOf("blob:") !== 0 ? O = O.substr(0, O.replace(/[?#].*/, "").lastIndexOf("/") + 1) : O = "", ae = (e) => {
      var t = new XMLHttpRequest();
      return t.open("GET", e, !1), t.send(null), t.responseText;
    }, q = (e, t, i) => {
      var o = new XMLHttpRequest();
      o.open("GET", e, !0), o.responseType = "arraybuffer", o.onload = () => {
        if (o.status == 200 || o.status == 0 && o.response) {
          t(o.response);
          return;
        }
        i();
      }, o.onerror = i, o.send(null);
    };
    var K = n.print || console.log.bind(console), pe = n.printErr || console.error.bind(console);
    Object.assign(n, v), v = null, n.thisProgram && (w = n.thisProgram), n.quit && (m = n.quit);
    var he;
    n.wasmBinary && (he = n.wasmBinary);
    var ce = n.noExitRuntime || !0;
    typeof WebAssembly != "object" && qe("no native wasm support detected");
    var ee, Te = !1, Oe;
    function me(e, t) {
      e || qe(t);
    }
    var Ee, de, Re, ye, I, X, je, De;
    function ke() {
      var e = ee.buffer;
      n.HEAP8 = Ee = new Int8Array(e), n.HEAP16 = Re = new Int16Array(e), n.HEAP32 = I = new Int32Array(e), n.HEAPU8 = de = new Uint8Array(e), n.HEAPU16 = ye = new Uint16Array(e), n.HEAPU32 = X = new Uint32Array(e), n.HEAPF32 = je = new Float32Array(e), n.HEAPF64 = De = new Float64Array(e);
    }
    var ge, $e = [], ze = [], Be = [], it = 0;
    function ie() {
      return ce || it > 0;
    }
    function we() {
      if (n.preRun)
        for (typeof n.preRun == "function" && (n.preRun = [n.preRun]); n.preRun.length; )
          wt(n.preRun.shift());
      $($e);
    }
    function Ie() {
      !n.noFSInit && !g.init.initialized && g.init(), g.ignorePermissions = !1, $(ze);
    }
    function gt() {
      if (n.postRun)
        for (typeof n.postRun == "function" && (n.postRun = [n.postRun]); n.postRun.length; )
          Pt(n.postRun.shift());
      $(Be);
    }
    function wt(e) {
      $e.unshift(e);
    }
    function lt(e) {
      ze.unshift(e);
    }
    function Pt(e) {
      Be.unshift(e);
    }
    var Je = 0, Ye = null;
    function ft(e) {
      return e;
    }
    function mt(e) {
      Je++, n.monitorRunDependencies && n.monitorRunDependencies(Je);
    }
    function rt(e) {
      if (Je--, n.monitorRunDependencies && n.monitorRunDependencies(Je), Je == 0 && Ye) {
        var t = Ye;
        Ye = null, t();
      }
    }
    function qe(e) {
      n.onAbort && n.onAbort(e), e = "Aborted(" + e + ")", pe(e), Te = !0, Oe = 1, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw _(t), t;
    }
    var M = "data:application/octet-stream;base64,";
    function j(e) {
      return e.startsWith(M);
    }
    var Q;
    Q = "BanubaSDK.wasm", j(Q) || (Q = J(Q));
    function E(e) {
      if (e == Q && he)
        return new Uint8Array(he);
      throw "both async and sync fetching of the wasm failed";
    }
    function d(e) {
      return !he && D && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((t) => {
        if (!t.ok)
          throw "failed to load wasm binary file at '" + e + "'";
        return t.arrayBuffer();
      }).catch(() => E(e)) : Promise.resolve().then(() => E(e));
    }
    function p(e, t, i) {
      return d(e).then((o) => WebAssembly.instantiate(o, t)).then((o) => o).then(i, (o) => {
        pe("failed to asynchronously prepare wasm: " + o), qe(o);
      });
    }
    function T(e, t, i, o) {
      return !e && typeof WebAssembly.instantiateStreaming == "function" && !j(t) && typeof fetch == "function" ? fetch(t, { credentials: "same-origin" }).then((s) => {
        var c = WebAssembly.instantiateStreaming(s, i);
        return c.then(o, function(h) {
          return pe("wasm streaming compile failed: " + h), pe("falling back to ArrayBuffer instantiation"), p(t, i, o);
        });
      }) : p(t, i, o);
    }
    function B() {
      var e = { env: fo, wasi_snapshot_preview1: fo };
      function t(o, s) {
        var c = o.exports;
        return n.asm = c, ee = n.asm.memory, ke(), ge = n.asm.__indirect_function_table, lt(n.asm.__wasm_call_ctors), rt(), c;
      }
      mt();
      function i(o) {
        t(o.instance);
      }
      if (n.instantiateWasm)
        try {
          return n.instantiateWasm(e, t);
        } catch (o) {
          pe("Module.instantiateWasm callback failed with error: " + o), _(o);
        }
      return T(he, Q, e, i).catch(_), {};
    }
    var N, V;
    function Ce() {
      return /electron/i.test(navigator.userAgent);
    }
    function Ne() {
      function e() {
        var s = self.top, c = self.parent, h = [];
        do {
          try {
            h.push(c.location.href);
          } catch {
          }
          c && (c = c.parent);
        } while (c && c !== s);
        return h;
      }
      var t = [self.location.href].concat(Array.from("ancestorOrigins" in self.location ? self.location.ancestorOrigins : e())).map(function(s) {
        return new URL(s.replace(/^blob:/, "")).hostname;
      }).find(function(s) {
        return !!s;
      }), i = at(t) + 1, o = Lt(i);
      return ot(t, o, i), o;
    }
    function S(e, t) {
      const i = Xe(e), o = g.readFile(i), s = document.createElement("video"), c = URL.createObjectURL(new Blob([o], { type: "video/mp4" })), h = n.proxyVideoRequestsTo;
      s.muted = !0, s.autoplay = !1, s.controls = !1, s.playsInline = !0, s.src = h ? h + encodeURIComponent(c) : c;
      var b = He.toValue(t);
      return s.onloadedmetadata = (x) => {
        b(x);
      }, He.toHandle(s);
    }
    function R(e) {
      const t = He.toValue(e);
      URL.revokeObjectURL(t.src), t.src = "";
    }
    function y(e, t, i, o) {
      const s = ge.length, c = new Uint8Array(de.slice(e + t, e + i));
      try {
        var h = new WebAssembly.Module(c), b = new WebAssembly.Instance(h, { env: { memory: ee } });
        for (var x in b.exports) {
          var F = b.exports[x];
          addFunction(F);
        }
        return s < ge.length ? s : o;
      } catch (P) {
        return console.log(P), o;
      }
    }
    function u() {
      function e(o) {
        return o.toString(16).padStart(2, "0");
      }
      let t = localStorage.getItem("billing_id");
      if (!t) {
        var i = new Uint8Array(8);
        window.crypto.getRandomValues(i), t = Array.from(i, e).join(""), localStorage.setItem("billing_id", t);
      }
      return wr(t);
    }
    function f() {
      return n.getRandomValue();
    }
    function C() {
      if (n.getRandomValue === void 0)
        try {
          var e = typeof window == "object" ? window : self, t = typeof e.crypto < "u" ? e.crypto : e.msCrypto, i = function() {
            var c = new Uint32Array(1);
            return t.getRandomValues(c), c[0] >>> 0;
          };
          i(), n.getRandomValue = i;
        } catch {
          try {
            var o = require("crypto"), s = function() {
              var h = o.randomBytes(4);
              return (h[0] << 24 | h[1] << 16 | h[2] << 8 | h[3]) >>> 0;
            };
            s(), n.getRandomValue = s;
          } catch {
            throw "No secure random number generator found";
          }
        }
    }
    function k(e) {
      this.name = "ExitStatus", this.message = `Program terminated with exit(${e})`, this.status = e;
    }
    var $ = (e) => {
      for (; e.length > 0; )
        e.shift()(n);
    };
    function Y(e) {
      this.excPtr = e, this.ptr = e - 24, this.set_type = function(t) {
        X[this.ptr + 4 >> 2] = t;
      }, this.get_type = function() {
        return X[this.ptr + 4 >> 2];
      }, this.set_destructor = function(t) {
        X[this.ptr + 8 >> 2] = t;
      }, this.get_destructor = function() {
        return X[this.ptr + 8 >> 2];
      }, this.set_caught = function(t) {
        t = t ? 1 : 0, Ee[this.ptr + 12 >> 0] = t;
      }, this.get_caught = function() {
        return Ee[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(t) {
        t = t ? 1 : 0, Ee[this.ptr + 13 >> 0] = t;
      }, this.get_rethrown = function() {
        return Ee[this.ptr + 13 >> 0] != 0;
      }, this.init = function(t, i) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(i);
      }, this.set_adjusted_ptr = function(t) {
        X[this.ptr + 16 >> 2] = t;
      }, this.get_adjusted_ptr = function() {
        return X[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var t = bo(this.get_type());
        if (t)
          return X[this.excPtr >> 2];
        var i = this.get_adjusted_ptr();
        return i !== 0 ? i : this.excPtr;
      };
    }
    var Fe = 0;
    function Ve(e, t, i) {
      var o = new Y(e);
      throw o.init(t, i), Fe = e, Fe;
    }
    var _e = { isAbs: (e) => e.charAt(0) === "/", splitPath: (e) => {
      var t = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return t.exec(e).slice(1);
    }, normalizeArray: (e, t) => {
      for (var i = 0, o = e.length - 1; o >= 0; o--) {
        var s = e[o];
        s === "." ? e.splice(o, 1) : s === ".." ? (e.splice(o, 1), i++) : i && (e.splice(o, 1), i--);
      }
      if (t)
        for (; i; i--)
          e.unshift("..");
      return e;
    }, normalize: (e) => {
      var t = _e.isAbs(e), i = e.substr(-1) === "/";
      return e = _e.normalizeArray(e.split("/").filter((o) => !!o), !t).join("/"), !e && !t && (e = "."), e && i && (e += "/"), (t ? "/" : "") + e;
    }, dirname: (e) => {
      var t = _e.splitPath(e), i = t[0], o = t[1];
      return !i && !o ? "." : (o && (o = o.substr(0, o.length - 1)), i + o);
    }, basename: (e) => {
      if (e === "/")
        return "/";
      e = _e.normalize(e), e = e.replace(/\/$/, "");
      var t = e.lastIndexOf("/");
      return t === -1 ? e : e.substr(t + 1);
    }, join: function() {
      var e = Array.prototype.slice.call(arguments);
      return _e.normalize(e.join("/"));
    }, join2: (e, t) => _e.normalize(e + "/" + t) }, Ge = () => {
      if (typeof crypto == "object" && typeof crypto.getRandomValues == "function")
        return (e) => crypto.getRandomValues(e);
      qe("initRandomDevice");
    }, Me = (e) => (Me = Ge())(e), vt = { resolve: function() {
      for (var e = "", t = !1, i = arguments.length - 1; i >= -1 && !t; i--) {
        var o = i >= 0 ? arguments[i] : g.cwd();
        if (typeof o != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!o)
          return "";
        e = o + "/" + e, t = _e.isAbs(o);
      }
      return e = _e.normalizeArray(e.split("/").filter((s) => !!s), !t).join("/"), (t ? "/" : "") + e || ".";
    }, relative: (e, t) => {
      e = vt.resolve(e).substr(1), t = vt.resolve(t).substr(1);
      function i(F) {
        for (var P = 0; P < F.length && F[P] === ""; P++)
          ;
        for (var W = F.length - 1; W >= 0 && F[W] === ""; W--)
          ;
        return P > W ? [] : F.slice(P, W - P + 1);
      }
      for (var o = i(e.split("/")), s = i(t.split("/")), c = Math.min(o.length, s.length), h = c, b = 0; b < c; b++)
        if (o[b] !== s[b]) {
          h = b;
          break;
        }
      for (var x = [], b = h; b < o.length; b++)
        x.push("..");
      return x = x.concat(s.slice(h)), x.join("/");
    } }, _r = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, xt = (e, t, i) => {
      for (var o = t + i, s = t; e[s] && !(s >= o); )
        ++s;
      if (s - t > 16 && e.buffer && _r)
        return _r.decode(e.subarray(t, s));
      for (var c = ""; t < s; ) {
        var h = e[t++];
        if (!(h & 128)) {
          c += String.fromCharCode(h);
          continue;
        }
        var b = e[t++] & 63;
        if ((h & 224) == 192) {
          c += String.fromCharCode((h & 31) << 6 | b);
          continue;
        }
        var x = e[t++] & 63;
        if ((h & 240) == 224 ? h = (h & 15) << 12 | b << 6 | x : h = (h & 7) << 18 | b << 12 | x << 6 | e[t++] & 63, h < 65536)
          c += String.fromCharCode(h);
        else {
          var F = h - 65536;
          c += String.fromCharCode(55296 | F >> 10, 56320 | F & 1023);
        }
      }
      return c;
    }, At = [], at = (e) => {
      for (var t = 0, i = 0; i < e.length; ++i) {
        var o = e.charCodeAt(i);
        o <= 127 ? t++ : o <= 2047 ? t += 2 : o >= 55296 && o <= 57343 ? (t += 4, ++i) : t += 3;
      }
      return t;
    }, ii = (e, t, i, o) => {
      if (!(o > 0))
        return 0;
      for (var s = i, c = i + o - 1, h = 0; h < e.length; ++h) {
        var b = e.charCodeAt(h);
        if (b >= 55296 && b <= 57343) {
          var x = e.charCodeAt(++h);
          b = 65536 + ((b & 1023) << 10) | x & 1023;
        }
        if (b <= 127) {
          if (i >= c)
            break;
          t[i++] = b;
        } else if (b <= 2047) {
          if (i + 1 >= c)
            break;
          t[i++] = 192 | b >> 6, t[i++] = 128 | b & 63;
        } else if (b <= 65535) {
          if (i + 2 >= c)
            break;
          t[i++] = 224 | b >> 12, t[i++] = 128 | b >> 6 & 63, t[i++] = 128 | b & 63;
        } else {
          if (i + 3 >= c)
            break;
          t[i++] = 240 | b >> 18, t[i++] = 128 | b >> 12 & 63, t[i++] = 128 | b >> 6 & 63, t[i++] = 128 | b & 63;
        }
      }
      return t[i] = 0, i - s;
    };
    function tn(e, t, i) {
      var o = i > 0 ? i : at(e) + 1, s = new Array(o), c = ii(e, s, 0, s.length);
      return t && (s.length = c), s;
    }
    var Qu = () => {
      if (!At.length) {
        var e = null;
        if (typeof window < "u" && typeof window.prompt == "function" ? (e = window.prompt("Input: "), e !== null && (e += `
`)) : typeof readline == "function" && (e = readline(), e !== null && (e += `
`)), !e)
          return null;
        At = tn(e, !0);
      }
      return At.shift();
    }, rr = { ttys: [], init: function() {
    }, shutdown: function() {
    }, register: function(e, t) {
      rr.ttys[e] = { input: [], output: [], ops: t }, g.registerDevice(e, rr.stream_ops);
    }, stream_ops: { open: function(e) {
      var t = rr.ttys[e.node.rdev];
      if (!t)
        throw new g.ErrnoError(43);
      e.tty = t, e.seekable = !1;
    }, close: function(e) {
      e.tty.ops.fsync(e.tty);
    }, fsync: function(e) {
      e.tty.ops.fsync(e.tty);
    }, read: function(e, t, i, o, s) {
      if (!e.tty || !e.tty.ops.get_char)
        throw new g.ErrnoError(60);
      for (var c = 0, h = 0; h < o; h++) {
        var b;
        try {
          b = e.tty.ops.get_char(e.tty);
        } catch {
          throw new g.ErrnoError(29);
        }
        if (b === void 0 && c === 0)
          throw new g.ErrnoError(6);
        if (b == null)
          break;
        c++, t[i + h] = b;
      }
      return c && (e.node.timestamp = Date.now()), c;
    }, write: function(e, t, i, o, s) {
      if (!e.tty || !e.tty.ops.put_char)
        throw new g.ErrnoError(60);
      try {
        for (var c = 0; c < o; c++)
          e.tty.ops.put_char(e.tty, t[i + c]);
      } catch {
        throw new g.ErrnoError(29);
      }
      return o && (e.node.timestamp = Date.now()), c;
    } }, default_tty_ops: { get_char: function(e) {
      return Qu();
    }, put_char: function(e, t) {
      t === null || t === 10 ? (K(xt(e.output, 0)), e.output = []) : t != 0 && e.output.push(t);
    }, fsync: function(e) {
      e.output && e.output.length > 0 && (K(xt(e.output, 0)), e.output = []);
    }, ioctl_tcgets: function(e) {
      return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
    }, ioctl_tcsets: function(e, t, i) {
      return 0;
    }, ioctl_tiocgwinsz: function(e) {
      return [24, 80];
    } }, default_tty1_ops: { put_char: function(e, t) {
      t === null || t === 10 ? (pe(xt(e.output, 0)), e.output = []) : t != 0 && e.output.push(t);
    }, fsync: function(e) {
      e.output && e.output.length > 0 && (pe(xt(e.output, 0)), e.output = []);
    } } }, ai = (e, t) => (de.fill(0, e, e + t), e), Ju = (e, t) => Math.ceil(e / t) * t, La = (e) => {
      e = Ju(e, 65536);
      var t = po(65536, e);
      return t ? ai(t, e) : 0;
    }, Ae = { ops_table: null, mount(e) {
      return Ae.createNode(null, "/", 16895, 0);
    }, createNode(e, t, i, o) {
      if (g.isBlkdev(i) || g.isFIFO(i))
        throw new g.ErrnoError(63);
      Ae.ops_table || (Ae.ops_table = { dir: { node: { getattr: Ae.node_ops.getattr, setattr: Ae.node_ops.setattr, lookup: Ae.node_ops.lookup, mknod: Ae.node_ops.mknod, rename: Ae.node_ops.rename, unlink: Ae.node_ops.unlink, rmdir: Ae.node_ops.rmdir, readdir: Ae.node_ops.readdir, symlink: Ae.node_ops.symlink }, stream: { llseek: Ae.stream_ops.llseek } }, file: { node: { getattr: Ae.node_ops.getattr, setattr: Ae.node_ops.setattr }, stream: { llseek: Ae.stream_ops.llseek, read: Ae.stream_ops.read, write: Ae.stream_ops.write, allocate: Ae.stream_ops.allocate, mmap: Ae.stream_ops.mmap, msync: Ae.stream_ops.msync } }, link: { node: { getattr: Ae.node_ops.getattr, setattr: Ae.node_ops.setattr, readlink: Ae.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: Ae.node_ops.getattr, setattr: Ae.node_ops.setattr }, stream: g.chrdev_stream_ops } });
      var s = g.createNode(e, t, i, o);
      return g.isDir(s.mode) ? (s.node_ops = Ae.ops_table.dir.node, s.stream_ops = Ae.ops_table.dir.stream, s.contents = {}) : g.isFile(s.mode) ? (s.node_ops = Ae.ops_table.file.node, s.stream_ops = Ae.ops_table.file.stream, s.usedBytes = 0, s.contents = null) : g.isLink(s.mode) ? (s.node_ops = Ae.ops_table.link.node, s.stream_ops = Ae.ops_table.link.stream) : g.isChrdev(s.mode) && (s.node_ops = Ae.ops_table.chrdev.node, s.stream_ops = Ae.ops_table.chrdev.stream), s.timestamp = Date.now(), e && (e.contents[t] = s, e.timestamp = s.timestamp), s;
    }, getFileDataAsTypedArray(e) {
      return e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0);
    }, expandFileStorage(e, t) {
      var i = e.contents ? e.contents.length : 0;
      if (!(i >= t)) {
        var o = 1024 * 1024;
        t = Math.max(t, i * (i < o ? 2 : 1.125) >>> 0), i != 0 && (t = Math.max(t, 256));
        var s = e.contents;
        e.contents = new Uint8Array(t), e.usedBytes > 0 && e.contents.set(s.subarray(0, e.usedBytes), 0);
      }
    }, resizeFileStorage(e, t) {
      if (e.usedBytes != t)
        if (t == 0)
          e.contents = null, e.usedBytes = 0;
        else {
          var i = e.contents;
          e.contents = new Uint8Array(t), i && e.contents.set(i.subarray(0, Math.min(t, e.usedBytes))), e.usedBytes = t;
        }
    }, node_ops: { getattr(e) {
      var t = {};
      return t.dev = g.isChrdev(e.mode) ? e.id : 1, t.ino = e.id, t.mode = e.mode, t.nlink = 1, t.uid = 0, t.gid = 0, t.rdev = e.rdev, g.isDir(e.mode) ? t.size = 4096 : g.isFile(e.mode) ? t.size = e.usedBytes : g.isLink(e.mode) ? t.size = e.link.length : t.size = 0, t.atime = new Date(e.timestamp), t.mtime = new Date(e.timestamp), t.ctime = new Date(e.timestamp), t.blksize = 4096, t.blocks = Math.ceil(t.size / t.blksize), t;
    }, setattr(e, t) {
      t.mode !== void 0 && (e.mode = t.mode), t.timestamp !== void 0 && (e.timestamp = t.timestamp), t.size !== void 0 && Ae.resizeFileStorage(e, t.size);
    }, lookup(e, t) {
      throw g.genericErrors[44];
    }, mknod(e, t, i, o) {
      return Ae.createNode(e, t, i, o);
    }, rename(e, t, i) {
      if (g.isDir(e.mode)) {
        var o;
        try {
          o = g.lookupNode(t, i);
        } catch {
        }
        if (o)
          for (var s in o.contents)
            throw new g.ErrnoError(55);
      }
      delete e.parent.contents[e.name], e.parent.timestamp = Date.now(), e.name = i, t.contents[i] = e, t.timestamp = e.parent.timestamp, e.parent = t;
    }, unlink(e, t) {
      delete e.contents[t], e.timestamp = Date.now();
    }, rmdir(e, t) {
      var i = g.lookupNode(e, t);
      for (var o in i.contents)
        throw new g.ErrnoError(55);
      delete e.contents[t], e.timestamp = Date.now();
    }, readdir(e) {
      var t = [".", ".."];
      for (var i in e.contents)
        e.contents.hasOwnProperty(i) && t.push(i);
      return t;
    }, symlink(e, t, i) {
      var o = Ae.createNode(e, t, 41471, 0);
      return o.link = i, o;
    }, readlink(e) {
      if (!g.isLink(e.mode))
        throw new g.ErrnoError(28);
      return e.link;
    } }, stream_ops: { read(e, t, i, o, s) {
      var c = e.node.contents;
      if (s >= e.node.usedBytes)
        return 0;
      var h = Math.min(e.node.usedBytes - s, o);
      if (h > 8 && c.subarray)
        t.set(c.subarray(s, s + h), i);
      else
        for (var b = 0; b < h; b++)
          t[i + b] = c[s + b];
      return h;
    }, write(e, t, i, o, s, c) {
      if (t.buffer === Ee.buffer && (c = !1), !o)
        return 0;
      var h = e.node;
      if (h.timestamp = Date.now(), t.subarray && (!h.contents || h.contents.subarray)) {
        if (c)
          return h.contents = t.subarray(i, i + o), h.usedBytes = o, o;
        if (h.usedBytes === 0 && s === 0)
          return h.contents = t.slice(i, i + o), h.usedBytes = o, o;
        if (s + o <= h.usedBytes)
          return h.contents.set(t.subarray(i, i + o), s), o;
      }
      if (Ae.expandFileStorage(h, s + o), h.contents.subarray && t.subarray)
        h.contents.set(t.subarray(i, i + o), s);
      else
        for (var b = 0; b < o; b++)
          h.contents[s + b] = t[i + b];
      return h.usedBytes = Math.max(h.usedBytes, s + o), o;
    }, llseek(e, t, i) {
      var o = t;
      if (i === 1 ? o += e.position : i === 2 && g.isFile(e.node.mode) && (o += e.node.usedBytes), o < 0)
        throw new g.ErrnoError(28);
      return o;
    }, allocate(e, t, i) {
      Ae.expandFileStorage(e.node, t + i), e.node.usedBytes = Math.max(e.node.usedBytes, t + i);
    }, mmap(e, t, i, o, s) {
      if (!g.isFile(e.node.mode))
        throw new g.ErrnoError(43);
      var c, h, b = e.node.contents;
      if (!(s & 2) && b.buffer === Ee.buffer)
        h = !1, c = b.byteOffset;
      else {
        if ((i > 0 || i + t < b.length) && (b.subarray ? b = b.subarray(i, i + t) : b = Array.prototype.slice.call(b, i, i + t)), h = !0, c = La(t), !c)
          throw new g.ErrnoError(48);
        Ee.set(b, c);
      }
      return { ptr: c, allocated: h };
    }, msync(e, t, i, o, s) {
      return Ae.stream_ops.write(e, t, 0, o, i, !1), 0;
    } } }, el = (e, t, i, o) => {
      var s = o ? "" : `al ${e}`;
      q(e, (c) => {
        me(c, `Loading data file "${e}" failed (no arrayBuffer).`), t(new Uint8Array(c)), s && rt();
      }, (c) => {
        if (i)
          i();
        else
          throw `Loading data file "${e}" failed.`;
      }), s && mt();
    }, oi = n.preloadPlugins || [];
    function tl(e, t, i, o) {
      typeof z < "u" && z.init();
      var s = !1;
      return oi.forEach(function(c) {
        s || c.canHandle(t) && (c.handle(e, t, i, o), s = !0);
      }), s;
    }
    function rl(e, t, i, o, s, c, h, b, x, F) {
      var P = t ? vt.resolve(_e.join2(e, t)) : e;
      function W(U) {
        function G(re) {
          F && F(), b || g.createDataFile(e, t, re, o, s, x), c && c(), rt();
        }
        tl(U, P, G, () => {
          h && h(), rt();
        }) || G(U);
      }
      mt(), typeof i == "string" ? el(i, (U) => W(U), h) : W(i);
    }
    function nl(e) {
      var t = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, i = t[e];
      if (typeof i > "u")
        throw new Error(`Unknown file open mode: ${e}`);
      return i;
    }
    function si(e, t) {
      var i = 0;
      return e && (i |= 365), t && (i |= 146), i;
    }
    var g = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: !1, ignorePermissions: !0, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: (e, t = {}) => {
      if (e = vt.resolve(e), !e)
        return { path: "", node: null };
      var i = { follow_mount: !0, recurse_count: 0 };
      if (t = Object.assign(i, t), t.recurse_count > 8)
        throw new g.ErrnoError(32);
      for (var o = e.split("/").filter((W) => !!W), s = g.root, c = "/", h = 0; h < o.length; h++) {
        var b = h === o.length - 1;
        if (b && t.parent)
          break;
        if (s = g.lookupNode(s, o[h]), c = _e.join2(c, o[h]), g.isMountpoint(s) && (!b || b && t.follow_mount) && (s = s.mounted.root), !b || t.follow)
          for (var x = 0; g.isLink(s.mode); ) {
            var F = g.readlink(c);
            c = vt.resolve(_e.dirname(c), F);
            var P = g.lookupPath(c, { recurse_count: t.recurse_count + 1 });
            if (s = P.node, x++ > 40)
              throw new g.ErrnoError(32);
          }
      }
      return { path: c, node: s };
    }, getPath: (e) => {
      for (var t; ; ) {
        if (g.isRoot(e)) {
          var i = e.mount.mountpoint;
          return t ? i[i.length - 1] !== "/" ? `${i}/${t}` : i + t : i;
        }
        t = t ? `${e.name}/${t}` : e.name, e = e.parent;
      }
    }, hashName: (e, t) => {
      for (var i = 0, o = 0; o < t.length; o++)
        i = (i << 5) - i + t.charCodeAt(o) | 0;
      return (e + i >>> 0) % g.nameTable.length;
    }, hashAddNode: (e) => {
      var t = g.hashName(e.parent.id, e.name);
      e.name_next = g.nameTable[t], g.nameTable[t] = e;
    }, hashRemoveNode: (e) => {
      var t = g.hashName(e.parent.id, e.name);
      if (g.nameTable[t] === e)
        g.nameTable[t] = e.name_next;
      else
        for (var i = g.nameTable[t]; i; ) {
          if (i.name_next === e) {
            i.name_next = e.name_next;
            break;
          }
          i = i.name_next;
        }
    }, lookupNode: (e, t) => {
      var i = g.mayLookup(e);
      if (i)
        throw new g.ErrnoError(i, e);
      for (var o = g.hashName(e.id, t), s = g.nameTable[o]; s; s = s.name_next) {
        var c = s.name;
        if (s.parent.id === e.id && c === t)
          return s;
      }
      return g.lookup(e, t);
    }, createNode: (e, t, i, o) => {
      var s = new g.FSNode(e, t, i, o);
      return g.hashAddNode(s), s;
    }, destroyNode: (e) => {
      g.hashRemoveNode(e);
    }, isRoot: (e) => e === e.parent, isMountpoint: (e) => !!e.mounted, isFile: (e) => (e & 61440) === 32768, isDir: (e) => (e & 61440) === 16384, isLink: (e) => (e & 61440) === 40960, isChrdev: (e) => (e & 61440) === 8192, isBlkdev: (e) => (e & 61440) === 24576, isFIFO: (e) => (e & 61440) === 4096, isSocket: (e) => (e & 49152) === 49152, flagsToPermissionString: (e) => {
      var t = ["r", "w", "rw"][e & 3];
      return e & 512 && (t += "w"), t;
    }, nodePermissions: (e, t) => g.ignorePermissions ? 0 : t.includes("r") && !(e.mode & 292) || t.includes("w") && !(e.mode & 146) || t.includes("x") && !(e.mode & 73) ? 2 : 0, mayLookup: (e) => {
      var t = g.nodePermissions(e, "x");
      return t || (e.node_ops.lookup ? 0 : 2);
    }, mayCreate: (e, t) => {
      try {
        return g.lookupNode(e, t), 20;
      } catch {
      }
      return g.nodePermissions(e, "wx");
    }, mayDelete: (e, t, i) => {
      var o;
      try {
        o = g.lookupNode(e, t);
      } catch (c) {
        return c.errno;
      }
      var s = g.nodePermissions(e, "wx");
      if (s)
        return s;
      if (i) {
        if (!g.isDir(o.mode))
          return 54;
        if (g.isRoot(o) || g.getPath(o) === g.cwd())
          return 10;
      } else if (g.isDir(o.mode))
        return 31;
      return 0;
    }, mayOpen: (e, t) => e ? g.isLink(e.mode) ? 32 : g.isDir(e.mode) && (g.flagsToPermissionString(t) !== "r" || t & 512) ? 31 : g.nodePermissions(e, g.flagsToPermissionString(t)) : 44, MAX_OPEN_FDS: 4096, nextfd: () => {
      for (var e = 0; e <= g.MAX_OPEN_FDS; e++)
        if (!g.streams[e])
          return e;
      throw new g.ErrnoError(33);
    }, getStreamChecked: (e) => {
      var t = g.getStream(e);
      if (!t)
        throw new g.ErrnoError(8);
      return t;
    }, getStream: (e) => g.streams[e], createStream: (e, t = -1) => (g.FSStream || (g.FSStream = function() {
      this.shared = {};
    }, g.FSStream.prototype = {}, Object.defineProperties(g.FSStream.prototype, { object: { get() {
      return this.node;
    }, set(i) {
      this.node = i;
    } }, isRead: { get() {
      return (this.flags & 2097155) !== 1;
    } }, isWrite: { get() {
      return (this.flags & 2097155) !== 0;
    } }, isAppend: { get() {
      return this.flags & 1024;
    } }, flags: { get() {
      return this.shared.flags;
    }, set(i) {
      this.shared.flags = i;
    } }, position: { get() {
      return this.shared.position;
    }, set(i) {
      this.shared.position = i;
    } } })), e = Object.assign(new g.FSStream(), e), t == -1 && (t = g.nextfd()), e.fd = t, g.streams[t] = e, e), closeStream: (e) => {
      g.streams[e] = null;
    }, chrdev_stream_ops: { open: (e) => {
      var t = g.getDevice(e.node.rdev);
      e.stream_ops = t.stream_ops, e.stream_ops.open && e.stream_ops.open(e);
    }, llseek: () => {
      throw new g.ErrnoError(70);
    } }, major: (e) => e >> 8, minor: (e) => e & 255, makedev: (e, t) => e << 8 | t, registerDevice: (e, t) => {
      g.devices[e] = { stream_ops: t };
    }, getDevice: (e) => g.devices[e], getMounts: (e) => {
      for (var t = [], i = [e]; i.length; ) {
        var o = i.pop();
        t.push(o), i.push.apply(i, o.mounts);
      }
      return t;
    }, syncfs: (e, t) => {
      typeof e == "function" && (t = e, e = !1), g.syncFSRequests++, g.syncFSRequests > 1 && pe(`warning: ${g.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      var i = g.getMounts(g.root.mount), o = 0;
      function s(h) {
        return g.syncFSRequests--, t(h);
      }
      function c(h) {
        if (h)
          return c.errored ? void 0 : (c.errored = !0, s(h));
        ++o >= i.length && s(null);
      }
      i.forEach((h) => {
        if (!h.type.syncfs)
          return c(null);
        h.type.syncfs(h, e, c);
      });
    }, mount: (e, t, i) => {
      var o = i === "/", s = !i, c;
      if (o && g.root)
        throw new g.ErrnoError(10);
      if (!o && !s) {
        var h = g.lookupPath(i, { follow_mount: !1 });
        if (i = h.path, c = h.node, g.isMountpoint(c))
          throw new g.ErrnoError(10);
        if (!g.isDir(c.mode))
          throw new g.ErrnoError(54);
      }
      var b = { type: e, opts: t, mountpoint: i, mounts: [] }, x = e.mount(b);
      return x.mount = b, b.root = x, o ? g.root = x : c && (c.mounted = b, c.mount && c.mount.mounts.push(b)), x;
    }, unmount: (e) => {
      var t = g.lookupPath(e, { follow_mount: !1 });
      if (!g.isMountpoint(t.node))
        throw new g.ErrnoError(28);
      var i = t.node, o = i.mounted, s = g.getMounts(o);
      Object.keys(g.nameTable).forEach((h) => {
        for (var b = g.nameTable[h]; b; ) {
          var x = b.name_next;
          s.includes(b.mount) && g.destroyNode(b), b = x;
        }
      }), i.mounted = null;
      var c = i.mount.mounts.indexOf(o);
      i.mount.mounts.splice(c, 1);
    }, lookup: (e, t) => e.node_ops.lookup(e, t), mknod: (e, t, i) => {
      var o = g.lookupPath(e, { parent: !0 }), s = o.node, c = _e.basename(e);
      if (!c || c === "." || c === "..")
        throw new g.ErrnoError(28);
      var h = g.mayCreate(s, c);
      if (h)
        throw new g.ErrnoError(h);
      if (!s.node_ops.mknod)
        throw new g.ErrnoError(63);
      return s.node_ops.mknod(s, c, t, i);
    }, create: (e, t) => (t = t !== void 0 ? t : 438, t &= 4095, t |= 32768, g.mknod(e, t, 0)), mkdir: (e, t) => (t = t !== void 0 ? t : 511, t &= 1023, t |= 16384, g.mknod(e, t, 0)), mkdirTree: (e, t) => {
      for (var i = e.split("/"), o = "", s = 0; s < i.length; ++s)
        if (i[s]) {
          o += "/" + i[s];
          try {
            g.mkdir(o, t);
          } catch (c) {
            if (c.errno != 20)
              throw c;
          }
        }
    }, mkdev: (e, t, i) => (typeof i > "u" && (i = t, t = 438), t |= 8192, g.mknod(e, t, i)), symlink: (e, t) => {
      if (!vt.resolve(e))
        throw new g.ErrnoError(44);
      var i = g.lookupPath(t, { parent: !0 }), o = i.node;
      if (!o)
        throw new g.ErrnoError(44);
      var s = _e.basename(t), c = g.mayCreate(o, s);
      if (c)
        throw new g.ErrnoError(c);
      if (!o.node_ops.symlink)
        throw new g.ErrnoError(63);
      return o.node_ops.symlink(o, s, e);
    }, rename: (e, t) => {
      var i = _e.dirname(e), o = _e.dirname(t), s = _e.basename(e), c = _e.basename(t), h, b, x;
      if (h = g.lookupPath(e, { parent: !0 }), b = h.node, h = g.lookupPath(t, { parent: !0 }), x = h.node, !b || !x)
        throw new g.ErrnoError(44);
      if (b.mount !== x.mount)
        throw new g.ErrnoError(75);
      var F = g.lookupNode(b, s), P = vt.relative(e, o);
      if (P.charAt(0) !== ".")
        throw new g.ErrnoError(28);
      if (P = vt.relative(t, i), P.charAt(0) !== ".")
        throw new g.ErrnoError(55);
      var W;
      try {
        W = g.lookupNode(x, c);
      } catch {
      }
      if (F !== W) {
        var U = g.isDir(F.mode), G = g.mayDelete(b, s, U);
        if (G)
          throw new g.ErrnoError(G);
        if (G = W ? g.mayDelete(x, c, U) : g.mayCreate(x, c), G)
          throw new g.ErrnoError(G);
        if (!b.node_ops.rename)
          throw new g.ErrnoError(63);
        if (g.isMountpoint(F) || W && g.isMountpoint(W))
          throw new g.ErrnoError(10);
        if (x !== b && (G = g.nodePermissions(b, "w"), G))
          throw new g.ErrnoError(G);
        g.hashRemoveNode(F);
        try {
          b.node_ops.rename(F, x, c);
        } catch (re) {
          throw re;
        } finally {
          g.hashAddNode(F);
        }
      }
    }, rmdir: (e) => {
      var t = g.lookupPath(e, { parent: !0 }), i = t.node, o = _e.basename(e), s = g.lookupNode(i, o), c = g.mayDelete(i, o, !0);
      if (c)
        throw new g.ErrnoError(c);
      if (!i.node_ops.rmdir)
        throw new g.ErrnoError(63);
      if (g.isMountpoint(s))
        throw new g.ErrnoError(10);
      i.node_ops.rmdir(i, o), g.destroyNode(s);
    }, readdir: (e) => {
      var t = g.lookupPath(e, { follow: !0 }), i = t.node;
      if (!i.node_ops.readdir)
        throw new g.ErrnoError(54);
      return i.node_ops.readdir(i);
    }, unlink: (e) => {
      var t = g.lookupPath(e, { parent: !0 }), i = t.node;
      if (!i)
        throw new g.ErrnoError(44);
      var o = _e.basename(e), s = g.lookupNode(i, o), c = g.mayDelete(i, o, !1);
      if (c)
        throw new g.ErrnoError(c);
      if (!i.node_ops.unlink)
        throw new g.ErrnoError(63);
      if (g.isMountpoint(s))
        throw new g.ErrnoError(10);
      i.node_ops.unlink(i, o), g.destroyNode(s);
    }, readlink: (e) => {
      var t = g.lookupPath(e), i = t.node;
      if (!i)
        throw new g.ErrnoError(44);
      if (!i.node_ops.readlink)
        throw new g.ErrnoError(28);
      return vt.resolve(g.getPath(i.parent), i.node_ops.readlink(i));
    }, stat: (e, t) => {
      var i = g.lookupPath(e, { follow: !t }), o = i.node;
      if (!o)
        throw new g.ErrnoError(44);
      if (!o.node_ops.getattr)
        throw new g.ErrnoError(63);
      return o.node_ops.getattr(o);
    }, lstat: (e) => g.stat(e, !0), chmod: (e, t, i) => {
      var o;
      if (typeof e == "string") {
        var s = g.lookupPath(e, { follow: !i });
        o = s.node;
      } else
        o = e;
      if (!o.node_ops.setattr)
        throw new g.ErrnoError(63);
      o.node_ops.setattr(o, { mode: t & 4095 | o.mode & -4096, timestamp: Date.now() });
    }, lchmod: (e, t) => {
      g.chmod(e, t, !0);
    }, fchmod: (e, t) => {
      var i = g.getStreamChecked(e);
      g.chmod(i.node, t);
    }, chown: (e, t, i, o) => {
      var s;
      if (typeof e == "string") {
        var c = g.lookupPath(e, { follow: !o });
        s = c.node;
      } else
        s = e;
      if (!s.node_ops.setattr)
        throw new g.ErrnoError(63);
      s.node_ops.setattr(s, { timestamp: Date.now() });
    }, lchown: (e, t, i) => {
      g.chown(e, t, i, !0);
    }, fchown: (e, t, i) => {
      var o = g.getStreamChecked(e);
      g.chown(o.node, t, i);
    }, truncate: (e, t) => {
      if (t < 0)
        throw new g.ErrnoError(28);
      var i;
      if (typeof e == "string") {
        var o = g.lookupPath(e, { follow: !0 });
        i = o.node;
      } else
        i = e;
      if (!i.node_ops.setattr)
        throw new g.ErrnoError(63);
      if (g.isDir(i.mode))
        throw new g.ErrnoError(31);
      if (!g.isFile(i.mode))
        throw new g.ErrnoError(28);
      var s = g.nodePermissions(i, "w");
      if (s)
        throw new g.ErrnoError(s);
      i.node_ops.setattr(i, { size: t, timestamp: Date.now() });
    }, ftruncate: (e, t) => {
      var i = g.getStreamChecked(e);
      if (!(i.flags & 2097155))
        throw new g.ErrnoError(28);
      g.truncate(i.node, t);
    }, utime: (e, t, i) => {
      var o = g.lookupPath(e, { follow: !0 }), s = o.node;
      s.node_ops.setattr(s, { timestamp: Math.max(t, i) });
    }, open: (e, t, i) => {
      if (e === "")
        throw new g.ErrnoError(44);
      t = typeof t == "string" ? nl(t) : t, i = typeof i > "u" ? 438 : i, t & 64 ? i = i & 4095 | 32768 : i = 0;
      var o;
      if (typeof e == "object")
        o = e;
      else {
        e = _e.normalize(e);
        try {
          var s = g.lookupPath(e, { follow: !(t & 131072) });
          o = s.node;
        } catch {
        }
      }
      var c = !1;
      if (t & 64)
        if (o) {
          if (t & 128)
            throw new g.ErrnoError(20);
        } else
          o = g.mknod(e, i, 0), c = !0;
      if (!o)
        throw new g.ErrnoError(44);
      if (g.isChrdev(o.mode) && (t &= -513), t & 65536 && !g.isDir(o.mode))
        throw new g.ErrnoError(54);
      if (!c) {
        var h = g.mayOpen(o, t);
        if (h)
          throw new g.ErrnoError(h);
      }
      t & 512 && !c && g.truncate(o, 0), t &= -131713;
      var b = g.createStream({ node: o, path: g.getPath(o), flags: t, seekable: !0, position: 0, stream_ops: o.stream_ops, ungotten: [], error: !1 });
      return b.stream_ops.open && b.stream_ops.open(b), n.logReadFiles && !(t & 1) && (g.readFiles || (g.readFiles = {}), e in g.readFiles || (g.readFiles[e] = 1)), b;
    }, close: (e) => {
      if (g.isClosed(e))
        throw new g.ErrnoError(8);
      e.getdents && (e.getdents = null);
      try {
        e.stream_ops.close && e.stream_ops.close(e);
      } catch (t) {
        throw t;
      } finally {
        g.closeStream(e.fd);
      }
      e.fd = null;
    }, isClosed: (e) => e.fd === null, llseek: (e, t, i) => {
      if (g.isClosed(e))
        throw new g.ErrnoError(8);
      if (!e.seekable || !e.stream_ops.llseek)
        throw new g.ErrnoError(70);
      if (i != 0 && i != 1 && i != 2)
        throw new g.ErrnoError(28);
      return e.position = e.stream_ops.llseek(e, t, i), e.ungotten = [], e.position;
    }, read: (e, t, i, o, s) => {
      if (o < 0 || s < 0)
        throw new g.ErrnoError(28);
      if (g.isClosed(e))
        throw new g.ErrnoError(8);
      if ((e.flags & 2097155) === 1)
        throw new g.ErrnoError(8);
      if (g.isDir(e.node.mode))
        throw new g.ErrnoError(31);
      if (!e.stream_ops.read)
        throw new g.ErrnoError(28);
      var c = typeof s < "u";
      if (!c)
        s = e.position;
      else if (!e.seekable)
        throw new g.ErrnoError(70);
      var h = e.stream_ops.read(e, t, i, o, s);
      return c || (e.position += h), h;
    }, write: (e, t, i, o, s, c) => {
      if (o < 0 || s < 0)
        throw new g.ErrnoError(28);
      if (g.isClosed(e))
        throw new g.ErrnoError(8);
      if (!(e.flags & 2097155))
        throw new g.ErrnoError(8);
      if (g.isDir(e.node.mode))
        throw new g.ErrnoError(31);
      if (!e.stream_ops.write)
        throw new g.ErrnoError(28);
      e.seekable && e.flags & 1024 && g.llseek(e, 0, 2);
      var h = typeof s < "u";
      if (!h)
        s = e.position;
      else if (!e.seekable)
        throw new g.ErrnoError(70);
      var b = e.stream_ops.write(e, t, i, o, s, c);
      return h || (e.position += b), b;
    }, allocate: (e, t, i) => {
      if (g.isClosed(e))
        throw new g.ErrnoError(8);
      if (t < 0 || i <= 0)
        throw new g.ErrnoError(28);
      if (!(e.flags & 2097155))
        throw new g.ErrnoError(8);
      if (!g.isFile(e.node.mode) && !g.isDir(e.node.mode))
        throw new g.ErrnoError(43);
      if (!e.stream_ops.allocate)
        throw new g.ErrnoError(138);
      e.stream_ops.allocate(e, t, i);
    }, mmap: (e, t, i, o, s) => {
      if (o & 2 && !(s & 2) && (e.flags & 2097155) !== 2)
        throw new g.ErrnoError(2);
      if ((e.flags & 2097155) === 1)
        throw new g.ErrnoError(2);
      if (!e.stream_ops.mmap)
        throw new g.ErrnoError(43);
      return e.stream_ops.mmap(e, t, i, o, s);
    }, msync: (e, t, i, o, s) => e.stream_ops.msync ? e.stream_ops.msync(e, t, i, o, s) : 0, munmap: (e) => 0, ioctl: (e, t, i) => {
      if (!e.stream_ops.ioctl)
        throw new g.ErrnoError(59);
      return e.stream_ops.ioctl(e, t, i);
    }, readFile: (e, t = {}) => {
      if (t.flags = t.flags || 0, t.encoding = t.encoding || "binary", t.encoding !== "utf8" && t.encoding !== "binary")
        throw new Error(`Invalid encoding type "${t.encoding}"`);
      var i, o = g.open(e, t.flags), s = g.stat(e), c = s.size, h = new Uint8Array(c);
      return g.read(o, h, 0, c, 0), t.encoding === "utf8" ? i = xt(h, 0) : t.encoding === "binary" && (i = h), g.close(o), i;
    }, writeFile: (e, t, i = {}) => {
      i.flags = i.flags || 577;
      var o = g.open(e, i.flags, i.mode);
      if (typeof t == "string") {
        var s = new Uint8Array(at(t) + 1), c = ii(t, s, 0, s.length);
        g.write(o, s, 0, c, void 0, i.canOwn);
      } else if (ArrayBuffer.isView(t))
        g.write(o, t, 0, t.byteLength, void 0, i.canOwn);
      else
        throw new Error("Unsupported data type");
      g.close(o);
    }, cwd: () => g.currentPath, chdir: (e) => {
      var t = g.lookupPath(e, { follow: !0 });
      if (t.node === null)
        throw new g.ErrnoError(44);
      if (!g.isDir(t.node.mode))
        throw new g.ErrnoError(54);
      var i = g.nodePermissions(t.node, "x");
      if (i)
        throw new g.ErrnoError(i);
      g.currentPath = t.path;
    }, createDefaultDirectories: () => {
      g.mkdir("/tmp"), g.mkdir("/home"), g.mkdir("/home/web_user");
    }, createDefaultDevices: () => {
      g.mkdir("/dev"), g.registerDevice(g.makedev(1, 3), { read: () => 0, write: (o, s, c, h, b) => h }), g.mkdev("/dev/null", g.makedev(1, 3)), rr.register(g.makedev(5, 0), rr.default_tty_ops), rr.register(g.makedev(6, 0), rr.default_tty1_ops), g.mkdev("/dev/tty", g.makedev(5, 0)), g.mkdev("/dev/tty1", g.makedev(6, 0));
      var e = new Uint8Array(1024), t = 0, i = () => (t === 0 && (t = Me(e).byteLength), e[--t]);
      g.createDevice("/dev", "random", i), g.createDevice("/dev", "urandom", i), g.mkdir("/dev/shm"), g.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories: () => {
      g.mkdir("/proc");
      var e = g.mkdir("/proc/self");
      g.mkdir("/proc/self/fd"), g.mount({ mount: () => {
        var t = g.createNode(e, "fd", 16895, 73);
        return t.node_ops = { lookup: (i, o) => {
          var s = +o, c = g.getStreamChecked(s), h = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => c.path } };
          return h.parent = h, h;
        } }, t;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams: () => {
      n.stdin ? g.createDevice("/dev", "stdin", n.stdin) : g.symlink("/dev/tty", "/dev/stdin"), n.stdout ? g.createDevice("/dev", "stdout", null, n.stdout) : g.symlink("/dev/tty", "/dev/stdout"), n.stderr ? g.createDevice("/dev", "stderr", null, n.stderr) : g.symlink("/dev/tty1", "/dev/stderr"), g.open("/dev/stdin", 0), g.open("/dev/stdout", 1), g.open("/dev/stderr", 1);
    }, ensureErrnoError: () => {
      g.ErrnoError || (g.ErrnoError = function(t, i) {
        this.name = "ErrnoError", this.node = i, this.setErrno = function(o) {
          this.errno = o;
        }, this.setErrno(t), this.message = "FS error";
      }, g.ErrnoError.prototype = new Error(), g.ErrnoError.prototype.constructor = g.ErrnoError, [44].forEach((e) => {
        g.genericErrors[e] = new g.ErrnoError(e), g.genericErrors[e].stack = "<generic error, no stack>";
      }));
    }, staticInit: () => {
      g.ensureErrnoError(), g.nameTable = new Array(4096), g.mount(Ae, {}, "/"), g.createDefaultDirectories(), g.createDefaultDevices(), g.createSpecialDirectories(), g.filesystems = { MEMFS: Ae };
    }, init: (e, t, i) => {
      g.init.initialized = !0, g.ensureErrnoError(), n.stdin = e || n.stdin, n.stdout = t || n.stdout, n.stderr = i || n.stderr, g.createStandardStreams();
    }, quit: () => {
      g.init.initialized = !1;
      for (var e = 0; e < g.streams.length; e++) {
        var t = g.streams[e];
        t && g.close(t);
      }
    }, findObject: (e, t) => {
      var i = g.analyzePath(e, t);
      return i.exists ? i.object : null;
    }, analyzePath: (e, t) => {
      try {
        var i = g.lookupPath(e, { follow: !t });
        e = i.path;
      } catch {
      }
      var o = { isRoot: !1, exists: !1, error: 0, name: null, path: null, object: null, parentExists: !1, parentPath: null, parentObject: null };
      try {
        var i = g.lookupPath(e, { parent: !0 });
        o.parentExists = !0, o.parentPath = i.path, o.parentObject = i.node, o.name = _e.basename(e), i = g.lookupPath(e, { follow: !t }), o.exists = !0, o.path = i.path, o.object = i.node, o.name = i.node.name, o.isRoot = i.path === "/";
      } catch (s) {
        o.error = s.errno;
      }
      return o;
    }, createPath: (e, t, i, o) => {
      e = typeof e == "string" ? e : g.getPath(e);
      for (var s = t.split("/").reverse(); s.length; ) {
        var c = s.pop();
        if (c) {
          var h = _e.join2(e, c);
          try {
            g.mkdir(h);
          } catch {
          }
          e = h;
        }
      }
      return h;
    }, createFile: (e, t, i, o, s) => {
      var c = _e.join2(typeof e == "string" ? e : g.getPath(e), t), h = si(o, s);
      return g.create(c, h);
    }, createDataFile: (e, t, i, o, s, c) => {
      var h = t;
      e && (e = typeof e == "string" ? e : g.getPath(e), h = t ? _e.join2(e, t) : e);
      var b = si(o, s), x = g.create(h, b);
      if (i) {
        if (typeof i == "string") {
          for (var F = new Array(i.length), P = 0, W = i.length; P < W; ++P)
            F[P] = i.charCodeAt(P);
          i = F;
        }
        g.chmod(x, b | 146);
        var U = g.open(x, 577);
        g.write(U, i, 0, i.length, 0, c), g.close(U), g.chmod(x, b);
      }
      return x;
    }, createDevice: (e, t, i, o) => {
      var s = _e.join2(typeof e == "string" ? e : g.getPath(e), t), c = si(!!i, !!o);
      g.createDevice.major || (g.createDevice.major = 64);
      var h = g.makedev(g.createDevice.major++, 0);
      return g.registerDevice(h, { open: (b) => {
        b.seekable = !1;
      }, close: (b) => {
        o && o.buffer && o.buffer.length && o(10);
      }, read: (b, x, F, P, W) => {
        for (var U = 0, G = 0; G < P; G++) {
          var re;
          try {
            re = i();
          } catch {
            throw new g.ErrnoError(29);
          }
          if (re === void 0 && U === 0)
            throw new g.ErrnoError(6);
          if (re == null)
            break;
          U++, x[F + G] = re;
        }
        return U && (b.node.timestamp = Date.now()), U;
      }, write: (b, x, F, P, W) => {
        for (var U = 0; U < P; U++)
          try {
            o(x[F + U]);
          } catch {
            throw new g.ErrnoError(29);
          }
        return P && (b.node.timestamp = Date.now()), U;
      } }), g.mkdev(s, c, h);
    }, forceLoadFile: (e) => {
      if (e.isDevice || e.isFolder || e.link || e.contents)
        return !0;
      if (typeof XMLHttpRequest < "u")
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      if (ae)
        try {
          e.contents = tn(ae(e.url), !0), e.usedBytes = e.contents.length;
        } catch {
          throw new g.ErrnoError(29);
        }
      else
        throw new Error("Cannot load without read() or XMLHttpRequest.");
    }, createLazyFile: (e, t, i, o, s) => {
      function c() {
        this.lengthKnown = !1, this.chunks = [];
      }
      if (c.prototype.get = function(G) {
        if (!(G > this.length - 1 || G < 0)) {
          var re = G % this.chunkSize, se = G / this.chunkSize | 0;
          return this.getter(se)[re];
        }
      }, c.prototype.setDataGetter = function(G) {
        this.getter = G;
      }, c.prototype.cacheLength = function() {
        var G = new XMLHttpRequest();
        if (G.open("HEAD", i, !1), G.send(null), !(G.status >= 200 && G.status < 300 || G.status === 304))
          throw new Error("Couldn't load " + i + ". Status: " + G.status);
        var re = Number(G.getResponseHeader("Content-length")), se, fe = (se = G.getResponseHeader("Accept-Ranges")) && se === "bytes", be = (se = G.getResponseHeader("Content-Encoding")) && se === "gzip", H = 1024 * 1024;
        fe || (H = re);
        var ne = (Se, ue) => {
          if (Se > ue)
            throw new Error("invalid range (" + Se + ", " + ue + ") or no bytes requested!");
          if (ue > re - 1)
            throw new Error("only " + re + " bytes available! programmer error!");
          var Pe = new XMLHttpRequest();
          if (Pe.open("GET", i, !1), re !== H && Pe.setRequestHeader("Range", "bytes=" + Se + "-" + ue), Pe.responseType = "arraybuffer", Pe.overrideMimeType && Pe.overrideMimeType("text/plain; charset=x-user-defined"), Pe.send(null), !(Pe.status >= 200 && Pe.status < 300 || Pe.status === 304))
            throw new Error("Couldn't load " + i + ". Status: " + Pe.status);
          return Pe.response !== void 0 ? new Uint8Array(Pe.response || []) : tn(Pe.responseText || "", !0);
        }, ve = this;
        ve.setDataGetter((Se) => {
          var ue = Se * H, Pe = (Se + 1) * H - 1;
          if (Pe = Math.min(Pe, re - 1), typeof ve.chunks[Se] > "u" && (ve.chunks[Se] = ne(ue, Pe)), typeof ve.chunks[Se] > "u")
            throw new Error("doXHR failed!");
          return ve.chunks[Se];
        }), (be || !re) && (H = re = 1, re = this.getter(0).length, H = re, K("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = re, this._chunkSize = H, this.lengthKnown = !0;
      }, typeof XMLHttpRequest < "u") {
        throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var h, b;
      } else
        var b = { isDevice: !1, url: i };
      var x = g.createFile(e, t, b, o, s);
      b.contents ? x.contents = b.contents : b.url && (x.contents = null, x.url = b.url), Object.defineProperties(x, { usedBytes: { get: function() {
        return this.contents.length;
      } } });
      var F = {}, P = Object.keys(x.stream_ops);
      P.forEach((U) => {
        var G = x.stream_ops[U];
        F[U] = function() {
          return g.forceLoadFile(x), G.apply(null, arguments);
        };
      });
      function W(U, G, re, se, fe) {
        var be = U.node.contents;
        if (fe >= be.length)
          return 0;
        var H = Math.min(be.length - fe, se);
        if (be.slice)
          for (var ne = 0; ne < H; ne++)
            G[re + ne] = be[fe + ne];
        else
          for (var ne = 0; ne < H; ne++)
            G[re + ne] = be.get(fe + ne);
        return H;
      }
      return F.read = (U, G, re, se, fe) => (g.forceLoadFile(x), W(U, G, re, se, fe)), F.mmap = (U, G, re, se, fe) => {
        g.forceLoadFile(x);
        var be = La(G);
        if (!be)
          throw new g.ErrnoError(48);
        return W(U, Ee, be, G, re), { ptr: be, allocated: !0 };
      }, x.stream_ops = F, x;
    } }, Xe = (e, t) => e ? xt(de, e, t) : "", xe = { DEFAULT_POLLMASK: 5, calculateAt: function(e, t, i) {
      if (_e.isAbs(t))
        return t;
      var o;
      if (e === -100)
        o = g.cwd();
      else {
        var s = xe.getStreamFromFD(e);
        o = s.path;
      }
      if (t.length == 0) {
        if (!i)
          throw new g.ErrnoError(44);
        return o;
      }
      return _e.join2(o, t);
    }, doStat: function(e, t, i) {
      try {
        var o = e(t);
      } catch (b) {
        if (b && b.node && _e.normalize(t) !== _e.normalize(g.getPath(b.node)))
          return -54;
        throw b;
      }
      I[i >> 2] = o.dev, I[i + 4 >> 2] = o.mode, X[i + 8 >> 2] = o.nlink, I[i + 12 >> 2] = o.uid, I[i + 16 >> 2] = o.gid, I[i + 20 >> 2] = o.rdev, V = [o.size >>> 0, (N = o.size, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[i + 24 >> 2] = V[0], I[i + 28 >> 2] = V[1], I[i + 32 >> 2] = 4096, I[i + 36 >> 2] = o.blocks;
      var s = o.atime.getTime(), c = o.mtime.getTime(), h = o.ctime.getTime();
      return V = [Math.floor(s / 1e3) >>> 0, (N = Math.floor(s / 1e3), +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[i + 40 >> 2] = V[0], I[i + 44 >> 2] = V[1], X[i + 48 >> 2] = s % 1e3 * 1e3, V = [Math.floor(c / 1e3) >>> 0, (N = Math.floor(c / 1e3), +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[i + 56 >> 2] = V[0], I[i + 60 >> 2] = V[1], X[i + 64 >> 2] = c % 1e3 * 1e3, V = [Math.floor(h / 1e3) >>> 0, (N = Math.floor(h / 1e3), +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[i + 72 >> 2] = V[0], I[i + 76 >> 2] = V[1], X[i + 80 >> 2] = h % 1e3 * 1e3, V = [o.ino >>> 0, (N = o.ino, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[i + 88 >> 2] = V[0], I[i + 92 >> 2] = V[1], 0;
    }, doMsync: function(e, t, i, o, s) {
      if (!g.isFile(t.node.mode))
        throw new g.ErrnoError(43);
      if (o & 2)
        return 0;
      var c = de.slice(e, e + i);
      g.msync(t, c, s, i, o);
    }, varargs: void 0, get() {
      xe.varargs += 4;
      var e = I[xe.varargs - 4 >> 2];
      return e;
    }, getStr(e) {
      var t = Xe(e);
      return t;
    }, getStreamFromFD: function(e) {
      var t = g.getStreamChecked(e);
      return t;
    } };
    function il(e, t) {
      try {
        return e = xe.getStr(e), g.chmod(e, t), 0;
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return -i.errno;
      }
    }
    function al(e, t) {
      try {
        return g.fchmod(e, t), 0;
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return -i.errno;
      }
    }
    var ol = (e) => (I[co() >> 2] = e, e);
    function sl(e, t, i) {
      xe.varargs = i;
      try {
        var o = xe.getStreamFromFD(e);
        switch (t) {
          case 0: {
            var s = xe.get();
            if (s < 0)
              return -28;
            var c;
            return c = g.createStream(o, s), c.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return o.flags;
          case 4: {
            var s = xe.get();
            return o.flags |= s, 0;
          }
          case 5: {
            var s = xe.get(), h = 0;
            return Re[s + h >> 1] = 2, 0;
          }
          case 6:
          case 7:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            return ol(28), -1;
          default:
            return -28;
        }
      } catch (b) {
        if (typeof g > "u" || b.name !== "ErrnoError")
          throw b;
        return -b.errno;
      }
    }
    function ul(e, t) {
      try {
        var i = xe.getStreamFromFD(e);
        return xe.doStat(g.stat, i.path, t);
      } catch (o) {
        if (typeof g > "u" || o.name !== "ErrnoError")
          throw o;
        return -o.errno;
      }
    }
    function br(e, t) {
      return t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + t * 4294967296 : NaN;
    }
    function ll(e, t, i) {
      var o = br(t, i);
      try {
        return isNaN(o) ? 61 : (g.ftruncate(e, o), 0);
      } catch (s) {
        if (typeof g > "u" || s.name !== "ErrnoError")
          throw s;
        return -s.errno;
      }
    }
    var ot = (e, t, i) => ii(e, de, t, i);
    function fl(e, t) {
      try {
        if (t === 0)
          return -28;
        var i = g.cwd(), o = at(i) + 1;
        return t < o ? -68 : (ot(i, e, t), o);
      } catch (s) {
        if (typeof g > "u" || s.name !== "ErrnoError")
          throw s;
        return -s.errno;
      }
    }
    function cl(e, t, i) {
      try {
        var o = xe.getStreamFromFD(e);
        o.getdents || (o.getdents = g.readdir(o.path));
        for (var s = 280, c = 0, h = g.llseek(o, 0, 1), b = Math.floor(h / s); b < o.getdents.length && c + s <= i; ) {
          var x, F, P = o.getdents[b];
          if (P === ".")
            x = o.node.id, F = 4;
          else if (P === "..") {
            var W = g.lookupPath(o.path, { parent: !0 });
            x = W.node.id, F = 4;
          } else {
            var U = g.lookupNode(o.node, P);
            x = U.id, F = g.isChrdev(U.mode) ? 2 : g.isDir(U.mode) ? 4 : g.isLink(U.mode) ? 10 : 8;
          }
          V = [x >>> 0, (N = x, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[t + c >> 2] = V[0], I[t + c + 4 >> 2] = V[1], V = [(b + 1) * s >>> 0, (N = (b + 1) * s, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[t + c + 8 >> 2] = V[0], I[t + c + 12 >> 2] = V[1], Re[t + c + 16 >> 1] = 280, Ee[t + c + 18 >> 0] = F, ot(P, t + c + 19, 256), c += s, b += 1;
        }
        return g.llseek(o, b * s, 0), c;
      } catch (G) {
        if (typeof g > "u" || G.name !== "ErrnoError")
          throw G;
        return -G.errno;
      }
    }
    function dl(e, t, i) {
      xe.varargs = i;
      try {
        var o = xe.getStreamFromFD(e);
        switch (t) {
          case 21509:
            return o.tty ? 0 : -59;
          case 21505: {
            if (!o.tty)
              return -59;
            if (o.tty.ops.ioctl_tcgets) {
              var s = o.tty.ops.ioctl_tcgets(o), c = xe.get();
              I[c >> 2] = s.c_iflag || 0, I[c + 4 >> 2] = s.c_oflag || 0, I[c + 8 >> 2] = s.c_cflag || 0, I[c + 12 >> 2] = s.c_lflag || 0;
              for (var h = 0; h < 32; h++)
                Ee[c + h + 17 >> 0] = s.c_cc[h] || 0;
              return 0;
            }
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
            return o.tty ? 0 : -59;
          case 21506:
          case 21507:
          case 21508: {
            if (!o.tty)
              return -59;
            if (o.tty.ops.ioctl_tcsets) {
              for (var c = xe.get(), b = I[c >> 2], x = I[c + 4 >> 2], F = I[c + 8 >> 2], P = I[c + 12 >> 2], W = [], h = 0; h < 32; h++)
                W.push(Ee[c + h + 17 >> 0]);
              return o.tty.ops.ioctl_tcsets(o.tty, t, { c_iflag: b, c_oflag: x, c_cflag: F, c_lflag: P, c_cc: W });
            }
            return 0;
          }
          case 21519: {
            if (!o.tty)
              return -59;
            var c = xe.get();
            return I[c >> 2] = 0, 0;
          }
          case 21520:
            return o.tty ? -28 : -59;
          case 21531: {
            var c = xe.get();
            return g.ioctl(o, t, c);
          }
          case 21523: {
            if (!o.tty)
              return -59;
            if (o.tty.ops.ioctl_tiocgwinsz) {
              var U = o.tty.ops.ioctl_tiocgwinsz(o.tty), c = xe.get();
              Re[c >> 1] = U[0], Re[c + 2 >> 1] = U[1];
            }
            return 0;
          }
          case 21524:
            return o.tty ? 0 : -59;
          case 21515:
            return o.tty ? 0 : -59;
          default:
            return -28;
        }
      } catch (G) {
        if (typeof g > "u" || G.name !== "ErrnoError")
          throw G;
        return -G.errno;
      }
    }
    function hl(e, t) {
      try {
        return e = xe.getStr(e), xe.doStat(g.lstat, e, t);
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return -i.errno;
      }
    }
    function pl(e, t, i) {
      try {
        return t = xe.getStr(t), t = xe.calculateAt(e, t), t = _e.normalize(t), t[t.length - 1] === "/" && (t = t.substr(0, t.length - 1)), g.mkdir(t, i, 0), 0;
      } catch (o) {
        if (typeof g > "u" || o.name !== "ErrnoError")
          throw o;
        return -o.errno;
      }
    }
    function ml(e, t, i, o) {
      try {
        t = xe.getStr(t);
        var s = o & 256, c = o & 4096;
        return o = o & -6401, t = xe.calculateAt(e, t, c), xe.doStat(s ? g.lstat : g.stat, t, i);
      } catch (h) {
        if (typeof g > "u" || h.name !== "ErrnoError")
          throw h;
        return -h.errno;
      }
    }
    function _l(e, t, i, o) {
      xe.varargs = o;
      try {
        t = xe.getStr(t), t = xe.calculateAt(e, t);
        var s = o ? xe.get() : 0;
        return g.open(t, i, s).fd;
      } catch (c) {
        if (typeof g > "u" || c.name !== "ErrnoError")
          throw c;
        return -c.errno;
      }
    }
    function bl(e, t, i, o) {
      try {
        if (t = xe.getStr(t), t = xe.calculateAt(e, t), o <= 0)
          return -28;
        var s = g.readlink(t), c = Math.min(o, at(s)), h = Ee[i + c];
        return ot(s, i, o + 1), Ee[i + c] = h, c;
      } catch (b) {
        if (typeof g > "u" || b.name !== "ErrnoError")
          throw b;
        return -b.errno;
      }
    }
    function yl(e, t, i, o) {
      try {
        return t = xe.getStr(t), o = xe.getStr(o), t = xe.calculateAt(e, t), o = xe.calculateAt(i, o), g.rename(t, o), 0;
      } catch (s) {
        if (typeof g > "u" || s.name !== "ErrnoError")
          throw s;
        return -s.errno;
      }
    }
    function gl(e, t) {
      try {
        return e = xe.getStr(e), xe.doStat(g.stat, e, t);
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return -i.errno;
      }
    }
    function wl(e, t) {
      try {
        return e = xe.getStr(e), t = xe.getStr(t), g.symlink(e, t), 0;
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return -i.errno;
      }
    }
    function vl(e, t, i) {
      try {
        return t = xe.getStr(t), t = xe.calculateAt(e, t), i === 0 ? g.unlink(t) : i === 512 ? g.rmdir(t) : qe("Invalid flags passed to unlinkat"), 0;
      } catch (o) {
        if (typeof g > "u" || o.name !== "ErrnoError")
          throw o;
        return -o.errno;
      }
    }
    function El(e, t, i, o, s) {
    }
    function rn(e) {
      switch (e) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError(`Unknown type size: ${e}`);
      }
    }
    function xl() {
      for (var e = new Array(256), t = 0; t < 256; ++t)
        e[t] = String.fromCharCode(t);
      Ma = e;
    }
    var Ma = void 0;
    function et(e) {
      for (var t = "", i = e; de[i]; )
        t += Ma[de[i++]];
      return t;
    }
    var yr = {}, nr = {}, nn = {}, gr = void 0;
    function Le(e) {
      throw new gr(e);
    }
    var Ba = void 0;
    function an(e) {
      throw new Ba(e);
    }
    function It(e, t, i) {
      e.forEach(function(b) {
        nn[b] = t;
      });
      function o(b) {
        var x = i(b);
        x.length !== e.length && an("Mismatched type converter count");
        for (var F = 0; F < e.length; ++F)
          kt(e[F], x[F]);
      }
      var s = new Array(t.length), c = [], h = 0;
      t.forEach((b, x) => {
        nr.hasOwnProperty(b) ? s[x] = nr[b] : (c.push(b), yr.hasOwnProperty(b) || (yr[b] = []), yr[b].push(() => {
          s[x] = nr[b], ++h, h === c.length && o(s);
        }));
      }), c.length === 0 && o(s);
    }
    function Sl(e, t, i = {}) {
      var o = t.name;
      if (e || Le(`type "${o}" must have a positive integer typeid pointer`), nr.hasOwnProperty(e)) {
        if (i.ignoreDuplicateRegistrations)
          return;
        Le(`Cannot register type '${o}' twice`);
      }
      if (nr[e] = t, delete nn[e], yr.hasOwnProperty(e)) {
        var s = yr[e];
        delete yr[e], s.forEach((c) => c());
      }
    }
    function kt(e, t, i = {}) {
      if (!("argPackAdvance" in t))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return Sl(e, t, i);
    }
    function Cl(e, t, i, o, s) {
      var c = rn(i);
      t = et(t), kt(e, { name: t, fromWireType: function(h) {
        return !!h;
      }, toWireType: function(h, b) {
        return b ? o : s;
      }, argPackAdvance: 8, readValueFromPointer: function(h) {
        var b;
        if (i === 1)
          b = Ee;
        else if (i === 2)
          b = Re;
        else if (i === 4)
          b = I;
        else
          throw new TypeError("Unknown boolean type size: " + t);
        return this.fromWireType(b[h >> c]);
      }, destructorFunction: null });
    }
    function Tl(e) {
      if (!(this instanceof Xt) || !(e instanceof Xt))
        return !1;
      for (var t = this.$$.ptrType.registeredClass, i = this.$$.ptr, o = e.$$.ptrType.registeredClass, s = e.$$.ptr; t.baseClass; )
        i = t.upcast(i), t = t.baseClass;
      for (; o.baseClass; )
        s = o.upcast(s), o = o.baseClass;
      return t === o && i === s;
    }
    function Fl(e) {
      return { count: e.count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType };
    }
    function ui(e) {
      function t(i) {
        return i.$$.ptrType.registeredClass.name;
      }
      Le(t(e) + " instance already deleted");
    }
    var li = !1;
    function Na(e) {
    }
    function Rl(e) {
      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
    }
    function Oa(e) {
      e.count.value -= 1;
      var t = e.count.value === 0;
      t && Rl(e);
    }
    function ja(e, t, i) {
      if (t === i)
        return e;
      if (i.baseClass === void 0)
        return null;
      var o = ja(e, t, i.baseClass);
      return o === null ? null : i.downcast(o);
    }
    var Ua = {};
    function Al() {
      return Object.keys(Mr).length;
    }
    function Il() {
      var e = [];
      for (var t in Mr)
        Mr.hasOwnProperty(t) && e.push(Mr[t]);
      return e;
    }
    var Dr = [];
    function fi() {
      for (; Dr.length; ) {
        var e = Dr.pop();
        e.$$.deleteScheduled = !1, e.delete();
      }
    }
    var Lr = void 0;
    function Pl(e) {
      Lr = e, Dr.length && Lr && Lr(fi);
    }
    function kl() {
      n.getInheritedInstanceCount = Al, n.getLiveInheritedInstances = Il, n.flushPendingDeletes = fi, n.setDelayFunction = Pl;
    }
    var Mr = {};
    function Dl(e, t) {
      for (t === void 0 && Le("ptr should not be undefined"); e.baseClass; )
        t = e.upcast(t), e = e.baseClass;
      return t;
    }
    function Ll(e, t) {
      return t = Dl(e, t), Mr[t];
    }
    function on(e, t) {
      (!t.ptrType || !t.ptr) && an("makeClassHandle requires ptr and ptrType");
      var i = !!t.smartPtrType, o = !!t.smartPtr;
      return i !== o && an("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, Br(Object.create(e, { $$: { value: t } }));
    }
    function Ml(e) {
      var t = this.getPointee(e);
      if (!t)
        return this.destructor(e), null;
      var i = Ll(this.registeredClass, t);
      if (i !== void 0) {
        if (i.$$.count.value === 0)
          return i.$$.ptr = t, i.$$.smartPtr = e, i.clone();
        var o = i.clone();
        return this.destructor(e), o;
      }
      function s() {
        return this.isSmartPointer ? on(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: t, smartPtrType: this, smartPtr: e }) : on(this.registeredClass.instancePrototype, { ptrType: this, ptr: e });
      }
      var c = this.registeredClass.getActualType(t), h = Ua[c];
      if (!h)
        return s.call(this);
      var b;
      this.isConst ? b = h.constPointerType : b = h.pointerType;
      var x = ja(t, this.registeredClass, b.registeredClass);
      return x === null ? s.call(this) : this.isSmartPointer ? on(b.registeredClass.instancePrototype, { ptrType: b, ptr: x, smartPtrType: this, smartPtr: e }) : on(b.registeredClass.instancePrototype, { ptrType: b, ptr: x });
    }
    var Br = function(e) {
      return typeof FinalizationRegistry > "u" ? (Br = (t) => t, e) : (li = new FinalizationRegistry((t) => {
        Oa(t.$$);
      }), Br = (t) => {
        var i = t.$$, o = !!i.smartPtr;
        if (o) {
          var s = { $$: i };
          li.register(t, s, t);
        }
        return t;
      }, Na = (t) => li.unregister(t), Br(e));
    };
    function Bl() {
      if (this.$$.ptr || ui(this), this.$$.preservePointerOnDelete)
        return this.$$.count.value += 1, this;
      var e = Br(Object.create(Object.getPrototypeOf(this), { $$: { value: Fl(this.$$) } }));
      return e.$$.count.value += 1, e.$$.deleteScheduled = !1, e;
    }
    function Nl() {
      this.$$.ptr || ui(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Le("Object already scheduled for deletion"), Na(this), Oa(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
    }
    function Ol() {
      return !this.$$.ptr;
    }
    function jl() {
      return this.$$.ptr || ui(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Le("Object already scheduled for deletion"), Dr.push(this), Dr.length === 1 && Lr && Lr(fi), this.$$.deleteScheduled = !0, this;
    }
    function Ul() {
      Xt.prototype.isAliasOf = Tl, Xt.prototype.clone = Bl, Xt.prototype.delete = Nl, Xt.prototype.isDeleted = Ol, Xt.prototype.deleteLater = jl;
    }
    function Xt() {
    }
    var Wl = 48, $l = 57;
    function sn(e) {
      if (e === void 0)
        return "_unknown";
      e = e.replace(/[^a-zA-Z0-9_]/g, "$");
      var t = e.charCodeAt(0);
      return t >= Wl && t <= $l ? `_${e}` : e;
    }
    function un(e, t) {
      return e = sn(e), { [e]: function() {
        return t.apply(this, arguments);
      } }[e];
    }
    function ci(e, t, i) {
      if (e[t].overloadTable === void 0) {
        var o = e[t];
        e[t] = function() {
          return e[t].overloadTable.hasOwnProperty(arguments.length) || Le(`Function '${i}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[arguments.length].apply(this, arguments);
        }, e[t].overloadTable = [], e[t].overloadTable[o.argCount] = o;
      }
    }
    function di(e, t, i) {
      n.hasOwnProperty(e) ? ((i === void 0 || n[e].overloadTable !== void 0 && n[e].overloadTable[i] !== void 0) && Le(`Cannot register public name '${e}' twice`), ci(n, e, e), n.hasOwnProperty(i) && Le(`Cannot register multiple overloads of a function with the same number of arguments (${i})!`), n[e].overloadTable[i] = t) : (n[e] = t, i !== void 0 && (n[e].numArguments = i));
    }
    function Gl(e, t, i, o, s, c, h, b) {
      this.name = e, this.constructor = t, this.instancePrototype = i, this.rawDestructor = o, this.baseClass = s, this.getActualType = c, this.upcast = h, this.downcast = b, this.pureVirtualFunctions = [];
    }
    function ln(e, t, i) {
      for (; t !== i; )
        t.upcast || Le(`Expected null or instance of ${i.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;
      return e;
    }
    function Vl(e, t) {
      if (t === null)
        return this.isReference && Le(`null is not a valid ${this.name}`), 0;
      t.$$ || Le(`Cannot pass "${_i(t)}" as a ${this.name}`), t.$$.ptr || Le(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var i = t.$$.ptrType.registeredClass, o = ln(t.$$.ptr, i, this.registeredClass);
      return o;
    }
    function zl(e, t) {
      var i;
      if (t === null)
        return this.isReference && Le(`null is not a valid ${this.name}`), this.isSmartPointer ? (i = this.rawConstructor(), e !== null && e.push(this.rawDestructor, i), i) : 0;
      t.$$ || Le(`Cannot pass "${_i(t)}" as a ${this.name}`), t.$$.ptr || Le(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && Le(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
      var o = t.$$.ptrType.registeredClass;
      if (i = ln(t.$$.ptr, o, this.registeredClass), this.isSmartPointer)
        switch (t.$$.smartPtr === void 0 && Le("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            t.$$.smartPtrType === this ? i = t.$$.smartPtr : Le(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            i = t.$$.smartPtr;
            break;
          case 2:
            if (t.$$.smartPtrType === this)
              i = t.$$.smartPtr;
            else {
              var s = t.clone();
              i = this.rawShare(i, He.toHandle(function() {
                s.delete();
              })), e !== null && e.push(this.rawDestructor, i);
            }
            break;
          default:
            Le("Unsupporting sharing policy");
        }
      return i;
    }
    function Hl(e, t) {
      if (t === null)
        return this.isReference && Le(`null is not a valid ${this.name}`), 0;
      t.$$ || Le(`Cannot pass "${_i(t)}" as a ${this.name}`), t.$$.ptr || Le(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && Le(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
      var i = t.$$.ptrType.registeredClass, o = ln(t.$$.ptr, i, this.registeredClass);
      return o;
    }
    function fn(e) {
      return this.fromWireType(I[e >> 2]);
    }
    function Kl(e) {
      return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
    }
    function Yl(e) {
      this.rawDestructor && this.rawDestructor(e);
    }
    function Xl(e) {
      e !== null && e.delete();
    }
    function Zl() {
      Dt.prototype.getPointee = Kl, Dt.prototype.destructor = Yl, Dt.prototype.argPackAdvance = 8, Dt.prototype.readValueFromPointer = fn, Dt.prototype.deleteObject = Xl, Dt.prototype.fromWireType = Ml;
    }
    function Dt(e, t, i, o, s, c, h, b, x, F, P) {
      this.name = e, this.registeredClass = t, this.isReference = i, this.isConst = o, this.isSmartPointer = s, this.pointeeType = c, this.sharingPolicy = h, this.rawGetPointee = b, this.rawConstructor = x, this.rawShare = F, this.rawDestructor = P, !s && t.baseClass === void 0 ? o ? (this.toWireType = Vl, this.destructorFunction = null) : (this.toWireType = Hl, this.destructorFunction = null) : this.toWireType = zl;
    }
    function Wa(e, t, i) {
      n.hasOwnProperty(e) || an("Replacing nonexistant public symbol"), n[e].overloadTable !== void 0 && i !== void 0 ? n[e].overloadTable[i] = t : (n[e] = t, n[e].argCount = i);
    }
    var ql = (e, t, i) => {
      var o = n["dynCall_" + e];
      return i && i.length ? o.apply(null, [t].concat(i)) : o.call(null, t);
    }, cn = [], Zt = (e) => {
      var t = cn[e];
      return t || (e >= cn.length && (cn.length = e + 1), cn[e] = t = ge.get(e)), t;
    }, Ql = (e, t, i) => {
      if (e.includes("j"))
        return ql(e, t, i);
      var o = Zt(t).apply(null, i);
      return o;
    }, Jl = (e, t) => {
      var i = [];
      return function() {
        return i.length = 0, Object.assign(i, arguments), Ql(e, t, i);
      };
    };
    function _t(e, t) {
      e = et(e);
      function i() {
        return e.includes("j") ? Jl(e, t) : Zt(t);
      }
      var o = i();
      return typeof o != "function" && Le(`unknown function pointer with signature ${e}: ${t}`), o;
    }
    function ef(e, t) {
      var i = un(t, function(o) {
        this.name = t, this.message = o;
        var s = new Error(o).stack;
        s !== void 0 && (this.stack = this.toString() + `
` + s.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return i.prototype = Object.create(e.prototype), i.prototype.constructor = i, i.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, i;
    }
    var $a = void 0;
    function Ga(e) {
      var t = ho(e), i = et(t);
      return Mt(t), i;
    }
    function ir(e, t) {
      var i = [], o = {};
      function s(c) {
        if (!o[c] && !nr[c]) {
          if (nn[c]) {
            nn[c].forEach(s);
            return;
          }
          i.push(c), o[c] = !0;
        }
      }
      throw t.forEach(s), new $a(`${e}: ` + i.map(Ga).join([", "]));
    }
    function tf(e, t, i, o, s, c, h, b, x, F, P, W, U) {
      P = et(P), c = _t(s, c), b && (b = _t(h, b)), F && (F = _t(x, F)), U = _t(W, U);
      var G = sn(P);
      di(G, function() {
        ir(`Cannot construct ${P} due to unbound types`, [o]);
      }), It([e, t, i], o ? [o] : [], function(re) {
        re = re[0];
        var se, fe;
        o ? (se = re.registeredClass, fe = se.instancePrototype) : fe = Xt.prototype;
        var be = un(G, function() {
          if (Object.getPrototypeOf(this) !== H)
            throw new gr("Use 'new' to construct " + P);
          if (ne.constructor_body === void 0)
            throw new gr(P + " has no accessible constructor");
          var Pe = ne.constructor_body[arguments.length];
          if (Pe === void 0)
            throw new gr(`Tried to invoke ctor of ${P} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(ne.constructor_body).toString()}) parameters instead!`);
          return Pe.apply(this, arguments);
        }), H = Object.create(fe, { constructor: { value: be } });
        be.prototype = H;
        var ne = new Gl(P, be, H, U, se, c, b, F);
        ne.baseClass && (ne.baseClass.__derivedClasses === void 0 && (ne.baseClass.__derivedClasses = []), ne.baseClass.__derivedClasses.push(ne));
        var ve = new Dt(P, ne, !0, !1, !1), Se = new Dt(P + "*", ne, !1, !1, !1), ue = new Dt(P + " const*", ne, !1, !0, !1);
        return Ua[e] = { pointerType: Se, constPointerType: ue }, Wa(G, be), [ve, Se, ue];
      });
    }
    function hi(e) {
      for (; e.length; ) {
        var t = e.pop(), i = e.pop();
        i(t);
      }
    }
    function Va(e, t) {
      if (!(e instanceof Function))
        throw new TypeError(`new_ called with constructor type ${typeof e} which is not a function`);
      var i = un(e.name || "unknownFunctionName", function() {
      });
      i.prototype = e.prototype;
      var o = new i(), s = e.apply(o, t);
      return s instanceof Object ? s : o;
    }
    function dn(e, t, i, o, s, c) {
      var h = t.length;
      h < 2 && Le("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var b = t[1] !== null && i !== null, x = !1, F = 1; F < t.length; ++F)
        if (t[F] !== null && t[F].destructorFunction === void 0) {
          x = !0;
          break;
        }
      for (var P = t[0].name !== "void", W = "", U = "", F = 0; F < h - 2; ++F)
        W += (F !== 0 ? ", " : "") + "arg" + F, U += (F !== 0 ? ", " : "") + "arg" + F + "Wired";
      var G = `
        return function ${sn(e)}(${W}) {
        if (arguments.length !== ${h - 2}) {
          throwBindingError('function ${e} called with ${arguments.length} arguments, expected ${h - 2} args!');
        }`;
      x && (G += `var destructors = [];
`);
      var re = x ? "destructors" : "null", se = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"], fe = [Le, o, s, hi, t[0], t[1]];
      b && (G += "var thisWired = classParam.toWireType(" + re + `, this);
`);
      for (var F = 0; F < h - 2; ++F)
        G += "var arg" + F + "Wired = argType" + F + ".toWireType(" + re + ", arg" + F + "); // " + t[F + 2].name + `
`, se.push("argType" + F), fe.push(t[F + 2]);
      if (b && (U = "thisWired" + (U.length > 0 ? ", " : "") + U), G += (P || c ? "var rv = " : "") + "invoker(fn" + (U.length > 0 ? ", " : "") + U + `);
`, x)
        G += `runDestructors(destructors);
`;
      else
        for (var F = b ? 1 : 2; F < t.length; ++F) {
          var be = F === 1 ? "thisWired" : "arg" + (F - 2) + "Wired";
          t[F].destructorFunction !== null && (G += be + "_dtor(" + be + "); // " + t[F].name + `
`, se.push(be + "_dtor"), fe.push(t[F].destructorFunction));
        }
      return P && (G += `var ret = retType.fromWireType(rv);
return ret;
`), G += `}
`, se.push(G), Va(Function, se).apply(null, fe);
    }
    function hn(e, t) {
      for (var i = [], o = 0; o < e; o++)
        i.push(X[t + o * 4 >> 2]);
      return i;
    }
    function rf(e, t, i, o, s, c, h, b) {
      var x = hn(i, o);
      t = et(t), c = _t(s, c), It([], [e], function(F) {
        F = F[0];
        var P = `${F.name}.${t}`;
        function W() {
          ir(`Cannot call ${P} due to unbound types`, x);
        }
        t.startsWith("@@") && (t = Symbol[t.substring(2)]);
        var U = F.registeredClass.constructor;
        return U[t] === void 0 ? (W.argCount = i - 1, U[t] = W) : (ci(U, t, P), U[t].overloadTable[i - 1] = W), It([], x, function(G) {
          var re = [G[0], null].concat(G.slice(1)), se = dn(P, re, null, c, h, b);
          if (U[t].overloadTable === void 0 ? (se.argCount = i - 1, U[t] = se) : U[t].overloadTable[i - 1] = se, F.registeredClass.__derivedClasses)
            for (const fe of F.registeredClass.__derivedClasses)
              fe.constructor.hasOwnProperty(t) || (fe.constructor[t] = se);
          return [];
        }), [];
      });
    }
    function nf(e, t, i, o, s, c) {
      var h = hn(t, i);
      s = _t(o, s), It([], [e], function(b) {
        b = b[0];
        var x = `constructor ${b.name}`;
        if (b.registeredClass.constructor_body === void 0 && (b.registeredClass.constructor_body = []), b.registeredClass.constructor_body[t - 1] !== void 0)
          throw new gr(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${b.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return b.registeredClass.constructor_body[t - 1] = () => {
          ir(`Cannot construct ${b.name} due to unbound types`, h);
        }, It([], h, function(F) {
          return F.splice(1, 0, null), b.registeredClass.constructor_body[t - 1] = dn(x, F, null, s, c), [];
        }), [];
      });
    }
    function af(e, t, i, o, s, c, h, b, x) {
      var F = hn(i, o);
      t = et(t), c = _t(s, c), It([], [e], function(P) {
        P = P[0];
        var W = `${P.name}.${t}`;
        t.startsWith("@@") && (t = Symbol[t.substring(2)]), b && P.registeredClass.pureVirtualFunctions.push(t);
        function U() {
          ir(`Cannot call ${W} due to unbound types`, F);
        }
        var G = P.registeredClass.instancePrototype, re = G[t];
        return re === void 0 || re.overloadTable === void 0 && re.className !== P.name && re.argCount === i - 2 ? (U.argCount = i - 2, U.className = P.name, G[t] = U) : (ci(G, t, W), G[t].overloadTable[i - 2] = U), It([], F, function(se) {
          var fe = dn(W, se, P, c, h, x);
          return G[t].overloadTable === void 0 ? (fe.argCount = i - 2, G[t] = fe) : G[t].overloadTable[i - 2] = fe, [];
        }), [];
      });
    }
    function za(e, t, i) {
      return e instanceof Object || Le(`${i} with invalid "this": ${e}`), e instanceof t.registeredClass.constructor || Le(`${i} incompatible with "this" of type ${e.constructor.name}`), e.$$.ptr || Le(`cannot call emscripten binding method ${i} on deleted object`), ln(e.$$.ptr, e.$$.ptrType.registeredClass, t.registeredClass);
    }
    function of(e, t, i, o, s, c, h, b, x, F) {
      t = et(t), s = _t(o, s), It([], [e], function(P) {
        P = P[0];
        var W = `${P.name}.${t}`, U = { get() {
          ir(`Cannot access ${W} due to unbound types`, [i, h]);
        }, enumerable: !0, configurable: !0 };
        return x ? U.set = () => {
          ir(`Cannot access ${W} due to unbound types`, [i, h]);
        } : U.set = (G) => {
          Le(W + " is a read-only property");
        }, Object.defineProperty(P.registeredClass.instancePrototype, t, U), It([], x ? [i, h] : [i], function(G) {
          var re = G[0], se = { get() {
            var be = za(this, P, W + " getter");
            return re.fromWireType(s(c, be));
          }, enumerable: !0 };
          if (x) {
            x = _t(b, x);
            var fe = G[1];
            se.set = function(be) {
              var H = za(this, P, W + " setter"), ne = [];
              x(F, H, fe.toWireType(ne, be)), hi(ne);
            };
          }
          return Object.defineProperty(P.registeredClass.instancePrototype, t, se), [];
        }), [];
      });
    }
    function sf() {
      Object.assign(pi.prototype, { get(e) {
        return this.allocated[e];
      }, has(e) {
        return this.allocated[e] !== void 0;
      }, allocate(e) {
        var t = this.freelist.pop() || this.allocated.length;
        return this.allocated[t] = e, t;
      }, free(e) {
        this.allocated[e] = void 0, this.freelist.push(e);
      } });
    }
    function pi() {
      this.allocated = [void 0], this.freelist = [];
    }
    var St = new pi();
    function mi(e) {
      e >= St.reserved && --St.get(e).refcount === 0 && St.free(e);
    }
    function uf() {
      for (var e = 0, t = St.reserved; t < St.allocated.length; ++t)
        St.allocated[t] !== void 0 && ++e;
      return e;
    }
    function lf() {
      St.allocated.push({ value: void 0 }, { value: null }, { value: !0 }, { value: !1 }), St.reserved = St.allocated.length, n.count_emval_handles = uf;
    }
    var He = { toValue: (e) => (e || Le("Cannot use deleted val. handle = " + e), St.get(e).value), toHandle: (e) => {
      switch (e) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          return St.allocate({ refcount: 1, value: e });
      }
    } };
    function ff(e, t) {
      t = et(t), kt(e, { name: t, fromWireType: function(i) {
        var o = He.toValue(i);
        return mi(i), o;
      }, toWireType: function(i, o) {
        return He.toHandle(o);
      }, argPackAdvance: 8, readValueFromPointer: fn, destructorFunction: null });
    }
    function cf(e, t, i) {
      switch (t) {
        case 0:
          return function(o) {
            var s = i ? Ee : de;
            return this.fromWireType(s[o]);
          };
        case 1:
          return function(o) {
            var s = i ? Re : ye;
            return this.fromWireType(s[o >> 1]);
          };
        case 2:
          return function(o) {
            var s = i ? I : X;
            return this.fromWireType(s[o >> 2]);
          };
        default:
          throw new TypeError("Unknown integer type: " + e);
      }
    }
    function df(e, t, i, o) {
      var s = rn(i);
      t = et(t);
      function c() {
      }
      c.values = {}, kt(e, { name: t, constructor: c, fromWireType: function(h) {
        return this.constructor.values[h];
      }, toWireType: function(h, b) {
        return b.value;
      }, argPackAdvance: 8, readValueFromPointer: cf(t, s, o), destructorFunction: null }), di(t, c);
    }
    function pn(e, t) {
      var i = nr[e];
      return i === void 0 && Le(t + " has unknown type " + Ga(e)), i;
    }
    function hf(e, t, i) {
      var o = pn(e, "enum");
      t = et(t);
      var s = o.constructor, c = Object.create(o.constructor.prototype, { value: { value: i }, constructor: { value: un(`${o.name}_${t}`, function() {
      }) } });
      s.values[i] = c, s[t] = c;
    }
    function _i(e) {
      if (e === null)
        return "null";
      var t = typeof e;
      return t === "object" || t === "array" || t === "function" ? e.toString() : "" + e;
    }
    function pf(e, t) {
      switch (t) {
        case 2:
          return function(i) {
            return this.fromWireType(je[i >> 2]);
          };
        case 3:
          return function(i) {
            return this.fromWireType(De[i >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + e);
      }
    }
    function mf(e, t, i) {
      var o = rn(i);
      t = et(t), kt(e, { name: t, fromWireType: function(s) {
        return s;
      }, toWireType: function(s, c) {
        return c;
      }, argPackAdvance: 8, readValueFromPointer: pf(t, o), destructorFunction: null });
    }
    function _f(e, t, i, o, s, c, h) {
      var b = hn(t, i);
      e = et(e), s = _t(o, s), di(e, function() {
        ir(`Cannot call ${e} due to unbound types`, b);
      }, t - 1), It([], b, function(x) {
        var F = [x[0], null].concat(x.slice(1));
        return Wa(e, dn(e, F, null, s, c, h), t - 1), [];
      });
    }
    function bf(e, t, i) {
      switch (t) {
        case 0:
          return i ? function(s) {
            return Ee[s];
          } : function(s) {
            return de[s];
          };
        case 1:
          return i ? function(s) {
            return Re[s >> 1];
          } : function(s) {
            return ye[s >> 1];
          };
        case 2:
          return i ? function(s) {
            return I[s >> 2];
          } : function(s) {
            return X[s >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + e);
      }
    }
    function yf(e, t, i, o, s) {
      t = et(t);
      var c = rn(i), h = (P) => P;
      if (o === 0) {
        var b = 32 - 8 * i;
        h = (P) => P << b >>> b;
      }
      var x = t.includes("unsigned"), F;
      x ? F = function(P, W) {
        return W >>> 0;
      } : F = function(P, W) {
        return W;
      }, kt(e, { name: t, fromWireType: h, toWireType: F, argPackAdvance: 8, readValueFromPointer: bf(t, c, o !== 0), destructorFunction: null });
    }
    function gf(e, t, i) {
      var o = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], s = o[t];
      function c(h) {
        h = h >> 2;
        var b = X, x = b[h], F = b[h + 1];
        return new s(b.buffer, F, x);
      }
      i = et(i), kt(e, { name: i, fromWireType: c, argPackAdvance: 8, readValueFromPointer: c }, { ignoreDuplicateRegistrations: !0 });
    }
    function wf(e, t, i, o, s, c, h, b, x, F, P, W) {
      i = et(i), c = _t(s, c), b = _t(h, b), F = _t(x, F), W = _t(P, W), It([e], [t], function(U) {
        U = U[0];
        var G = new Dt(i, U.registeredClass, !1, !1, !0, U, o, c, b, F, W);
        return [G];
      });
    }
    function vf(e, t) {
      t = et(t);
      var i = t === "std::string";
      kt(e, { name: t, fromWireType: function(o) {
        var s = X[o >> 2], c = o + 4, h;
        if (i)
          for (var b = c, x = 0; x <= s; ++x) {
            var F = c + x;
            if (x == s || de[F] == 0) {
              var P = F - b, W = Xe(b, P);
              h === void 0 ? h = W : (h += String.fromCharCode(0), h += W), b = F + 1;
            }
          }
        else {
          for (var U = new Array(s), x = 0; x < s; ++x)
            U[x] = String.fromCharCode(de[c + x]);
          h = U.join("");
        }
        return Mt(o), h;
      }, toWireType: function(o, s) {
        s instanceof ArrayBuffer && (s = new Uint8Array(s));
        var c, h = typeof s == "string";
        h || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Int8Array || Le("Cannot pass non-string to std::string"), i && h ? c = at(s) : c = s.length;
        var b = Lt(4 + c + 1), x = b + 4;
        if (X[b >> 2] = c, i && h)
          ot(s, x, c + 1);
        else if (h)
          for (var F = 0; F < c; ++F) {
            var P = s.charCodeAt(F);
            P > 255 && (Mt(x), Le("String has UTF-16 code units that do not fit in 8 bits")), de[x + F] = P;
          }
        else
          for (var F = 0; F < c; ++F)
            de[x + F] = s[F];
        return o !== null && o.push(Mt, b), b;
      }, argPackAdvance: 8, readValueFromPointer: fn, destructorFunction: function(o) {
        Mt(o);
      } });
    }
    var Ha = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, Ef = (e, t) => {
      for (var i = e, o = i >> 1, s = o + t / 2; !(o >= s) && ye[o]; )
        ++o;
      if (i = o << 1, i - e > 32 && Ha)
        return Ha.decode(de.subarray(e, i));
      for (var c = "", h = 0; !(h >= t / 2); ++h) {
        var b = Re[e + h * 2 >> 1];
        if (b == 0)
          break;
        c += String.fromCharCode(b);
      }
      return c;
    }, xf = (e, t, i) => {
      if (i === void 0 && (i = 2147483647), i < 2)
        return 0;
      i -= 2;
      for (var o = t, s = i < e.length * 2 ? i / 2 : e.length, c = 0; c < s; ++c) {
        var h = e.charCodeAt(c);
        Re[t >> 1] = h, t += 2;
      }
      return Re[t >> 1] = 0, t - o;
    }, Sf = (e) => e.length * 2, Cf = (e, t) => {
      for (var i = 0, o = ""; !(i >= t / 4); ) {
        var s = I[e + i * 4 >> 2];
        if (s == 0)
          break;
        if (++i, s >= 65536) {
          var c = s - 65536;
          o += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else
          o += String.fromCharCode(s);
      }
      return o;
    }, Tf = (e, t, i) => {
      if (i === void 0 && (i = 2147483647), i < 4)
        return 0;
      for (var o = t, s = o + i - 4, c = 0; c < e.length; ++c) {
        var h = e.charCodeAt(c);
        if (h >= 55296 && h <= 57343) {
          var b = e.charCodeAt(++c);
          h = 65536 + ((h & 1023) << 10) | b & 1023;
        }
        if (I[t >> 2] = h, t += 4, t + 4 > s)
          break;
      }
      return I[t >> 2] = 0, t - o;
    }, Ff = (e) => {
      for (var t = 0, i = 0; i < e.length; ++i) {
        var o = e.charCodeAt(i);
        o >= 55296 && o <= 57343 && ++i, t += 4;
      }
      return t;
    }, Rf = function(e, t, i) {
      i = et(i);
      var o, s, c, h, b;
      t === 2 ? (o = Ef, s = xf, h = Sf, c = () => ye, b = 1) : t === 4 && (o = Cf, s = Tf, h = Ff, c = () => X, b = 2), kt(e, { name: i, fromWireType: function(x) {
        for (var F = X[x >> 2], P = c(), W, U = x + 4, G = 0; G <= F; ++G) {
          var re = x + 4 + G * t;
          if (G == F || P[re >> b] == 0) {
            var se = re - U, fe = o(U, se);
            W === void 0 ? W = fe : (W += String.fromCharCode(0), W += fe), U = re + t;
          }
        }
        return Mt(x), W;
      }, toWireType: function(x, F) {
        typeof F != "string" && Le(`Cannot pass non-string to C++ string type ${i}`);
        var P = h(F), W = Lt(4 + P + t);
        return X[W >> 2] = P >> b, s(F, W + 4, P + t), x !== null && x.push(Mt, W), W;
      }, argPackAdvance: 8, readValueFromPointer: fn, destructorFunction: function(x) {
        Mt(x);
      } });
    };
    function Af(e, t) {
      t = et(t), kt(e, { isVoid: !0, name: t, argPackAdvance: 0, fromWireType: function() {
      }, toWireType: function(i, o) {
      } });
    }
    function If(e) {
      if (nt.xhrs.has(e)) {
        var t = nt.xhrs.get(e);
        nt.xhrs.free(e), t.readyState > 0 && t.readyState < 4 && t.abort();
      }
    }
    var Pf = !0, kf = () => Pf;
    function Df(e, t, i) {
      e = He.toValue(e), t = pn(t, "emval::as");
      var o = [], s = He.toHandle(o);
      return X[i >> 2] = s, t.toWireType(o, e);
    }
    function Ka(e, t) {
      for (var i = new Array(e), o = 0; o < e; ++o)
        i[o] = pn(X[t + o * 4 >> 2], "parameter " + o);
      return i;
    }
    function Lf(e, t, i, o) {
      e = He.toValue(e);
      for (var s = Ka(t, i), c = new Array(t), h = 0; h < t; ++h) {
        var b = s[h];
        c[h] = b.readValueFromPointer(o), o += b.argPackAdvance;
      }
      var x = e.apply(void 0, c);
      return He.toHandle(x);
    }
    function Mf(e) {
      var t = [];
      return X[e >> 2] = He.toHandle(t), t;
    }
    var Bf = {};
    function mn(e) {
      var t = Bf[e];
      return t === void 0 ? et(e) : t;
    }
    var _n = [];
    function Nf(e, t, i, o, s) {
      return e = _n[e], t = He.toValue(t), i = mn(i), e(t, i, Mf(o), s);
    }
    function Of(e, t, i, o) {
      e = _n[e], t = He.toValue(t), i = mn(i), e(t, i, null, o);
    }
    function jf(e) {
      var t = _n.length;
      return _n.push(e), t;
    }
    var Ya = [];
    function Uf(e, t) {
      var i = Ka(e, t), o = i[0], s = o.name + "_$" + i.slice(1).map(function(re) {
        return re.name;
      }).join("_") + "$", c = Ya[s];
      if (c !== void 0)
        return c;
      for (var h = ["retType"], b = [o], x = "", F = 0; F < e - 1; ++F)
        x += (F !== 0 ? ", " : "") + "arg" + F, h.push("argType" + F), b.push(i[1 + F]);
      for (var P = sn("methodCaller_" + s), W = "return function " + P + `(handle, name, destructors, args) {
`, U = 0, F = 0; F < e - 1; ++F)
        W += "    var arg" + F + " = argType" + F + ".readValueFromPointer(args" + (U ? "+" + U : "") + `);
`, U += i[F + 1].argPackAdvance;
      W += "    var rv = handle[name](" + x + `);
`;
      for (var F = 0; F < e - 1; ++F)
        i[F + 1].deleteObject && (W += "    argType" + F + ".deleteObject(arg" + F + `);
`);
      o.isVoid || (W += `    return retType.toWireType(destructors, rv);
`), W += `};
`, h.push(W);
      var G = Va(Function, h).apply(null, b);
      return c = jf(G), Ya[s] = c, c;
    }
    function Wf(e) {
      return e = mn(e), He.toHandle(n[e]);
    }
    function $f(e, t) {
      return e = He.toValue(e), t = He.toValue(t), He.toHandle(e[t]);
    }
    function Gf(e) {
      e > 4 && (St.get(e).refcount += 1);
    }
    function Vf(e) {
      return e = He.toValue(e), typeof e == "number";
    }
    function zf(e) {
      return He.toHandle(mn(e));
    }
    function Hf(e) {
      var t = He.toValue(e);
      hi(t), mi(e);
    }
    function Kf(e, t, i) {
      e = He.toValue(e), t = He.toValue(t), i = He.toValue(i), e[t] = i;
    }
    function Yf(e, t) {
      e = pn(e, "_emval_take_value");
      var i = e.readValueFromPointer(t);
      return He.toHandle(i);
    }
    function Xf(e, t, i) {
      var o = br(e, t), s = new Date(o * 1e3);
      I[i >> 2] = s.getUTCSeconds(), I[i + 4 >> 2] = s.getUTCMinutes(), I[i + 8 >> 2] = s.getUTCHours(), I[i + 12 >> 2] = s.getUTCDate(), I[i + 16 >> 2] = s.getUTCMonth(), I[i + 20 >> 2] = s.getUTCFullYear() - 1900, I[i + 24 >> 2] = s.getUTCDay();
      var c = Date.UTC(s.getUTCFullYear(), 0, 1, 0, 0, 0, 0), h = (s.getTime() - c) / (1e3 * 60 * 60 * 24) | 0;
      I[i + 28 >> 2] = h;
    }
    var Nr = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), Zf = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], qf = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Xa = (e) => {
      var t = Nr(e.getFullYear()), i = t ? Zf : qf, o = i[e.getMonth()] + e.getDate() - 1;
      return o;
    };
    function Qf(e, t, i) {
      var o = br(e, t), s = new Date(o * 1e3);
      I[i >> 2] = s.getSeconds(), I[i + 4 >> 2] = s.getMinutes(), I[i + 8 >> 2] = s.getHours(), I[i + 12 >> 2] = s.getDate(), I[i + 16 >> 2] = s.getMonth(), I[i + 20 >> 2] = s.getFullYear() - 1900, I[i + 24 >> 2] = s.getDay();
      var c = Xa(s) | 0;
      I[i + 28 >> 2] = c, I[i + 36 >> 2] = -(s.getTimezoneOffset() * 60);
      var h = new Date(s.getFullYear(), 0, 1), b = new Date(s.getFullYear(), 6, 1).getTimezoneOffset(), x = h.getTimezoneOffset(), F = (b != x && s.getTimezoneOffset() == Math.min(x, b)) | 0;
      I[i + 32 >> 2] = F;
    }
    var Jf = function(e) {
      var t = (() => {
        var i = new Date(I[e + 20 >> 2] + 1900, I[e + 16 >> 2], I[e + 12 >> 2], I[e + 8 >> 2], I[e + 4 >> 2], I[e >> 2], 0), o = I[e + 32 >> 2], s = i.getTimezoneOffset(), c = new Date(i.getFullYear(), 0, 1), h = new Date(i.getFullYear(), 6, 1).getTimezoneOffset(), b = c.getTimezoneOffset(), x = Math.min(b, h);
        if (o < 0)
          I[e + 32 >> 2] = +(h != b && x == s);
        else if (o > 0 != (x == s)) {
          var F = Math.max(b, h), P = o > 0 ? x : F;
          i.setTime(i.getTime() + (P - s) * 6e4);
        }
        I[e + 24 >> 2] = i.getDay();
        var W = Xa(i) | 0;
        return I[e + 28 >> 2] = W, I[e >> 2] = i.getSeconds(), I[e + 4 >> 2] = i.getMinutes(), I[e + 8 >> 2] = i.getHours(), I[e + 12 >> 2] = i.getDate(), I[e + 16 >> 2] = i.getMonth(), I[e + 20 >> 2] = i.getYear(), i.getTime() / 1e3;
      })();
      return _o((N = t, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)), t >>> 0;
    };
    function ec(e, t, i, o, s, c, h, b) {
      var x = br(s, c);
      try {
        if (isNaN(x))
          return 61;
        var F = xe.getStreamFromFD(o), P = g.mmap(F, e, x, t, i), W = P.ptr;
        return I[h >> 2] = P.allocated, X[b >> 2] = W, 0;
      } catch (U) {
        if (typeof g > "u" || U.name !== "ErrnoError")
          throw U;
        return -U.errno;
      }
    }
    function tc(e, t, i, o, s, c, h) {
      var b = br(c, h);
      try {
        if (isNaN(b))
          return 61;
        var x = xe.getStreamFromFD(s);
        i & 2 && xe.doMsync(e, x, t, o, b), g.munmap(x);
      } catch (F) {
        if (typeof g > "u" || F.name !== "ErrnoError")
          throw F;
        return -F.errno;
      }
    }
    var wr = (e) => {
      var t = at(e) + 1, i = Lt(t);
      return i && ot(e, i, t), i;
    }, rc = (e, t, i) => {
      var o = (/* @__PURE__ */ new Date()).getFullYear(), s = new Date(o, 0, 1), c = new Date(o, 6, 1), h = s.getTimezoneOffset(), b = c.getTimezoneOffset(), x = Math.max(h, b);
      X[e >> 2] = x * 60, I[t >> 2] = +(h != b);
      function F(re) {
        var se = re.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return se ? se[1] : "GMT";
      }
      var P = F(s), W = F(c), U = wr(P), G = wr(W);
      b < h ? (X[i >> 2] = U, X[i + 4 >> 2] = G) : (X[i >> 2] = G, X[i + 4 >> 2] = U);
    }, nc = () => {
      qe("");
    };
    function bi(e, t) {
      if (z.mainLoop.timingMode = e, z.mainLoop.timingValue = t, !z.mainLoop.func)
        return 1;
      if (z.mainLoop.running || (z.mainLoop.running = !0), e == 0)
        z.mainLoop.scheduler = function() {
          var h = Math.max(0, z.mainLoop.tickStartTime + t - bn()) | 0;
          setTimeout(z.mainLoop.runner, h);
        }, z.mainLoop.method = "timeout";
      else if (e == 1)
        z.mainLoop.scheduler = function() {
          z.requestAnimationFrame(z.mainLoop.runner);
        }, z.mainLoop.method = "rAF";
      else if (e == 2) {
        if (typeof setImmediate > "u") {
          var i = [], o = "setimmediate", s = (c) => {
            (c.data === o || c.data.target === o) && (c.stopPropagation(), i.shift()());
          };
          addEventListener("message", s, !0), setImmediate = function(h) {
            i.push(h), postMessage(o, "*");
          };
        }
        z.mainLoop.scheduler = function() {
          setImmediate(z.mainLoop.runner);
        }, z.mainLoop.method = "immediate";
      }
      return 0;
    }
    var bn;
    bn = () => performance.now();
    function ic(e, t, i, o, s) {
      me(!z.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."), z.mainLoop.func = e, z.mainLoop.arg = o;
      var c = z.mainLoop.currentlyRunningMainloop;
      function h() {
        return !(c < z.mainLoop.currentlyRunningMainloop);
      }
      if (z.mainLoop.running = !1, z.mainLoop.runner = function() {
        if (!Te) {
          if (z.mainLoop.queue.length > 0) {
            var x = Date.now(), F = z.mainLoop.queue.shift();
            if (F.func(F.arg), z.mainLoop.remainingBlockers) {
              var P = z.mainLoop.remainingBlockers, W = P % 1 == 0 ? P - 1 : Math.floor(P);
              F.counted ? z.mainLoop.remainingBlockers = W : (W = W + 0.5, z.mainLoop.remainingBlockers = (8 * P + W) / 9);
            }
            if (K('main loop blocker "' + F.name + '" took ' + (Date.now() - x) + " ms"), z.mainLoop.updateStatus(), !h())
              return;
            setTimeout(z.mainLoop.runner, 0);
            return;
          }
          if (h()) {
            if (z.mainLoop.currentFrameNumber = z.mainLoop.currentFrameNumber + 1 | 0, z.mainLoop.timingMode == 1 && z.mainLoop.timingValue > 1 && z.mainLoop.currentFrameNumber % z.mainLoop.timingValue != 0) {
              z.mainLoop.scheduler();
              return;
            } else
              z.mainLoop.timingMode == 0 && (z.mainLoop.tickStartTime = bn());
            z.mainLoop.runIter(e), h() && (typeof SDL == "object" && SDL.audio && SDL.audio.queueNewAudioData && SDL.audio.queueNewAudioData(), z.mainLoop.scheduler());
          }
        }
      }, s || (t && t > 0 ? bi(0, 1e3 / t) : bi(1, 1), z.mainLoop.scheduler()), i)
        throw "unwind";
    }
    var Za = (e) => {
      if (e instanceof k || e == "unwind")
        return Oe;
      m(1, e);
    }, ac = (e) => {
      Oe = e, ie() || (n.onExit && n.onExit(e), Te = !0), m(e, new k(e));
    }, oc = (e, t) => {
      Oe = e, ac(e);
    }, qa = oc, sc = () => {
      if (!ie())
        try {
          qa(Oe);
        } catch (e) {
          Za(e);
        }
    }, yn = (e) => {
      if (!Te)
        try {
          e(), sc();
        } catch (t) {
          Za(t);
        }
    }, Qa = (e, t) => setTimeout(() => {
      yn(e);
    }, t), z = { mainLoop: { running: !1, scheduler: null, method: "", currentlyRunningMainloop: 0, func: null, arg: 0, timingMode: 0, timingValue: 0, currentFrameNumber: 0, queue: [], pause: function() {
      z.mainLoop.scheduler = null, z.mainLoop.currentlyRunningMainloop++;
    }, resume: function() {
      z.mainLoop.currentlyRunningMainloop++;
      var e = z.mainLoop.timingMode, t = z.mainLoop.timingValue, i = z.mainLoop.func;
      z.mainLoop.func = null, ic(i, 0, !1, z.mainLoop.arg, !0), bi(e, t), z.mainLoop.scheduler();
    }, updateStatus: function() {
      if (n.setStatus) {
        var e = n.statusMessage || "Please wait...", t = z.mainLoop.remainingBlockers, i = z.mainLoop.expectedBlockers;
        t ? t < i ? n.setStatus(e + " (" + (i - t) + "/" + i + ")") : n.setStatus(e) : n.setStatus("");
      }
    }, runIter: function(e) {
      if (!Te) {
        if (n.preMainLoop) {
          var t = n.preMainLoop();
          if (t === !1)
            return;
        }
        yn(e), n.postMainLoop && n.postMainLoop();
      }
    } }, isFullscreen: !1, pointerLock: !1, moduleContextCreatedCallbacks: [], workers: [], init: function() {
      if (z.initted)
        return;
      z.initted = !0;
      var e = {};
      e.canHandle = function(c) {
        return !n.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(c);
      }, e.handle = function(c, h, b, x) {
        var F = new Blob([c], { type: z.getMimetype(h) });
        F.size !== c.length && (F = new Blob([new Uint8Array(c).buffer], { type: z.getMimetype(h) }));
        var P = URL.createObjectURL(F), W = new Image();
        W.onload = () => {
          me(W.complete, "Image " + h + " could not be decoded");
          var U = document.createElement("canvas");
          U.width = W.width, U.height = W.height;
          var G = U.getContext("2d");
          G.drawImage(W, 0, 0), URL.revokeObjectURL(P), b && b(c);
        }, W.onerror = (U) => {
          K("Image " + P + " could not be decoded"), x && x();
        }, W.src = P;
      }, oi.push(e);
      var t = {};
      t.canHandle = function(c) {
        return !n.noAudioDecoding && c.substr(-4) in { ".ogg": 1, ".wav": 1, ".mp3": 1 };
      }, t.handle = function(c, h, b, x) {
        var F = !1;
        function P(re) {
          F || (F = !0, b && b(c));
        }
        var W = new Blob([c], { type: z.getMimetype(h) }), U = URL.createObjectURL(W), G = new Audio();
        G.addEventListener("canplaythrough", () => P(), !1), G.onerror = function(se) {
          if (F)
            return;
          pe("warning: browser could not fully decode audio " + h + ", trying slower base64 approach");
          function fe(be) {
            for (var H = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ne = "=", ve = "", Se = 0, ue = 0, Pe = 0; Pe < be.length; Pe++)
              for (Se = Se << 8 | be[Pe], ue += 8; ue >= 6; ) {
                var ct = Se >> ue - 6 & 63;
                ue -= 6, ve += H[ct];
              }
            return ue == 2 ? (ve += H[(Se & 3) << 4], ve += ne + ne) : ue == 4 && (ve += H[(Se & 15) << 2], ve += ne), ve;
          }
          G.src = "data:audio/x-" + h.substr(-3) + ";base64," + fe(c), P();
        }, G.src = U, Qa(() => {
          P();
        }, 1e4);
      }, oi.push(t);
      function i() {
        z.pointerLock = document.pointerLockElement === n.canvas || document.mozPointerLockElement === n.canvas || document.webkitPointerLockElement === n.canvas || document.msPointerLockElement === n.canvas;
      }
      var o = n.canvas;
      o && (o.requestPointerLock = o.requestPointerLock || o.mozRequestPointerLock || o.webkitRequestPointerLock || o.msRequestPointerLock || (() => {
      }), o.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock || document.msExitPointerLock || (() => {
      }), o.exitPointerLock = o.exitPointerLock.bind(document), document.addEventListener("pointerlockchange", i, !1), document.addEventListener("mozpointerlockchange", i, !1), document.addEventListener("webkitpointerlockchange", i, !1), document.addEventListener("mspointerlockchange", i, !1), n.elementPointerLock && o.addEventListener("click", (s) => {
        !z.pointerLock && n.canvas.requestPointerLock && (n.canvas.requestPointerLock(), s.preventDefault());
      }, !1));
    }, createContext: function(e, t, i, o) {
      if (t && n.ctx && e == n.canvas)
        return n.ctx;
      var s, c;
      if (t) {
        var h = { antialias: !1, alpha: !1, majorVersion: typeof WebGL2RenderingContext < "u" ? 2 : 1 };
        if (o)
          for (var b in o)
            h[b] = o[b];
        typeof te < "u" && (c = te.createContext(e, h), c && (s = te.getContext(c).GLctx));
      } else
        s = e.getContext("2d");
      return s ? (i && (t || me(typeof Z > "u", "cannot set in module if GLctx is used, but we are a non-GL context that would replace it"), n.ctx = s, t && te.makeContextCurrent(c), n.useWebGL = t, z.moduleContextCreatedCallbacks.forEach((x) => x()), z.init()), s) : null;
    }, destroyContext: function(e, t, i) {
    }, fullscreenHandlersInstalled: !1, lockPointer: void 0, resizeCanvas: void 0, requestFullscreen: function(e, t) {
      z.lockPointer = e, z.resizeCanvas = t, typeof z.lockPointer > "u" && (z.lockPointer = !0), typeof z.resizeCanvas > "u" && (z.resizeCanvas = !1);
      var i = n.canvas;
      function o() {
        z.isFullscreen = !1;
        var c = i.parentNode;
        (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === c ? (i.exitFullscreen = z.exitFullscreen, z.lockPointer && i.requestPointerLock(), z.isFullscreen = !0, z.resizeCanvas ? z.setFullscreenCanvasSize() : z.updateCanvasDimensions(i)) : (c.parentNode.insertBefore(i, c), c.parentNode.removeChild(c), z.resizeCanvas ? z.setWindowedCanvasSize() : z.updateCanvasDimensions(i)), n.onFullScreen && n.onFullScreen(z.isFullscreen), n.onFullscreen && n.onFullscreen(z.isFullscreen);
      }
      z.fullscreenHandlersInstalled || (z.fullscreenHandlersInstalled = !0, document.addEventListener("fullscreenchange", o, !1), document.addEventListener("mozfullscreenchange", o, !1), document.addEventListener("webkitfullscreenchange", o, !1), document.addEventListener("MSFullscreenChange", o, !1));
      var s = document.createElement("div");
      i.parentNode.insertBefore(s, i), s.appendChild(i), s.requestFullscreen = s.requestFullscreen || s.mozRequestFullScreen || s.msRequestFullscreen || (s.webkitRequestFullscreen ? () => s.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : null) || (s.webkitRequestFullScreen ? () => s.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT) : null), s.requestFullscreen();
    }, exitFullscreen: function() {
      if (!z.isFullscreen)
        return !1;
      var e = document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen || document.webkitCancelFullScreen || (() => {
      });
      return e.apply(document, []), !0;
    }, nextRAF: 0, fakeRequestAnimationFrame: function(e) {
      var t = Date.now();
      if (z.nextRAF === 0)
        z.nextRAF = t + 1e3 / 60;
      else
        for (; t + 2 >= z.nextRAF; )
          z.nextRAF += 1e3 / 60;
      var i = Math.max(z.nextRAF - t, 0);
      setTimeout(e, i);
    }, requestAnimationFrame: function(e) {
      if (typeof requestAnimationFrame == "function") {
        requestAnimationFrame(e);
        return;
      }
      var t = z.fakeRequestAnimationFrame;
      t(e);
    }, safeSetTimeout: function(e, t) {
      return Qa(e, t);
    }, safeRequestAnimationFrame: function(e) {
      return z.requestAnimationFrame(() => {
        yn(e);
      });
    }, getMimetype: function(e) {
      return { jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", bmp: "image/bmp", ogg: "audio/ogg", wav: "audio/wav", mp3: "audio/mpeg" }[e.substr(e.lastIndexOf(".") + 1)];
    }, getUserMedia: function(e) {
      window.getUserMedia || (window.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia), window.getUserMedia(e);
    }, getMovementX: function(e) {
      return e.movementX || e.mozMovementX || e.webkitMovementX || 0;
    }, getMovementY: function(e) {
      return e.movementY || e.mozMovementY || e.webkitMovementY || 0;
    }, getMouseWheelDelta: function(e) {
      var t = 0;
      switch (e.type) {
        case "DOMMouseScroll":
          t = e.detail / 3;
          break;
        case "mousewheel":
          t = e.wheelDelta / 120;
          break;
        case "wheel":
          switch (t = e.deltaY, e.deltaMode) {
            case 0:
              t /= 100;
              break;
            case 1:
              t /= 3;
              break;
            case 2:
              t *= 80;
              break;
            default:
              throw "unrecognized mouse wheel delta mode: " + e.deltaMode;
          }
          break;
        default:
          throw "unrecognized mouse wheel event: " + e.type;
      }
      return t;
    }, mouseX: 0, mouseY: 0, mouseMovementX: 0, mouseMovementY: 0, touches: {}, lastTouches: {}, calculateMouseEvent: function(e) {
      if (z.pointerLock)
        e.type != "mousemove" && "mozMovementX" in e ? z.mouseMovementX = z.mouseMovementY = 0 : (z.mouseMovementX = z.getMovementX(e), z.mouseMovementY = z.getMovementY(e)), typeof SDL < "u" ? (z.mouseX = SDL.mouseX + z.mouseMovementX, z.mouseY = SDL.mouseY + z.mouseMovementY) : (z.mouseX += z.mouseMovementX, z.mouseY += z.mouseMovementY);
      else {
        var t = n.canvas.getBoundingClientRect(), i = n.canvas.width, o = n.canvas.height, s = typeof window.scrollX < "u" ? window.scrollX : window.pageXOffset, c = typeof window.scrollY < "u" ? window.scrollY : window.pageYOffset;
        if (e.type === "touchstart" || e.type === "touchend" || e.type === "touchmove") {
          var h = e.touch;
          if (h === void 0)
            return;
          var b = h.pageX - (s + t.left), x = h.pageY - (c + t.top);
          b = b * (i / t.width), x = x * (o / t.height);
          var F = { x: b, y: x };
          if (e.type === "touchstart")
            z.lastTouches[h.identifier] = F, z.touches[h.identifier] = F;
          else if (e.type === "touchend" || e.type === "touchmove") {
            var P = z.touches[h.identifier];
            P || (P = F), z.lastTouches[h.identifier] = P, z.touches[h.identifier] = F;
          }
          return;
        }
        var W = e.pageX - (s + t.left), U = e.pageY - (c + t.top);
        W = W * (i / t.width), U = U * (o / t.height), z.mouseMovementX = W - z.mouseX, z.mouseMovementY = U - z.mouseY, z.mouseX = W, z.mouseY = U;
      }
    }, resizeListeners: [], updateResizeListeners: function() {
      var e = n.canvas;
      z.resizeListeners.forEach((t) => t(e.width, e.height));
    }, setCanvasSize: function(e, t, i) {
      var o = n.canvas;
      z.updateCanvasDimensions(o, e, t), i || z.updateResizeListeners();
    }, windowedWidth: 0, windowedHeight: 0, setFullscreenCanvasSize: function() {
      if (typeof SDL < "u") {
        var e = X[SDL.screen >> 2];
        e = e | 8388608, I[SDL.screen >> 2] = e;
      }
      z.updateCanvasDimensions(n.canvas), z.updateResizeListeners();
    }, setWindowedCanvasSize: function() {
      if (typeof SDL < "u") {
        var e = X[SDL.screen >> 2];
        e = e & -8388609, I[SDL.screen >> 2] = e;
      }
      z.updateCanvasDimensions(n.canvas), z.updateResizeListeners();
    }, updateCanvasDimensions: function(e, t, i) {
      t && i ? (e.widthNative = t, e.heightNative = i) : (t = e.widthNative, i = e.heightNative);
      var o = t, s = i;
      if (n.forcedAspectRatio && n.forcedAspectRatio > 0 && (o / s < n.forcedAspectRatio ? o = Math.round(s * n.forcedAspectRatio) : s = Math.round(o / n.forcedAspectRatio)), (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === e.parentNode && typeof screen < "u") {
        var c = Math.min(screen.width / o, screen.height / s);
        o = Math.round(o * c), s = Math.round(s * c);
      }
      z.resizeCanvas ? (e.width != o && (e.width = o), e.height != s && (e.height = s), typeof e.style < "u" && (e.style.removeProperty("width"), e.style.removeProperty("height"))) : (e.width != t && (e.width = t), e.height != i && (e.height = i), typeof e.style < "u" && (o != t || s != i ? (e.style.setProperty("width", o + "px", "important"), e.style.setProperty("height", s + "px", "important")) : (e.style.removeProperty("width"), e.style.removeProperty("height"))));
    } }, A = { QUEUE_INTERVAL: 25, QUEUE_LOOKAHEAD: 0.1, DEVICE_NAME: "Emscripten OpenAL", CAPTURE_DEVICE_NAME: "Emscripten OpenAL capture", ALC_EXTENSIONS: { ALC_SOFT_pause_device: !0, ALC_SOFT_HRTF: !0 }, AL_EXTENSIONS: { AL_EXT_float32: !0, AL_SOFT_loop_points: !0, AL_SOFT_source_length: !0, AL_EXT_source_distance_model: !0, AL_SOFT_source_spatialize: !0 }, _alcErr: 0, alcErr: 0, deviceRefCounts: {}, alcStringCache: {}, paused: !1, stringCache: {}, contexts: {}, currentCtx: null, buffers: { 0: { id: 0, refCount: 0, audioBuf: null, frequency: 0, bytesPerSample: 2, channels: 1, length: 0 } }, paramArray: [], _nextId: 1, newId: function() {
      return A.freeIds.length > 0 ? A.freeIds.pop() : A._nextId++;
    }, freeIds: [], scheduleContextAudio: function(e) {
      if (!(z.mainLoop.timingMode === 1 && document.visibilityState != "visible"))
        for (var t in e.sources)
          A.scheduleSourceAudio(e.sources[t]);
    }, scheduleSourceAudio: function(e, t) {
      if (!(z.mainLoop.timingMode === 1 && document.visibilityState != "visible") && e.state === 4114) {
        for (var i = A.updateSourceTime(e), o = e.bufStartTime, s = e.bufOffset, c = e.bufsProcessed, h = 0; h < e.audioQueue.length; h++) {
          var b = e.audioQueue[h];
          o = b._startTime + b._duration, s = 0, c += b._skipCount + 1;
        }
        t || (t = A.QUEUE_LOOKAHEAD);
        for (var x = i + t, F = 0; o < x; ) {
          if (c >= e.bufQueue.length)
            if (e.looping)
              c %= e.bufQueue.length;
            else
              break;
          var P = e.bufQueue[c % e.bufQueue.length];
          if (P.length === 0) {
            if (F++, F === e.bufQueue.length)
              break;
          } else {
            var b = e.context.audioCtx.createBufferSource();
            b.buffer = P.audioBuf, b.playbackRate.value = e.playbackRate, (P.audioBuf._loopStart || P.audioBuf._loopEnd) && (b.loopStart = P.audioBuf._loopStart, b.loopEnd = P.audioBuf._loopEnd);
            var W = 0;
            e.type === 4136 && e.looping ? (W = Number.POSITIVE_INFINITY, b.loop = !0, P.audioBuf._loopStart && (b.loopStart = P.audioBuf._loopStart), P.audioBuf._loopEnd && (b.loopEnd = P.audioBuf._loopEnd)) : W = (P.audioBuf.duration - s) / e.playbackRate, b._startOffset = s, b._duration = W, b._skipCount = F, F = 0, b.connect(e.gain), typeof b.start < "u" ? (o = Math.max(o, e.context.audioCtx.currentTime), b.start(o, s)) : typeof b.noteOn < "u" && (o = Math.max(o, e.context.audioCtx.currentTime), b.noteOn(o)), b._startTime = o, e.audioQueue.push(b), o += W;
          }
          s = 0, c++;
        }
      }
    }, updateSourceTime: function(e) {
      var t = e.context.audioCtx.currentTime;
      if (e.state !== 4114)
        return t;
      isFinite(e.bufStartTime) || (e.bufStartTime = t - e.bufOffset / e.playbackRate, e.bufOffset = 0);
      for (var i = 0; e.audioQueue.length; ) {
        var o = e.audioQueue[0];
        if (e.bufsProcessed += o._skipCount, i = o._startTime + o._duration, t < i)
          break;
        e.audioQueue.shift(), e.bufStartTime = i, e.bufOffset = 0, e.bufsProcessed++;
      }
      if (e.bufsProcessed >= e.bufQueue.length && !e.looping)
        A.setSourceState(e, 4116);
      else if (e.type === 4136 && e.looping) {
        var s = e.bufQueue[0];
        if (s.length === 0)
          e.bufOffset = 0;
        else {
          var c = (t - e.bufStartTime) * e.playbackRate, h = s.audioBuf._loopStart || 0, b = s.audioBuf._loopEnd || s.audioBuf.duration;
          b <= h && (b = s.audioBuf.duration), c < b ? e.bufOffset = c : e.bufOffset = h + (c - h) % (b - h);
        }
      } else if (e.audioQueue[0])
        e.bufOffset = (t - e.audioQueue[0]._startTime) * e.playbackRate;
      else {
        if (e.type !== 4136 && e.looping) {
          var x = A.sourceDuration(e) / e.playbackRate;
          x > 0 && (e.bufStartTime += Math.floor((t - e.bufStartTime) / x) * x);
        }
        for (var F = 0; F < e.bufQueue.length; F++) {
          if (e.bufsProcessed >= e.bufQueue.length)
            if (e.looping)
              e.bufsProcessed %= e.bufQueue.length;
            else {
              A.setSourceState(e, 4116);
              break;
            }
          var s = e.bufQueue[e.bufsProcessed];
          if (s.length > 0) {
            if (i = e.bufStartTime + s.audioBuf.duration / e.playbackRate, t < i) {
              e.bufOffset = (t - e.bufStartTime) * e.playbackRate;
              break;
            }
            e.bufStartTime = i;
          }
          e.bufOffset = 0, e.bufsProcessed++;
        }
      }
      return t;
    }, cancelPendingSourceAudio: function(e) {
      A.updateSourceTime(e);
      for (var t = 1; t < e.audioQueue.length; t++) {
        var i = e.audioQueue[t];
        i.stop();
      }
      e.audioQueue.length > 1 && (e.audioQueue.length = 1);
    }, stopSourceAudio: function(e) {
      for (var t = 0; t < e.audioQueue.length; t++)
        e.audioQueue[t].stop();
      e.audioQueue.length = 0;
    }, setSourceState: function(e, t) {
      t === 4114 ? ((e.state === 4114 || e.state == 4116) && (e.bufsProcessed = 0, e.bufOffset = 0), A.stopSourceAudio(e), e.state = 4114, e.bufStartTime = Number.NEGATIVE_INFINITY, A.scheduleSourceAudio(e)) : t === 4115 ? e.state === 4114 && (A.updateSourceTime(e), A.stopSourceAudio(e), e.state = 4115) : t === 4116 ? e.state !== 4113 && (e.state = 4116, e.bufsProcessed = e.bufQueue.length, e.bufStartTime = Number.NEGATIVE_INFINITY, e.bufOffset = 0, A.stopSourceAudio(e)) : t === 4113 && e.state !== 4113 && (e.state = 4113, e.bufsProcessed = 0, e.bufStartTime = Number.NEGATIVE_INFINITY, e.bufOffset = 0, A.stopSourceAudio(e));
    }, initSourcePanner: function(e) {
      if (e.type !== 4144) {
        for (var t = A.buffers[0], i = 0; i < e.bufQueue.length; i++)
          if (e.bufQueue[i].id !== 0) {
            t = e.bufQueue[i];
            break;
          }
        if (e.spatialize === 1 || e.spatialize === 2 && t.channels === 1) {
          if (e.panner)
            return;
          e.panner = e.context.audioCtx.createPanner(), A.updateSourceGlobal(e), A.updateSourceSpace(e), e.panner.connect(e.context.gain), e.gain.disconnect(), e.gain.connect(e.panner);
        } else {
          if (!e.panner)
            return;
          e.panner.disconnect(), e.gain.disconnect(), e.gain.connect(e.context.gain), e.panner = null;
        }
      }
    }, updateContextGlobal: function(e) {
      for (var t in e.sources)
        A.updateSourceGlobal(e.sources[t]);
    }, updateSourceGlobal: function(e) {
      var t = e.panner;
      if (t) {
        t.refDistance = e.refDistance, t.maxDistance = e.maxDistance, t.rolloffFactor = e.rolloffFactor, t.panningModel = e.context.hrtf ? "HRTF" : "equalpower";
        var i = e.context.sourceDistanceModel ? e.distanceModel : e.context.distanceModel;
        switch (i) {
          case 0:
            t.distanceModel = "inverse", t.refDistance = 340282e33;
            break;
          case 53249:
          case 53250:
            t.distanceModel = "inverse";
            break;
          case 53251:
          case 53252:
            t.distanceModel = "linear";
            break;
          case 53253:
          case 53254:
            t.distanceModel = "exponential";
            break;
        }
      }
    }, updateListenerSpace: function(e) {
      var t = e.audioCtx.listener;
      t.positionX ? (t.positionX.value = e.listener.position[0], t.positionY.value = e.listener.position[1], t.positionZ.value = e.listener.position[2]) : t.setPosition(e.listener.position[0], e.listener.position[1], e.listener.position[2]), t.forwardX ? (t.forwardX.value = e.listener.direction[0], t.forwardY.value = e.listener.direction[1], t.forwardZ.value = e.listener.direction[2], t.upX.value = e.listener.up[0], t.upY.value = e.listener.up[1], t.upZ.value = e.listener.up[2]) : t.setOrientation(e.listener.direction[0], e.listener.direction[1], e.listener.direction[2], e.listener.up[0], e.listener.up[1], e.listener.up[2]);
      for (var i in e.sources)
        A.updateSourceSpace(e.sources[i]);
    }, updateSourceSpace: function(e) {
      if (e.panner) {
        var t = e.panner, i = e.position[0], o = e.position[1], s = e.position[2], c = e.direction[0], h = e.direction[1], b = e.direction[2], x = e.context.listener, F = x.position[0], P = x.position[1], W = x.position[2];
        if (e.relative) {
          var U = -x.direction[0], G = -x.direction[1], re = -x.direction[2], se = x.up[0], fe = x.up[1], be = x.up[2], H = (wo, vo, Eo) => {
            var xo = Math.sqrt(wo * wo + vo * vo + Eo * Eo);
            return xo < Number.EPSILON ? 0 : 1 / xo;
          }, ne = H(U, G, re);
          U *= ne, G *= ne, re *= ne, ne = H(se, fe, be), se *= ne, fe *= ne, be *= ne;
          var ve = fe * re - be * G, Se = be * U - se * re, ue = se * G - fe * U;
          ne = H(ve, Se, ue), ve *= ne, Se *= ne, ue *= ne, se = G * ue - re * Se, fe = re * ve - U * ue, be = U * Se - G * ve;
          var Pe = c, ct = h, Ct = b;
          c = Pe * ve + ct * se + Ct * U, h = Pe * Se + ct * fe + Ct * G, b = Pe * ue + ct * be + Ct * re, Pe = i, ct = o, Ct = s, i = Pe * ve + ct * se + Ct * U, o = Pe * Se + ct * fe + Ct * G, s = Pe * ue + ct * be + Ct * re, i += F, o += P, s += W;
        }
        t.positionX ? (i != t.positionX.value && (t.positionX.value = i), o != t.positionY.value && (t.positionY.value = o), s != t.positionZ.value && (t.positionZ.value = s)) : t.setPosition(i, o, s), t.orientationX ? (c != t.orientationX.value && (t.orientationX.value = c), h != t.orientationY.value && (t.orientationY.value = h), b != t.orientationZ.value && (t.orientationZ.value = b)) : t.setOrientation(c, h, b);
        var Ke = e.dopplerShift, Tt = e.velocity[0], ut = e.velocity[1], xr = e.velocity[2], ar = x.velocity[0], Ue = x.velocity[1], bt = x.velocity[2];
        if (i === F && o === P && s === W || Tt === ar && ut === Ue && xr === bt)
          e.dopplerShift = 1;
        else {
          var dt = e.context.speedOfSound, Cn = e.context.dopplerFactor, Tn = F - i, Fn = P - o, Rn = W - s, go = Math.sqrt(Tn * Tn + Fn * Fn + Rn * Rn), Si = (Tn * ar + Fn * Ue + Rn * bt) / go, Ci = (Tn * Tt + Fn * ut + Rn * xr) / go;
          Si = Math.min(Si, dt / Cn), Ci = Math.min(Ci, dt / Cn), e.dopplerShift = (dt - Cn * Si) / (dt - Cn * Ci);
        }
        e.dopplerShift !== Ke && A.updateSourceRate(e);
      }
    }, updateSourceRate: function(e) {
      if (e.state === 4114) {
        A.cancelPendingSourceAudio(e);
        var t = e.audioQueue[0];
        if (!t)
          return;
        var i;
        e.type === 4136 && e.looping ? i = Number.POSITIVE_INFINITY : i = (t.buffer.duration - t._startOffset) / e.playbackRate, t._duration = i, t.playbackRate.value = e.playbackRate, A.scheduleSourceAudio(e);
      }
    }, sourceDuration: function(e) {
      for (var t = 0, i = 0; i < e.bufQueue.length; i++) {
        var o = e.bufQueue[i].audioBuf;
        t += o ? o.duration : 0;
      }
      return t;
    }, sourceTell: function(e) {
      A.updateSourceTime(e);
      for (var t = 0, i = 0; i < e.bufsProcessed; i++)
        e.bufQueue[i].audioBuf && (t += e.bufQueue[i].audioBuf.duration);
      return t += e.bufOffset, t;
    }, sourceSeek: function(e, t) {
      var i = e.state == 4114;
      if (i && A.setSourceState(e, 4113), e.bufQueue[e.bufsProcessed].audioBuf !== null) {
        for (e.bufsProcessed = 0; t > e.bufQueue[e.bufsProcessed].audioBuf.duration; )
          t -= e.bufQueue[e.bufsProcessed].audiobuf.duration, e.bufsProcessed++;
        e.bufOffset = t;
      }
      i && A.setSourceState(e, 4114);
    }, getGlobalParam: function(e, t) {
      if (!A.currentCtx)
        return null;
      switch (t) {
        case 49152:
          return A.currentCtx.dopplerFactor;
        case 49155:
          return A.currentCtx.speedOfSound;
        case 53248:
          return A.currentCtx.distanceModel;
        default:
          return A.currentCtx.err = 40962, null;
      }
    }, setGlobalParam: function(e, t, i) {
      if (A.currentCtx)
        switch (t) {
          case 49152:
            if (!Number.isFinite(i) || i < 0) {
              A.currentCtx.err = 40963;
              return;
            }
            A.currentCtx.dopplerFactor = i, A.updateListenerSpace(A.currentCtx);
            break;
          case 49155:
            if (!Number.isFinite(i) || i <= 0) {
              A.currentCtx.err = 40963;
              return;
            }
            A.currentCtx.speedOfSound = i, A.updateListenerSpace(A.currentCtx);
            break;
          case 53248:
            switch (i) {
              case 0:
              case 53249:
              case 53250:
              case 53251:
              case 53252:
              case 53253:
              case 53254:
                A.currentCtx.distanceModel = i, A.updateContextGlobal(A.currentCtx);
                break;
              default:
                A.currentCtx.err = 40963;
                return;
            }
            break;
          default:
            A.currentCtx.err = 40962;
            return;
        }
    }, getListenerParam: function(e, t) {
      if (!A.currentCtx)
        return null;
      switch (t) {
        case 4100:
          return A.currentCtx.listener.position;
        case 4102:
          return A.currentCtx.listener.velocity;
        case 4111:
          return A.currentCtx.listener.direction.concat(A.currentCtx.listener.up);
        case 4106:
          return A.currentCtx.gain.gain.value;
        default:
          return A.currentCtx.err = 40962, null;
      }
    }, setListenerParam: function(e, t, i) {
      if (A.currentCtx) {
        if (i === null) {
          A.currentCtx.err = 40962;
          return;
        }
        var o = A.currentCtx.listener;
        switch (t) {
          case 4100:
            if (!Number.isFinite(i[0]) || !Number.isFinite(i[1]) || !Number.isFinite(i[2])) {
              A.currentCtx.err = 40963;
              return;
            }
            o.position[0] = i[0], o.position[1] = i[1], o.position[2] = i[2], A.updateListenerSpace(A.currentCtx);
            break;
          case 4102:
            if (!Number.isFinite(i[0]) || !Number.isFinite(i[1]) || !Number.isFinite(i[2])) {
              A.currentCtx.err = 40963;
              return;
            }
            o.velocity[0] = i[0], o.velocity[1] = i[1], o.velocity[2] = i[2], A.updateListenerSpace(A.currentCtx);
            break;
          case 4106:
            if (!Number.isFinite(i) || i < 0) {
              A.currentCtx.err = 40963;
              return;
            }
            A.currentCtx.gain.gain.value = i;
            break;
          case 4111:
            if (!Number.isFinite(i[0]) || !Number.isFinite(i[1]) || !Number.isFinite(i[2]) || !Number.isFinite(i[3]) || !Number.isFinite(i[4]) || !Number.isFinite(i[5])) {
              A.currentCtx.err = 40963;
              return;
            }
            o.direction[0] = i[0], o.direction[1] = i[1], o.direction[2] = i[2], o.up[0] = i[3], o.up[1] = i[4], o.up[2] = i[5], A.updateListenerSpace(A.currentCtx);
            break;
          default:
            A.currentCtx.err = 40962;
            return;
        }
      }
    }, getBufferParam: function(e, t, i) {
      if (A.currentCtx) {
        var o = A.buffers[t];
        if (!o || t === 0) {
          A.currentCtx.err = 40961;
          return;
        }
        switch (i) {
          case 8193:
            return o.frequency;
          case 8194:
            return o.bytesPerSample * 8;
          case 8195:
            return o.channels;
          case 8196:
            return o.length * o.bytesPerSample * o.channels;
          case 8213:
            return o.length === 0 ? [0, 0] : [(o.audioBuf._loopStart || 0) * o.frequency, (o.audioBuf._loopEnd || o.length) * o.frequency];
          default:
            return A.currentCtx.err = 40962, null;
        }
      }
    }, setBufferParam: function(e, t, i, o) {
      if (A.currentCtx) {
        var s = A.buffers[t];
        if (!s || t === 0) {
          A.currentCtx.err = 40961;
          return;
        }
        if (o === null) {
          A.currentCtx.err = 40962;
          return;
        }
        switch (i) {
          case 8196:
            if (o !== 0) {
              A.currentCtx.err = 40963;
              return;
            }
            break;
          case 8213:
            if (o[0] < 0 || o[0] > s.length || o[1] < 0 || o[1] > s.Length || o[0] >= o[1]) {
              A.currentCtx.err = 40963;
              return;
            }
            if (s.refCount > 0) {
              A.currentCtx.err = 40964;
              return;
            }
            s.audioBuf && (s.audioBuf._loopStart = o[0] / s.frequency, s.audioBuf._loopEnd = o[1] / s.frequency);
            break;
          default:
            A.currentCtx.err = 40962;
            return;
        }
      }
    }, getSourceParam: function(e, t, i) {
      if (!A.currentCtx)
        return null;
      var o = A.currentCtx.sources[t];
      if (!o)
        return A.currentCtx.err = 40961, null;
      switch (i) {
        case 514:
          return o.relative;
        case 4097:
          return o.coneInnerAngle;
        case 4098:
          return o.coneOuterAngle;
        case 4099:
          return o.pitch;
        case 4100:
          return o.position;
        case 4101:
          return o.direction;
        case 4102:
          return o.velocity;
        case 4103:
          return o.looping;
        case 4105:
          return o.type === 4136 ? o.bufQueue[0].id : 0;
        case 4106:
          return o.gain.gain.value;
        case 4109:
          return o.minGain;
        case 4110:
          return o.maxGain;
        case 4112:
          return o.state;
        case 4117:
          return o.bufQueue.length === 1 && o.bufQueue[0].id === 0 ? 0 : o.bufQueue.length;
        case 4118:
          return o.bufQueue.length === 1 && o.bufQueue[0].id === 0 || o.looping ? 0 : o.bufsProcessed;
        case 4128:
          return o.refDistance;
        case 4129:
          return o.rolloffFactor;
        case 4130:
          return o.coneOuterGain;
        case 4131:
          return o.maxDistance;
        case 4132:
          return A.sourceTell(o);
        case 4133:
          var s = A.sourceTell(o);
          return s > 0 && (s *= o.bufQueue[0].frequency), s;
        case 4134:
          var s = A.sourceTell(o);
          return s > 0 && (s *= o.bufQueue[0].frequency * o.bufQueue[0].bytesPerSample), s;
        case 4135:
          return o.type;
        case 4628:
          return o.spatialize;
        case 8201:
          for (var b = 0, c = 0, h = 0; h < o.bufQueue.length; h++)
            b += o.bufQueue[h].length, o.bufQueue[h].id !== 0 && (c = o.bufQueue[h].bytesPerSample * o.bufQueue[h].channels);
          return b * c;
        case 8202:
          for (var b = 0, h = 0; h < o.bufQueue.length; h++)
            b += o.bufQueue[h].length;
          return b;
        case 8203:
          return A.sourceDuration(o);
        case 53248:
          return o.distanceModel;
        default:
          return A.currentCtx.err = 40962, null;
      }
    }, setSourceParam: function(e, t, i, o) {
      if (A.currentCtx) {
        var s = A.currentCtx.sources[t];
        if (!s) {
          A.currentCtx.err = 40961;
          return;
        }
        if (o === null) {
          A.currentCtx.err = 40962;
          return;
        }
        switch (i) {
          case 514:
            if (o === 1)
              s.relative = !0, A.updateSourceSpace(s);
            else if (o === 0)
              s.relative = !1, A.updateSourceSpace(s);
            else {
              A.currentCtx.err = 40963;
              return;
            }
            break;
          case 4097:
            if (!Number.isFinite(o)) {
              A.currentCtx.err = 40963;
              return;
            }
            s.coneInnerAngle = o, s.panner && (s.panner.coneInnerAngle = o % 360);
            break;
          case 4098:
            if (!Number.isFinite(o)) {
              A.currentCtx.err = 40963;
              return;
            }
            s.coneOuterAngle = o, s.panner && (s.panner.coneOuterAngle = o % 360);
            break;
          case 4099:
            if (!Number.isFinite(o) || o <= 0) {
              A.currentCtx.err = 40963;
              return;
            }
            if (s.pitch === o)
              break;
            s.pitch = o, A.updateSourceRate(s);
            break;
          case 4100:
            if (!Number.isFinite(o[0]) || !Number.isFinite(o[1]) || !Number.isFinite(o[2])) {
              A.currentCtx.err = 40963;
              return;
            }
            s.position[0] = o[0], s.position[1] = o[1], s.position[2] = o[2], A.updateSourceSpace(s);
            break;
          case 4101:
            if (!Number.isFinite(o[0]) || !Number.isFinite(o[1]) || !Number.isFinite(o[2])) {
              A.currentCtx.err = 40963;
              return;
            }
            s.direction[0] = o[0], s.direction[1] = o[1], s.direction[2] = o[2], A.updateSourceSpace(s);
            break;
          case 4102:
            if (!Number.isFinite(o[0]) || !Number.isFinite(o[1]) || !Number.isFinite(o[2])) {
              A.currentCtx.err = 40963;
              return;
            }
            s.velocity[0] = o[0], s.velocity[1] = o[1], s.velocity[2] = o[2], A.updateSourceSpace(s);
            break;
          case 4103:
            if (o === 1) {
              if (s.looping = !0, A.updateSourceTime(s), s.type === 4136 && s.audioQueue.length > 0) {
                var c = s.audioQueue[0];
                c.loop = !0, c._duration = Number.POSITIVE_INFINITY;
              }
            } else if (o === 0) {
              s.looping = !1;
              var h = A.updateSourceTime(s);
              if (s.type === 4136 && s.audioQueue.length > 0) {
                var c = s.audioQueue[0];
                c.loop = !1, c._duration = s.bufQueue[0].audioBuf.duration / s.playbackRate, c._startTime = h - s.bufOffset / s.playbackRate;
              }
            } else {
              A.currentCtx.err = 40963;
              return;
            }
            break;
          case 4105:
            if (s.state === 4114 || s.state === 4115) {
              A.currentCtx.err = 40964;
              return;
            }
            if (o === 0) {
              for (var b in s.bufQueue)
                s.bufQueue[b].refCount--;
              s.bufQueue.length = 1, s.bufQueue[0] = A.buffers[0], s.bufsProcessed = 0, s.type = 4144;
            } else {
              var x = A.buffers[o];
              if (!x) {
                A.currentCtx.err = 40963;
                return;
              }
              for (var b in s.bufQueue)
                s.bufQueue[b].refCount--;
              s.bufQueue.length = 0, x.refCount++, s.bufQueue = [x], s.bufsProcessed = 0, s.type = 4136;
            }
            A.initSourcePanner(s), A.scheduleSourceAudio(s);
            break;
          case 4106:
            if (!Number.isFinite(o) || o < 0) {
              A.currentCtx.err = 40963;
              return;
            }
            s.gain.gain.value = o;
            break;
          case 4109:
            if (!Number.isFinite(o) || o < 0 || o > Math.min(s.maxGain, 1)) {
              A.currentCtx.err = 40963;
              return;
            }
            s.minGain = o;
            break;
          case 4110:
            if (!Number.isFinite(o) || o < Math.max(0, s.minGain) || o > 1) {
              A.currentCtx.err = 40963;
              return;
            }
            s.maxGain = o;
            break;
          case 4128:
            if (!Number.isFinite(o) || o < 0) {
              A.currentCtx.err = 40963;
              return;
            }
            s.refDistance = o, s.panner && (s.panner.refDistance = o);
            break;
          case 4129:
            if (!Number.isFinite(o) || o < 0) {
              A.currentCtx.err = 40963;
              return;
            }
            s.rolloffFactor = o, s.panner && (s.panner.rolloffFactor = o);
            break;
          case 4130:
            if (!Number.isFinite(o) || o < 0 || o > 1) {
              A.currentCtx.err = 40963;
              return;
            }
            s.coneOuterGain = o, s.panner && (s.panner.coneOuterGain = o);
            break;
          case 4131:
            if (!Number.isFinite(o) || o < 0) {
              A.currentCtx.err = 40963;
              return;
            }
            s.maxDistance = o, s.panner && (s.panner.maxDistance = o);
            break;
          case 4132:
            if (o < 0 || o > A.sourceDuration(s)) {
              A.currentCtx.err = 40963;
              return;
            }
            A.sourceSeek(s, o);
            break;
          case 4133:
            var W = A.sourceDuration(s);
            if (W > 0) {
              var F;
              for (var P in s.bufQueue)
                if (P) {
                  F = s.bufQueue[P].frequency;
                  break;
                }
              o /= F;
            }
            if (o < 0 || o > W) {
              A.currentCtx.err = 40963;
              return;
            }
            A.sourceSeek(s, o);
            break;
          case 4134:
            var W = A.sourceDuration(s);
            if (W > 0) {
              var U;
              for (var P in s.bufQueue)
                if (P) {
                  var x = s.bufQueue[P];
                  U = x.frequency * x.bytesPerSample * x.channels;
                  break;
                }
              o /= U;
            }
            if (o < 0 || o > W) {
              A.currentCtx.err = 40963;
              return;
            }
            A.sourceSeek(s, o);
            break;
          case 4628:
            if (o !== 0 && o !== 1 && o !== 2) {
              A.currentCtx.err = 40963;
              return;
            }
            s.spatialize = o, A.initSourcePanner(s);
            break;
          case 8201:
          case 8202:
          case 8203:
            A.currentCtx.err = 40964;
            break;
          case 53248:
            switch (o) {
              case 0:
              case 53249:
              case 53250:
              case 53251:
              case 53252:
              case 53253:
              case 53254:
                s.distanceModel = o, A.currentCtx.sourceDistanceModel && A.updateContextGlobal(A.currentCtx);
                break;
              default:
                A.currentCtx.err = 40963;
                return;
            }
            break;
          default:
            A.currentCtx.err = 40962;
            return;
        }
      }
    }, captures: {}, sharedCaptureAudioCtx: null, requireValidCaptureDevice: function(e, t) {
      if (e === 0)
        return A.alcErr = 40961, null;
      var i = A.captures[e];
      if (!i)
        return A.alcErr = 40961, null;
      var o = i.mediaStreamError;
      return o ? (A.alcErr = 40961, null) : i;
    } };
    function uc(e, t, i, o, s) {
      if (A.currentCtx) {
        var c = A.buffers[e];
        if (!c) {
          A.currentCtx.err = 40963;
          return;
        }
        if (s <= 0) {
          A.currentCtx.err = 40963;
          return;
        }
        var h = null;
        try {
          switch (t) {
            case 4352:
              if (o > 0) {
                h = A.currentCtx.audioCtx.createBuffer(1, o, s);
                for (var b = h.getChannelData(0), x = 0; x < o; ++x)
                  b[x] = de[i++] * 78125e-7 - 1;
              }
              c.bytesPerSample = 1, c.channels = 1, c.length = o;
              break;
            case 4353:
              if (o > 0) {
                h = A.currentCtx.audioCtx.createBuffer(1, o >> 1, s);
                var b = h.getChannelData(0);
                i >>= 1;
                for (var x = 0; x < o >> 1; ++x)
                  b[x] = Re[i++] * 30517578125e-15;
              }
              c.bytesPerSample = 2, c.channels = 1, c.length = o >> 1;
              break;
            case 4354:
              if (o > 0) {
                h = A.currentCtx.audioCtx.createBuffer(2, o >> 1, s);
                for (var b = h.getChannelData(0), F = h.getChannelData(1), x = 0; x < o >> 1; ++x)
                  b[x] = de[i++] * 78125e-7 - 1, F[x] = de[i++] * 78125e-7 - 1;
              }
              c.bytesPerSample = 1, c.channels = 2, c.length = o >> 1;
              break;
            case 4355:
              if (o > 0) {
                h = A.currentCtx.audioCtx.createBuffer(2, o >> 2, s);
                var b = h.getChannelData(0), F = h.getChannelData(1);
                i >>= 1;
                for (var x = 0; x < o >> 2; ++x)
                  b[x] = Re[i++] * 30517578125e-15, F[x] = Re[i++] * 30517578125e-15;
              }
              c.bytesPerSample = 2, c.channels = 2, c.length = o >> 2;
              break;
            case 65552:
              if (o > 0) {
                h = A.currentCtx.audioCtx.createBuffer(1, o >> 2, s);
                var b = h.getChannelData(0);
                i >>= 2;
                for (var x = 0; x < o >> 2; ++x)
                  b[x] = je[i++];
              }
              c.bytesPerSample = 4, c.channels = 1, c.length = o >> 2;
              break;
            case 65553:
              if (o > 0) {
                h = A.currentCtx.audioCtx.createBuffer(2, o >> 3, s);
                var b = h.getChannelData(0), F = h.getChannelData(1);
                i >>= 2;
                for (var x = 0; x < o >> 3; ++x)
                  b[x] = je[i++], F[x] = je[i++];
              }
              c.bytesPerSample = 4, c.channels = 2, c.length = o >> 3;
              break;
            default:
              A.currentCtx.err = 40963;
              return;
          }
          c.frequency = s, c.audioBuf = h;
        } catch {
          A.currentCtx.err = 40963;
          return;
        }
      }
    }
    function lc(e, t) {
      if (A.currentCtx) {
        for (var i = 0; i < e; ++i) {
          var o = I[t + i * 4 >> 2];
          if (o !== 0) {
            if (!A.buffers[o]) {
              A.currentCtx.err = 40961;
              return;
            }
            if (A.buffers[o].refCount) {
              A.currentCtx.err = 40964;
              return;
            }
          }
        }
        for (var i = 0; i < e; ++i) {
          var o = I[t + i * 4 >> 2];
          o !== 0 && (A.deviceRefCounts[A.buffers[o].deviceId]--, delete A.buffers[o], A.freeIds.push(o));
        }
      }
    }
    function Ja(e, t, i) {
      switch (t) {
        case 514:
        case 4097:
        case 4098:
        case 4103:
        case 4105:
        case 4128:
        case 4129:
        case 4131:
        case 4132:
        case 4133:
        case 4134:
        case 4628:
        case 8201:
        case 8202:
        case 53248:
          A.setSourceParam("alSourcei", e, t, i);
          break;
        default:
          A.setSourceParam("alSourcei", e, t, null);
          break;
      }
    }
    function fc(e, t) {
      if (A.currentCtx) {
        for (var i = 0; i < e; ++i) {
          var o = I[t + i * 4 >> 2];
          if (!A.currentCtx.sources[o]) {
            A.currentCtx.err = 40961;
            return;
          }
        }
        for (var i = 0; i < e; ++i) {
          var o = I[t + i * 4 >> 2];
          A.setSourceState(A.currentCtx.sources[o], 4116), Ja(o, 4105, 0), delete A.currentCtx.sources[o], A.freeIds.push(o);
        }
      }
    }
    function cc(e, t) {
      if (A.currentCtx)
        for (var i = 0; i < e; ++i) {
          var o = { deviceId: A.currentCtx.deviceId, id: A.newId(), refCount: 0, audioBuf: null, frequency: 0, bytesPerSample: 2, channels: 1, length: 0 };
          A.deviceRefCounts[o.deviceId]++, A.buffers[o.id] = o, I[t + i * 4 >> 2] = o.id;
        }
    }
    function dc(e, t) {
      if (A.currentCtx)
        for (var i = 0; i < e; ++i) {
          var o = A.currentCtx.audioCtx.createGain();
          o.connect(A.currentCtx.gain);
          var s = { context: A.currentCtx, id: A.newId(), type: 4144, state: 4113, bufQueue: [A.buffers[0]], audioQueue: [], looping: !1, pitch: 1, dopplerShift: 1, gain: o, minGain: 0, maxGain: 1, panner: null, bufsProcessed: 0, bufStartTime: Number.NEGATIVE_INFINITY, bufOffset: 0, relative: !1, refDistance: 1, maxDistance: 340282e33, rolloffFactor: 1, position: [0, 0, 0], velocity: [0, 0, 0], direction: [0, 0, 0], coneOuterGain: 0, coneInnerAngle: 360, coneOuterAngle: 360, distanceModel: 53250, spatialize: 2, get playbackRate() {
            return this.pitch * this.dopplerShift;
          } };
          A.currentCtx.sources[s.id] = s, I[t + i * 4 >> 2] = s.id;
        }
    }
    function hc() {
      if (!A.currentCtx)
        return 40964;
      var e = A.currentCtx.err;
      return A.currentCtx.err = 0, e;
    }
    function pc(e, t, i) {
      var o = A.getSourceParam("alGetSourcei", e, t);
      if (o !== null) {
        if (!i) {
          A.currentCtx.err = 40963;
          return;
        }
        switch (t) {
          case 514:
          case 4097:
          case 4098:
          case 4103:
          case 4105:
          case 4112:
          case 4117:
          case 4118:
          case 4128:
          case 4129:
          case 4131:
          case 4132:
          case 4133:
          case 4134:
          case 4135:
          case 4628:
          case 8201:
          case 8202:
          case 53248:
            I[i >> 2] = o;
            break;
          default:
            A.currentCtx.err = 40962;
            return;
        }
      }
    }
    function mc(e) {
      if (A.stringCache[e])
        return A.stringCache[e];
      var t;
      switch (e) {
        case 0:
          t = "No Error";
          break;
        case 40961:
          t = "Invalid Name";
          break;
        case 40962:
          t = "Invalid Enum";
          break;
        case 40963:
          t = "Invalid Value";
          break;
        case 40964:
          t = "Invalid Operation";
          break;
        case 40965:
          t = "Out of Memory";
          break;
        case 45057:
          t = "Emscripten";
          break;
        case 45058:
          t = "1.1";
          break;
        case 45059:
          t = "WebAudio";
          break;
        case 45060:
          t = "";
          for (var i in A.AL_EXTENSIONS)
            t = t.concat(i), t = t.concat(" ");
          t = t.trim();
          break;
        default:
          return A.currentCtx && (A.currentCtx.err = 40962), 0;
      }
      return t = wr(t), A.stringCache[e] = t, t;
    }
    function _c(e) {
      if (A.currentCtx) {
        var t = A.currentCtx.sources[e];
        if (!t) {
          A.currentCtx.err = 40961;
          return;
        }
        A.setSourceState(t, 4115);
      }
    }
    function bc(e) {
      if (A.currentCtx) {
        var t = A.currentCtx.sources[e];
        if (!t) {
          A.currentCtx.err = 40961;
          return;
        }
        A.setSourceState(t, 4114);
      }
    }
    function yc(e) {
      if (A.currentCtx) {
        var t = A.currentCtx.sources[e];
        if (!t) {
          A.currentCtx.err = 40961;
          return;
        }
        A.setSourceState(t, 4116);
      }
    }
    function gc(e, t, i) {
      switch (t) {
        case 4097:
        case 4098:
        case 4099:
        case 4106:
        case 4109:
        case 4110:
        case 4128:
        case 4129:
        case 4130:
        case 4131:
        case 4132:
        case 4133:
        case 4134:
        case 8203:
          A.setSourceParam("alSourcef", e, t, i);
          break;
        default:
          A.setSourceParam("alSourcef", e, t, null);
          break;
      }
    }
    function wc(e) {
      return !(e in A.deviceRefCounts) || A.deviceRefCounts[e] > 0 ? 0 : (delete A.deviceRefCounts[e], A.freeIds.push(e), 1);
    }
    var vc = (e, t, i) => {
      e.addEventListener(t, i, { once: !0 });
    }, eo = (e, t) => {
      t || (t = [document, document.getElementById("canvas")]), ["keydown", "mousedown", "touchstart"].forEach((i) => {
        t.forEach((o) => {
          o && vc(o, i, () => {
            e.state === "suspended" && e.resume();
          });
        });
      });
    };
    function Ec(e, t) {
      if (!(e in A.deviceRefCounts))
        return A.alcErr = 40961, 0;
      var i = null, o = [], s = null;
      if (t >>= 2, t)
        for (var c = 0, h = 0; c = I[t++], o.push(c), c !== 0; )
          switch (h = I[t++], o.push(h), c) {
            case 4103:
              i || (i = {}), i.sampleRate = h;
              break;
            case 4112:
            case 4113:
              break;
            case 6546:
              switch (h) {
                case 0:
                  s = !1;
                  break;
                case 1:
                  s = !0;
                  break;
                case 2:
                  break;
                default:
                  return A.alcErr = 40964, 0;
              }
              break;
            case 6550:
              if (h !== 0)
                return A.alcErr = 40964, 0;
              break;
            default:
              return A.alcErr = 40964, 0;
          }
      var b = window.AudioContext || window.webkitAudioContext, x = null;
      try {
        i ? x = new b(i) : x = new b();
      } catch (G) {
        return G.name === "NotSupportedError" ? A.alcErr = 40964 : A.alcErr = 40961, 0;
      }
      eo(x), typeof x.createGain > "u" && (x.createGain = x.createGainNode);
      var F = x.createGain();
      F.connect(x.destination);
      var P = { deviceId: e, id: A.newId(), attrs: o, audioCtx: x, listener: { position: [0, 0, 0], velocity: [0, 0, 0], direction: [0, 0, 0], up: [0, 0, 0] }, sources: [], interval: setInterval(function() {
        A.scheduleContextAudio(P);
      }, A.QUEUE_INTERVAL), gain: F, distanceModel: 53250, speedOfSound: 343.3, dopplerFactor: 1, sourceDistanceModel: !1, hrtf: s || !1, _err: 0, get err() {
        return this._err;
      }, set err(G) {
        (this._err === 0 || G === 0) && (this._err = G);
      } };
      if (A.deviceRefCounts[e]++, A.contexts[P.id] = P, s !== null)
        for (var W in A.contexts) {
          var U = A.contexts[W];
          U.deviceId === e && (U.hrtf = s, A.updateContextGlobal(U));
        }
      return P.id;
    }
    function xc(e) {
      var t = A.contexts[e];
      if (A.currentCtx === t) {
        A.alcErr = 40962;
        return;
      }
      A.contexts[e].interval && clearInterval(A.contexts[e].interval), A.deviceRefCounts[t.deviceId]--, delete A.contexts[e], A.freeIds.push(e);
    }
    function Sc(e) {
      var t = A.alcErr;
      return A.alcErr = 0, t;
    }
    function Cc(e, t) {
      if (A.alcStringCache[t])
        return A.alcStringCache[t];
      var i;
      switch (t) {
        case 0:
          i = "No Error";
          break;
        case 40961:
          i = "Invalid Device";
          break;
        case 40962:
          i = "Invalid Context";
          break;
        case 40963:
          i = "Invalid Enum";
          break;
        case 40964:
          i = "Invalid Value";
          break;
        case 40965:
          i = "Out of Memory";
          break;
        case 4100:
          if (typeof AudioContext < "u" || typeof webkitAudioContext < "u")
            i = A.DEVICE_NAME;
          else
            return 0;
          break;
        case 4101:
          typeof AudioContext < "u" || typeof webkitAudioContext < "u" ? i = A.DEVICE_NAME.concat("\0") : i = "\0";
          break;
        case 785:
          i = A.CAPTURE_DEVICE_NAME;
          break;
        case 784:
          if (e === 0)
            i = A.CAPTURE_DEVICE_NAME.concat("\0");
          else {
            var o = A.requireValidCaptureDevice(e, "alcGetString");
            if (!o)
              return 0;
            i = o.deviceName;
          }
          break;
        case 4102:
          if (!e)
            return A.alcErr = 40961, 0;
          i = "";
          for (var s in A.ALC_EXTENSIONS)
            i = i.concat(s), i = i.concat(" ");
          i = i.trim();
          break;
        default:
          return A.alcErr = 40963, 0;
      }
      return i = wr(i), A.alcStringCache[t] = i, i;
    }
    function Tc(e) {
      return e === 0 ? A.currentCtx = null : A.currentCtx = A.contexts[e], 1;
    }
    function Fc(e) {
      if (e) {
        var t = Xe(e);
        if (t !== A.DEVICE_NAME)
          return 0;
      }
      if (typeof AudioContext < "u" || typeof webkitAudioContext < "u") {
        var i = A.newId();
        return A.deviceRefCounts[i] = 0, i;
      }
      return 0;
    }
    function Rc() {
      return Date.now();
    }
    var to = () => 2147483648, Ac = () => to();
    function Ic() {
      return !L;
    }
    var Pc = (e, t, i) => de.copyWithin(e, t, t + i), kc = (e) => {
      var t = ee.buffer, i = e - t.byteLength + 65535 >>> 16;
      try {
        return ee.grow(i), ke(), 1;
      } catch {
      }
    }, Dc = (e) => {
      var t = de.length;
      e >>>= 0;
      var i = to();
      if (e > i)
        return !1;
      for (var o = (x, F) => x + (F - x % F) % F, s = 1; s <= 4; s *= 2) {
        var c = t * (1 + 0.2 / s);
        c = Math.min(c, e + 100663296);
        var h = Math.min(i, o(Math.max(e, c), 65536)), b = kc(h);
        if (b)
          return !0;
      }
      return !1;
    }, nt = { openDatabase: function(e, t, i, o) {
      try {
        var s = indexedDB.open(e, t);
      } catch (c) {
        return o(c);
      }
      s.onupgradeneeded = (c) => {
        var h = c.target.result;
        h.objectStoreNames.contains("FILES") && h.deleteObjectStore("FILES"), h.createObjectStore("FILES");
      }, s.onsuccess = (c) => i(c.target.result), s.onerror = (c) => o(c);
    }, init: function() {
      nt.xhrs = new pi();
      var e = (i) => {
        nt.dbInstance = i, rt();
      }, t = () => {
        nt.dbInstance = !1, rt();
      };
      mt(), nt.openDatabase("emscripten_filesystem", 1, e, t);
    } };
    function yi(e, t, i, o, s) {
      var c = X[e + 8 >> 2];
      if (!c) {
        i(e, 0, "no url specified!");
        return;
      }
      var h = Xe(c), b = e + 112, x = Xe(b + 0);
      x || (x = "GET");
      var F = X[b + 56 >> 2], P = X[b + 68 >> 2], W = X[b + 72 >> 2], U = X[b + 76 >> 2], G = X[b + 80 >> 2], re = X[b + 84 >> 2], se = X[b + 88 >> 2], fe = X[b + 52 >> 2], be = !!(fe & 1), H = !!(fe & 2), ne = !!(fe & 64), ve = P ? Xe(P) : void 0, Se = W ? Xe(W) : void 0, ue = new XMLHttpRequest();
      if (ue.withCredentials = !!de[b + 60 >> 0], ue.open(x, h, !ne, ve, Se), ne || (ue.timeout = F), ue.url_ = h, ue.responseType = "arraybuffer", G) {
        var Pe = Xe(G);
        ue.overrideMimeType(Pe);
      }
      if (U)
        for (; ; ) {
          var ct = X[U >> 2];
          if (!ct)
            break;
          var Ct = X[U + 4 >> 2];
          if (!Ct)
            break;
          U += 8;
          var Ke = Xe(ct), Tt = Xe(Ct);
          ue.setRequestHeader(Ke, Tt);
        }
      var ut = nt.xhrs.allocate(ue);
      X[e >> 2] = ut;
      var xr = re && se ? de.slice(re, re + se) : null;
      function ar() {
        var Ue = 0, bt = 0;
        ue.response && be && X[e + 12 >> 2] === 0 && (bt = ue.response.byteLength), bt > 0 && (Ue = Lt(bt), de.set(new Uint8Array(ue.response), Ue)), X[e + 12 >> 2] = Ue, Et(e + 16, bt), Et(e + 24, 0);
        var dt = ue.response ? ue.response.byteLength : 0;
        dt && Et(e + 32, dt), ye[e + 40 >> 1] = ue.readyState, ye[e + 42 >> 1] = ue.status, ue.statusText && ot(ue.statusText, e + 44, 64);
      }
      ue.onload = (Ue) => {
        nt.xhrs.has(ut) && (ar(), ue.status >= 200 && ue.status < 300 ? t && t(e, ue, Ue) : i && i(e, ue, Ue));
      }, ue.onerror = (Ue) => {
        nt.xhrs.has(ut) && (ar(), i && i(e, ue, Ue));
      }, ue.ontimeout = (Ue) => {
        nt.xhrs.has(ut) && i && i(e, ue, Ue);
      }, ue.onprogress = (Ue) => {
        if (nt.xhrs.has(ut)) {
          var bt = be && H && ue.response ? ue.response.byteLength : 0, dt = 0;
          bt > 0 && be && H && (dt = Lt(bt), de.set(new Uint8Array(ue.response), dt)), X[e + 12 >> 2] = dt, Et(e + 16, bt), Et(e + 24, Ue.loaded - bt), Et(e + 32, Ue.total), ye[e + 40 >> 1] = ue.readyState, ue.readyState >= 3 && ue.status === 0 && Ue.loaded > 0 && (ue.status = 200), ye[e + 42 >> 1] = ue.status, ue.statusText && ot(ue.statusText, e + 44, 64), o && o(e, ue, Ue), dt && Mt(dt);
        }
      }, ue.onreadystatechange = (Ue) => {
        nt.xhrs.has(ut) && (ye[e + 40 >> 1] = ue.readyState, ue.readyState >= 2 && (ye[e + 42 >> 1] = ue.status), s && s(e, ue, Ue));
      };
      try {
        ue.send(xr);
      } catch (Ue) {
        i && i(e, ue, Ue);
      }
    }
    function Et(e, t) {
      X[e >> 2] = t, X[e + 4 >> 2] = (t - X[e >> 2]) / 4294967296;
    }
    function ro(e, t, i, o, s) {
      if (!e) {
        s(t, 0, "IndexedDB not available!");
        return;
      }
      var c = t + 112, h = X[c + 64 >> 2];
      h || (h = X[t + 8 >> 2]);
      var b = Xe(h);
      try {
        var x = e.transaction(["FILES"], "readwrite"), F = x.objectStore("FILES"), P = F.put(i, b);
        P.onsuccess = (W) => {
          ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 200, ot("OK", t + 44, 64), o(t, 0, b);
        }, P.onerror = (W) => {
          ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 413, ot("Payload Too Large", t + 44, 64), s(t, 0, W);
        };
      } catch (W) {
        s(t, 0, W);
      }
    }
    function Lc(e, t, i, o) {
      if (!e) {
        o(t, 0, "IndexedDB not available!");
        return;
      }
      var s = t + 112, c = X[s + 64 >> 2];
      c || (c = X[t + 8 >> 2]);
      var h = Xe(c);
      try {
        var b = e.transaction(["FILES"], "readonly"), x = b.objectStore("FILES"), F = x.get(h);
        F.onsuccess = (P) => {
          if (P.target.result) {
            var W = P.target.result, U = W.byteLength || W.length, G = Lt(U);
            de.set(new Uint8Array(W), G), X[t + 12 >> 2] = G, Et(t + 16, U), Et(t + 24, 0), Et(t + 32, U), ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 200, ot("OK", t + 44, 64), i(t, 0, W);
          } else
            ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 404, ot("Not Found", t + 44, 64), o(t, 0, "no data");
        }, F.onerror = (P) => {
          ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 404, ot("Not Found", t + 44, 64), o(t, 0, P);
        };
      } catch (P) {
        o(t, 0, P);
      }
    }
    function Mc(e, t, i, o) {
      if (!e) {
        o(t, 0, "IndexedDB not available!");
        return;
      }
      var s = t + 112, c = X[s + 64 >> 2];
      c || (c = X[t + 8 >> 2]);
      var h = Xe(c);
      try {
        var b = e.transaction(["FILES"], "readwrite"), x = b.objectStore("FILES"), F = x.delete(h);
        F.onsuccess = (P) => {
          var W = P.target.result;
          X[t + 12 >> 2] = 0, Et(t + 16, 0), Et(t + 24, 0), Et(t + 32, 0), ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 200, ot("OK", t + 44, 64), i(t, 0, W);
        }, F.onerror = (P) => {
          ye[t + 40 >> 1] = 4, ye[t + 42 >> 1] = 404, ot("Not Found", t + 44, 64), o(t, 0, P);
        };
      } catch (P) {
        o(t, 0, P);
      }
    }
    function Bc(e, t, i, o, s) {
      var c = e + 112, h = X[c + 36 >> 2], b = X[c + 40 >> 2], x = X[c + 44 >> 2], F = X[c + 48 >> 2], P = X[c + 52 >> 2], W = !!(P & 64);
      function U(Ke) {
        W ? Ke() : yn(Ke);
      }
      var G = (Ke, Tt, ut) => {
        U(() => {
          h ? Zt(h)(Ke) : t && t(Ke);
        });
      }, re = (Ke, Tt, ut) => {
        U(() => {
          x ? Zt(x)(Ke) : o && o(Ke);
        });
      }, se = (Ke, Tt, ut) => {
        U(() => {
          b ? Zt(b)(Ke) : i && i(Ke);
        });
      }, fe = (Ke, Tt, ut) => {
        U(() => {
          F ? Zt(F)(Ke) : s && s(Ke);
        });
      }, be = (Ke, Tt, ut) => {
        yi(Ke, G, se, re, fe);
      }, H = (Ke, Tt, ut) => {
        var xr = (Ue, bt, dt) => {
          U(() => {
            h ? Zt(h)(Ue) : t && t(Ue);
          });
        }, ar = (Ue, bt, dt) => {
          U(() => {
            h ? Zt(h)(Ue) : t && t(Ue);
          });
        };
        ro(nt.dbInstance, Ke, Tt.response, xr, ar);
      }, ne = (Ke, Tt, ut) => {
        yi(Ke, H, se, re, fe);
      }, ve = Xe(c + 0), Se = !!(P & 16), ue = !!(P & 4), Pe = !!(P & 32);
      if (ve === "EM_IDB_STORE") {
        var ct = X[c + 84 >> 2], Ct = X[c + 88 >> 2];
        ro(nt.dbInstance, e, de.slice(ct, ct + Ct), G, se);
      } else if (ve === "EM_IDB_DELETE")
        Mc(nt.dbInstance, e, G, se);
      else if (!Se)
        Lc(nt.dbInstance, e, G, Pe ? se : ue ? ne : be);
      else if (!Pe)
        yi(e, ue ? H : G, se, re, fe);
      else
        return 0;
      return e;
    }
    var gi = {}, Nc = () => w || "./this.program", Or = () => {
      if (!Or.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: e, _: Nc() };
        for (var i in gi)
          gi[i] === void 0 ? delete t[i] : t[i] = gi[i];
        var o = [];
        for (var i in t)
          o.push(`${i}=${t[i]}`);
        Or.strings = o;
      }
      return Or.strings;
    }, Oc = (e, t) => {
      for (var i = 0; i < e.length; ++i)
        Ee[t++ >> 0] = e.charCodeAt(i);
      Ee[t >> 0] = 0;
    }, jc = (e, t) => {
      var i = 0;
      return Or().forEach(function(o, s) {
        var c = t + i;
        X[e + s * 4 >> 2] = c, Oc(o, c), i += o.length + 1;
      }), 0;
    }, Uc = (e, t) => {
      var i = Or();
      X[e >> 2] = i.length;
      var o = 0;
      return i.forEach(function(s) {
        o += s.length + 1;
      }), X[t >> 2] = o, 0;
    };
    function Wc(e) {
      try {
        var t = xe.getStreamFromFD(e);
        return g.close(t), 0;
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return i.errno;
      }
    }
    function $c(e, t) {
      try {
        var i = 0, o = 0, s = 0, c = xe.getStreamFromFD(e), h = c.tty ? 2 : g.isDir(c.mode) ? 3 : g.isLink(c.mode) ? 7 : 4;
        return Ee[t >> 0] = h, Re[t + 2 >> 1] = s, V = [i >>> 0, (N = i, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[t + 8 >> 2] = V[0], I[t + 12 >> 2] = V[1], V = [o >>> 0, (N = o, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[t + 16 >> 2] = V[0], I[t + 20 >> 2] = V[1], 0;
      } catch (b) {
        if (typeof g > "u" || b.name !== "ErrnoError")
          throw b;
        return b.errno;
      }
    }
    var Gc = (e, t, i, o) => {
      for (var s = 0, c = 0; c < i; c++) {
        var h = X[t >> 2], b = X[t + 4 >> 2];
        t += 8;
        var x = g.read(e, Ee, h, b, o);
        if (x < 0)
          return -1;
        if (s += x, x < b)
          break;
        typeof o < "u" && (o += x);
      }
      return s;
    };
    function Vc(e, t, i, o) {
      try {
        var s = xe.getStreamFromFD(e), c = Gc(s, t, i);
        return X[o >> 2] = c, 0;
      } catch (h) {
        if (typeof g > "u" || h.name !== "ErrnoError")
          throw h;
        return h.errno;
      }
    }
    function zc(e, t, i, o, s) {
      var c = br(t, i);
      try {
        if (isNaN(c))
          return 61;
        var h = xe.getStreamFromFD(e);
        return g.llseek(h, c, o), V = [h.position >>> 0, (N = h.position, +Math.abs(N) >= 1 ? N > 0 ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)], I[s >> 2] = V[0], I[s + 4 >> 2] = V[1], h.getdents && c === 0 && o === 0 && (h.getdents = null), 0;
      } catch (b) {
        if (typeof g > "u" || b.name !== "ErrnoError")
          throw b;
        return b.errno;
      }
    }
    function Hc(e) {
      try {
        var t = xe.getStreamFromFD(e);
        return t.stream_ops && t.stream_ops.fsync ? t.stream_ops.fsync(t) : 0;
      } catch (i) {
        if (typeof g > "u" || i.name !== "ErrnoError")
          throw i;
        return i.errno;
      }
    }
    var Kc = (e, t, i, o) => {
      for (var s = 0, c = 0; c < i; c++) {
        var h = X[t >> 2], b = X[t + 4 >> 2];
        t += 8;
        var x = g.write(e, Ee, h, b, o);
        if (x < 0)
          return -1;
        s += x, typeof o < "u" && (o += x);
      }
      return s;
    };
    function Yc(e, t, i, o) {
      try {
        var s = xe.getStreamFromFD(e), c = Kc(s, t, i);
        return X[o >> 2] = c, 0;
      } catch (h) {
        if (typeof g > "u" || h.name !== "ErrnoError")
          throw h;
        return h.errno;
      }
    }
    var gn = (e) => {
      for (var t = e.split("."), i = 0; i < 4; i++) {
        var o = Number(t[i]);
        if (isNaN(o))
          return null;
        t[i] = o;
      }
      return (t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24) >>> 0;
    }, jr = (e) => parseInt(e), wi = (e) => {
      var t, i, o, s, c = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i, h = [];
      if (!c.test(e))
        return null;
      if (e === "::")
        return [0, 0, 0, 0, 0, 0, 0, 0];
      for (e.startsWith("::") ? e = e.replace("::", "Z:") : e = e.replace("::", ":Z:"), e.indexOf(".") > 0 ? (e = e.replace(new RegExp("[.]", "g"), ":"), t = e.split(":"), t[t.length - 4] = jr(t[t.length - 4]) + jr(t[t.length - 3]) * 256, t[t.length - 3] = jr(t[t.length - 2]) + jr(t[t.length - 1]) * 256, t = t.slice(0, t.length - 2)) : t = e.split(":"), o = 0, s = 0, i = 0; i < t.length; i++)
        if (typeof t[i] == "string")
          if (t[i] === "Z") {
            for (s = 0; s < 8 - t.length + 1; s++)
              h[i + s] = 0;
            o = s - 1;
          } else
            h[i + o] = xn(parseInt(t[i], 16));
        else
          h[i + o] = t[i];
      return [h[1] << 16 | h[0], h[3] << 16 | h[2], h[5] << 16 | h[4], h[7] << 16 | h[6]];
    }, qt = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name: (e) => {
      var t = gn(e);
      if (t !== null || (t = wi(e), t !== null))
        return e;
      var i;
      if (qt.address_map.addrs[e])
        i = qt.address_map.addrs[e];
      else {
        var o = qt.address_map.id++;
        me(o < 65535, "exceeded max address mappings of 65535"), i = "172.29." + (o & 255) + "." + (o & 65280), qt.address_map.names[i] = e, qt.address_map.addrs[e] = i;
      }
      return i;
    }, lookup_addr: (e) => qt.address_map.names[e] ? qt.address_map.names[e] : null }, no = (e) => (e & 255) + "." + (e >> 8 & 255) + "." + (e >> 16 & 255) + "." + (e >> 24 & 255), Xc = (e) => {
      var t = "", i = 0, o = 0, s = 0, c = 0, h = 0, b = 0, x = [e[0] & 65535, e[0] >> 16, e[1] & 65535, e[1] >> 16, e[2] & 65535, e[2] >> 16, e[3] & 65535, e[3] >> 16], F = !0, P = "";
      for (b = 0; b < 5; b++)
        if (x[b] !== 0) {
          F = !1;
          break;
        }
      if (F) {
        if (P = no(x[6] | x[7] << 16), x[5] === -1)
          return t = "::ffff:", t += P, t;
        if (x[5] === 0)
          return t = "::", P === "0.0.0.0" && (P = ""), P === "0.0.0.1" && (P = "1"), t += P, t;
      }
      for (i = 0; i < 8; i++)
        x[i] === 0 && (i - s > 1 && (h = 0), s = i, h++), h > o && (o = h, c = i - o + 1);
      for (i = 0; i < 8; i++) {
        if (o > 1 && x[i] === 0 && i >= c && i < c + o) {
          i === c && (t += ":", c === 0 && (t += ":"));
          continue;
        }
        t += Number(mo(x[i] & 65535)).toString(16), t += i < 7 ? ":" : "";
      }
      return t;
    }, Zc = (e, t, i, o, s) => {
      switch (t) {
        case 2:
          i = gn(i), ai(e, 16), s && (I[s >> 2] = 16), Re[e >> 1] = t, I[e + 4 >> 2] = i, Re[e + 2 >> 1] = xn(o);
          break;
        case 10:
          i = wi(i), ai(e, 28), s && (I[s >> 2] = 28), I[e >> 2] = t, I[e + 8 >> 2] = i[0], I[e + 12 >> 2] = i[1], I[e + 16 >> 2] = i[2], I[e + 20 >> 2] = i[3], Re[e + 2 >> 1] = xn(o);
          break;
        default:
          return 5;
      }
      return 0;
    }, qc = (e, t, i, o) => {
      var s = 0, c = 0, h = 0, b = 0, x = 0, F = 0, P;
      function W(U, G, re, se, fe, be) {
        var H, ne, ve, Se;
        return ne = U === 10 ? 28 : 16, fe = U === 10 ? Xc(fe) : no(fe), H = Lt(ne), Se = Zc(H, U, fe, be), me(!Se), ve = Lt(32), I[ve + 4 >> 2] = U, I[ve + 8 >> 2] = G, I[ve + 12 >> 2] = re, X[ve + 24 >> 2] = se, X[ve + 20 >> 2] = H, U === 10 ? I[ve + 16 >> 2] = 28 : I[ve + 16 >> 2] = 16, I[ve + 28 >> 2] = 0, ve;
      }
      if (i && (h = I[i >> 2], b = I[i + 4 >> 2], x = I[i + 8 >> 2], F = I[i + 12 >> 2]), x && !F && (F = x === 2 ? 17 : 6), !x && F && (x = F === 17 ? 2 : 1), F === 0 && (F = 6), x === 0 && (x = 1), !e && !t)
        return -2;
      if (h & -1088 || i !== 0 && I[i >> 2] & 2 && !e)
        return -1;
      if (h & 32)
        return -2;
      if (x !== 0 && x !== 1 && x !== 2)
        return -7;
      if (b !== 0 && b !== 2 && b !== 10)
        return -6;
      if (t && (t = Xe(t), c = parseInt(t, 10), isNaN(c)))
        return h & 1024 ? -2 : -8;
      if (!e)
        return b === 0 && (b = 2), h & 1 || (b === 2 ? s = En(2130706433) : s = [0, 0, 0, 1]), P = W(b, x, F, null, s, c), X[o >> 2] = P, 0;
      if (e = Xe(e), s = gn(e), s !== null)
        if (b === 0 || b === 2)
          b = 2;
        else if (b === 10 && h & 8)
          s = [0, 0, En(65535), s], b = 10;
        else
          return -2;
      else if (s = wi(e), s !== null)
        if (b === 0 || b === 10)
          b = 10;
        else
          return -2;
      return s != null ? (P = W(b, x, F, e, s, c), X[o >> 2] = P, 0) : h & 4 ? -2 : (e = qt.lookup_name(e), s = gn(e), b === 0 ? b = 2 : b === 10 && (s = [0, 0, En(65535), s]), P = W(b, x, F, null, s, c), X[o >> 2] = P, 0);
    }, Qc = (e, t) => (Me(de.subarray(e, e + t)), 0), te = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: [], offscreenCanvases: {}, queries: [], samplers: [], transformFeedbacks: [], syncs: [], stringCache: {}, stringiCache: {}, unpackAlignment: 4, recordError: function(t) {
      te.lastError || (te.lastError = t);
    }, getNewId: function(e) {
      for (var t = te.counter++, i = e.length; i < t; i++)
        e[i] = null;
      return t;
    }, getSource: function(e, t, i, o) {
      for (var s = "", c = 0; c < t; ++c) {
        var h = o ? I[o + c * 4 >> 2] : -1;
        s += Xe(I[i + c * 4 >> 2], h < 0 ? void 0 : h);
      }
      return s;
    }, createContext: function(e, t) {
      if (!e.getContextSafariWebGL2Fixed) {
        let s = function(c, h) {
          var b = e.getContextSafariWebGL2Fixed(c, h);
          return c == "webgl" == b instanceof WebGLRenderingContext ? b : null;
        };
        e.getContextSafariWebGL2Fixed = e.getContext, e.getContext = s;
      }
      var i = t.majorVersion > 1 ? e.getContext("webgl2", t) : e.getContext("webgl", t);
      if (!i)
        return 0;
      var o = te.registerContext(i, t);
      return o;
    }, registerContext: function(e, t) {
      var i = te.getNewId(te.contexts), o = { handle: i, attributes: t, version: t.majorVersion, GLctx: e };
      return e.canvas && (e.canvas.GLctxObject = o), te.contexts[i] = o, i;
    }, makeContextCurrent: function(e) {
      return te.currentContext = te.contexts[e], n.ctx = Z = te.currentContext && te.currentContext.GLctx, !(e && !Z);
    }, getContext: function(e) {
      return te.contexts[e];
    }, deleteContext: function(e) {
      te.currentContext === te.contexts[e] && (te.currentContext = null), typeof JSEvents == "object" && JSEvents.removeAllHandlersOnTarget(te.contexts[e].GLctx.canvas), te.contexts[e] && te.contexts[e].GLctx.canvas && (te.contexts[e].GLctx.canvas.GLctxObject = void 0), te.contexts[e] = null;
    } };
    function Jc(e) {
      Z.activeTexture(e);
    }
    function ed(e, t) {
      Z.attachShader(te.programs[e], te.shaders[t]);
    }
    function td(e, t) {
      e == 35051 ? Z.currentPixelPackBufferBinding = t : e == 35052 && (Z.currentPixelUnpackBufferBinding = t), Z.bindBuffer(e, te.buffers[t]);
    }
    function rd(e, t, i, o, s) {
      Z.bindBufferRange(e, t, te.buffers[i], o, s);
    }
    function nd(e, t) {
      Z.bindFramebuffer(e, te.framebuffers[t]);
    }
    function id(e, t) {
      Z.bindRenderbuffer(e, te.renderbuffers[t]);
    }
    function ad(e, t) {
      Z.bindTexture(e, te.textures[t]);
    }
    function od(e) {
      Z.bindVertexArray(te.vaos[e]);
    }
    function sd(e) {
      Z.blendEquation(e);
    }
    function ud(e, t) {
      Z.blendFunc(e, t);
    }
    function ld(e, t, i, o) {
      Z.blendFuncSeparate(e, t, i, o);
    }
    function fd(e, t, i, o, s, c, h, b, x, F) {
      Z.blitFramebuffer(e, t, i, o, s, c, h, b, x, F);
    }
    function cd(e, t, i, o) {
      te.currentContext.version >= 2 ? i && t ? Z.bufferData(e, de, o, i, t) : Z.bufferData(e, t, o) : Z.bufferData(e, i ? de.subarray(i, i + t) : t, o);
    }
    function dd(e, t, i, o) {
      if (te.currentContext.version >= 2) {
        i && Z.bufferSubData(e, t, de, o, i);
        return;
      }
      Z.bufferSubData(e, t, de.subarray(o, o + i));
    }
    function hd(e, t, i) {
      Z.clearBufferfv(e, t, je, i >> 2);
    }
    function pd(e, t, i, o) {
      Z.colorMask(!!e, !!t, !!i, !!o);
    }
    function md(e) {
      Z.compileShader(te.shaders[e]);
    }
    function _d(e, t, i, o, s, c, h, b) {
      if (te.currentContext.version >= 2) {
        Z.currentPixelUnpackBufferBinding || !h ? Z.compressedTexImage2D(e, t, i, o, s, c, h, b) : Z.compressedTexImage2D(e, t, i, o, s, c, de, b, h);
        return;
      }
      Z.compressedTexImage2D(e, t, i, o, s, c, b ? de.subarray(b, b + h) : null);
    }
    function bd(e, t, i, o, s, c, h, b, x) {
      Z.currentPixelUnpackBufferBinding ? Z.compressedTexImage3D(e, t, i, o, s, c, h, b, x) : Z.compressedTexImage3D(e, t, i, o, s, c, h, de, x, b);
    }
    function yd() {
      var e = te.getNewId(te.programs), t = Z.createProgram();
      return t.name = e, t.maxUniformLength = t.maxAttributeLength = t.maxUniformBlockNameLength = 0, t.uniformIdCounter = 1, te.programs[e] = t, e;
    }
    function gd(e) {
      var t = te.getNewId(te.shaders);
      return te.shaders[t] = Z.createShader(e), t;
    }
    function wd(e, t) {
      for (var i = 0; i < e; i++) {
        var o = I[t + i * 4 >> 2], s = te.buffers[o];
        s && (Z.deleteBuffer(s), s.name = 0, te.buffers[o] = null, o == Z.currentPixelPackBufferBinding && (Z.currentPixelPackBufferBinding = 0), o == Z.currentPixelUnpackBufferBinding && (Z.currentPixelUnpackBufferBinding = 0));
      }
    }
    function vd(e, t) {
      for (var i = 0; i < e; ++i) {
        var o = I[t + i * 4 >> 2], s = te.framebuffers[o];
        s && (Z.deleteFramebuffer(s), s.name = 0, te.framebuffers[o] = null);
      }
    }
    function Ed(e) {
      if (e) {
        var t = te.programs[e];
        if (!t) {
          te.recordError(1281);
          return;
        }
        Z.deleteProgram(t), t.name = 0, te.programs[e] = null;
      }
    }
    function xd(e, t) {
      for (var i = 0; i < e; i++) {
        var o = I[t + i * 4 >> 2], s = te.renderbuffers[o];
        s && (Z.deleteRenderbuffer(s), s.name = 0, te.renderbuffers[o] = null);
      }
    }
    function Sd(e) {
      if (e) {
        var t = te.shaders[e];
        if (!t) {
          te.recordError(1281);
          return;
        }
        Z.deleteShader(t), te.shaders[e] = null;
      }
    }
    function Cd(e, t) {
      for (var i = 0; i < e; i++) {
        var o = I[t + i * 4 >> 2], s = te.textures[o];
        s && (Z.deleteTexture(s), s.name = 0, te.textures[o] = null);
      }
    }
    function Td(e, t) {
      for (var i = 0; i < e; i++) {
        var o = I[t + i * 4 >> 2];
        Z.deleteVertexArray(te.vaos[o]), te.vaos[o] = null;
      }
    }
    function Fd(e) {
      Z.depthFunc(e);
    }
    function Rd(e) {
      Z.depthMask(!!e);
    }
    function Ad(e) {
      Z.disable(e);
    }
    function Id(e, t, i) {
      Z.drawArrays(e, t, i);
    }
    function Pd(e, t, i, o) {
      Z.drawArraysInstanced(e, t, i, o);
    }
    var vi = [];
    function kd(e, t) {
      for (var i = vi[e], o = 0; o < e; o++)
        i[o] = I[t + o * 4 >> 2];
      Z.drawBuffers(i);
    }
    function Dd(e, t, i, o) {
      Z.drawElements(e, t, i, o);
    }
    function Ld(e, t, i, o, s) {
      Z.drawElementsInstanced(e, t, i, o, s);
    }
    function Md(e) {
      Z.enable(e);
    }
    function Bd(e) {
      Z.enableVertexAttribArray(e);
    }
    function Nd(e, t, i, o) {
      Z.framebufferRenderbuffer(e, t, i, te.renderbuffers[o]);
    }
    function Od(e, t, i, o, s) {
      Z.framebufferTexture2D(e, t, i, te.textures[o], s);
    }
    function Ur(e, t, i, o) {
      for (var s = 0; s < e; s++) {
        var c = Z[i](), h = c && te.getNewId(o);
        c ? (c.name = h, o[h] = c) : te.recordError(1282), I[t + s * 4 >> 2] = h;
      }
    }
    function jd(e, t) {
      Ur(e, t, "createBuffer", te.buffers);
    }
    function Ud(e, t) {
      Ur(e, t, "createFramebuffer", te.framebuffers);
    }
    function Wd(e, t) {
      Ur(e, t, "createRenderbuffer", te.renderbuffers);
    }
    function $d(e, t) {
      Ur(e, t, "createTexture", te.textures);
    }
    function Gd(e, t) {
      Ur(e, t, "createVertexArray", te.vaos);
    }
    function Vd(e) {
      Z.generateMipmap(e);
    }
    function zd() {
      var e = Z.getError() || te.lastError;
      return te.lastError = 0, e;
    }
    function Hd(e, t, i) {
      if (!t) {
        te.recordError(1281);
        return;
      }
      var o = void 0;
      switch (e) {
        case 36346:
          o = 1;
          break;
        case 36344:
          i != 0 && i != 1 && te.recordError(1280);
          return;
        case 34814:
        case 36345:
          o = 0;
          break;
        case 34466:
          var s = Z.getParameter(34467);
          o = s ? s.length : 0;
          break;
        case 33309:
          if (te.currentContext.version < 2) {
            te.recordError(1282);
            return;
          }
          var c = Z.getSupportedExtensions() || [];
          o = 2 * c.length;
          break;
        case 33307:
        case 33308:
          if (te.currentContext.version < 2) {
            te.recordError(1280);
            return;
          }
          o = e == 33307 ? 3 : 0;
          break;
      }
      if (o === void 0) {
        var h = Z.getParameter(e);
        switch (typeof h) {
          case "number":
            o = h;
            break;
          case "boolean":
            o = h ? 1 : 0;
            break;
          case "string":
            te.recordError(1280);
            return;
          case "object":
            if (h === null)
              switch (e) {
                case 34964:
                case 35725:
                case 34965:
                case 36006:
                case 36007:
                case 32873:
                case 34229:
                case 36662:
                case 36663:
                case 35053:
                case 35055:
                case 36010:
                case 35097:
                case 35869:
                case 32874:
                case 36389:
                case 35983:
                case 35368:
                case 34068: {
                  o = 0;
                  break;
                }
                default: {
                  te.recordError(1280);
                  return;
                }
              }
            else if (h instanceof Float32Array || h instanceof Uint32Array || h instanceof Int32Array || h instanceof Array) {
              for (var b = 0; b < h.length; ++b)
                switch (i) {
                  case 0:
                    I[t + b * 4 >> 2] = h[b];
                    break;
                  case 2:
                    je[t + b * 4 >> 2] = h[b];
                    break;
                  case 4:
                    Ee[t + b >> 0] = h[b] ? 1 : 0;
                    break;
                }
              return;
            } else
              try {
                o = h.name | 0;
              } catch (x) {
                te.recordError(1280), pe("GL_INVALID_ENUM in glGet" + i + "v: Unknown object returned from WebGL getParameter(" + e + ")! (error: " + x + ")");
                return;
              }
            break;
          default:
            te.recordError(1280), pe("GL_INVALID_ENUM in glGet" + i + "v: Native code calling glGet" + i + "v(" + e + ") and it returns " + h + " of type " + typeof h + "!");
            return;
        }
      }
      switch (i) {
        case 1:
          Et(t, o);
          break;
        case 0:
          I[t >> 2] = o;
          break;
        case 2:
          je[t >> 2] = o;
          break;
        case 4:
          Ee[t >> 0] = o ? 1 : 0;
          break;
      }
    }
    function Kd(e, t) {
      Hd(e, t, 0);
    }
    function Yd(e, t, i, o) {
      var s = Z.getProgramInfoLog(te.programs[e]);
      s === null && (s = "(unknown error)");
      var c = t > 0 && o ? ot(s, o, t) : 0;
      i && (I[i >> 2] = c);
    }
    function Xd(e, t, i) {
      if (!i) {
        te.recordError(1281);
        return;
      }
      if (e >= te.counter) {
        te.recordError(1281);
        return;
      }
      if (e = te.programs[e], t == 35716) {
        var o = Z.getProgramInfoLog(e);
        o === null && (o = "(unknown error)"), I[i >> 2] = o.length + 1;
      } else if (t == 35719) {
        if (!e.maxUniformLength)
          for (var s = 0; s < Z.getProgramParameter(e, 35718); ++s)
            e.maxUniformLength = Math.max(e.maxUniformLength, Z.getActiveUniform(e, s).name.length + 1);
        I[i >> 2] = e.maxUniformLength;
      } else if (t == 35722) {
        if (!e.maxAttributeLength)
          for (var s = 0; s < Z.getProgramParameter(e, 35721); ++s)
            e.maxAttributeLength = Math.max(e.maxAttributeLength, Z.getActiveAttrib(e, s).name.length + 1);
        I[i >> 2] = e.maxAttributeLength;
      } else if (t == 35381) {
        if (!e.maxUniformBlockNameLength)
          for (var s = 0; s < Z.getProgramParameter(e, 35382); ++s)
            e.maxUniformBlockNameLength = Math.max(e.maxUniformBlockNameLength, Z.getActiveUniformBlockName(e, s).length + 1);
        I[i >> 2] = e.maxUniformBlockNameLength;
      } else
        I[i >> 2] = Z.getProgramParameter(e, t);
    }
    function Zd(e, t, i, o) {
      var s = Z.getShaderInfoLog(te.shaders[e]);
      s === null && (s = "(unknown error)");
      var c = t > 0 && o ? ot(s, o, t) : 0;
      i && (I[i >> 2] = c);
    }
    function qd(e, t, i) {
      if (!i) {
        te.recordError(1281);
        return;
      }
      if (t == 35716) {
        var o = Z.getShaderInfoLog(te.shaders[e]);
        o === null && (o = "(unknown error)");
        var s = o ? o.length + 1 : 0;
        I[i >> 2] = s;
      } else if (t == 35720) {
        var c = Z.getShaderSource(te.shaders[e]), h = c ? c.length + 1 : 0;
        I[i >> 2] = h;
      } else
        I[i >> 2] = Z.getShaderParameter(te.shaders[e], t);
    }
    function io(e) {
      return e.slice(-1) == "]" && e.lastIndexOf("[");
    }
    function Qd(e) {
      var t = e.uniformLocsById, i = e.uniformSizeAndIdsByName, o, s;
      if (!t)
        for (e.uniformLocsById = t = {}, e.uniformArrayNamesById = {}, o = 0; o < Z.getProgramParameter(e, 35718); ++o) {
          var c = Z.getActiveUniform(e, o), h = c.name, b = c.size, x = io(h), F = x > 0 ? h.slice(0, x) : h, P = e.uniformIdCounter;
          for (e.uniformIdCounter += b, i[F] = [b, P], s = 0; s < b; ++s)
            t[P] = s, e.uniformArrayNamesById[P++] = F;
        }
    }
    function Jd(e, t) {
      if (t = Xe(t), e = te.programs[e]) {
        Qd(e);
        var i = e.uniformLocsById, o = 0, s = t, c = io(t);
        c > 0 && (o = jr(t.slice(c + 1)) >>> 0, s = t.slice(0, c));
        var h = e.uniformSizeAndIdsByName[s];
        if (h && o < h[0] && (o += h[1], i[o] = i[o] || Z.getUniformLocation(e, t)))
          return o;
      } else
        te.recordError(1281);
      return -1;
    }
    function eh(e, t, i) {
      for (var o = vi[t], s = 0; s < t; s++)
        o[s] = I[i + s * 4 >> 2];
      Z.invalidateFramebuffer(e, o);
    }
    function th(e) {
      e = te.programs[e], Z.linkProgram(e), e.uniformLocsById = 0, e.uniformSizeAndIdsByName = {};
    }
    function rh(e, t) {
      e == 3317 && (te.unpackAlignment = t), Z.pixelStorei(e, t);
    }
    function nh(e, t, i, o) {
      function s(b, x) {
        return b + x - 1 & -x;
      }
      var c = e * i, h = s(c, o);
      return t * h;
    }
    function ih(e) {
      var t = { 5: 3, 6: 4, 8: 2, 29502: 3, 29504: 4, 26917: 2, 26918: 2, 29846: 3, 29847: 4 };
      return t[e - 6402] || 1;
    }
    function vr(e) {
      return e -= 5120, e == 0 ? Ee : e == 1 ? de : e == 2 ? Re : e == 4 ? I : e == 6 ? je : e == 5 || e == 28922 || e == 28520 || e == 30779 || e == 30782 ? X : ye;
    }
    function Er(e) {
      return 31 - Math.clz32(e.BYTES_PER_ELEMENT);
    }
    function Ei(e, t, i, o, s, c) {
      var h = vr(e), b = Er(h), x = 1 << b, F = ih(t) * x, P = nh(i, o, F, te.unpackAlignment);
      return h.subarray(s >> b, s + P >> b);
    }
    function ah(e, t, i, o, s, c, h) {
      if (te.currentContext.version >= 2) {
        if (Z.currentPixelPackBufferBinding)
          Z.readPixels(e, t, i, o, s, c, h);
        else {
          var b = vr(c);
          Z.readPixels(e, t, i, o, s, c, b, h >> Er(b));
        }
        return;
      }
      var x = Ei(c, s, i, o, h);
      if (!x) {
        te.recordError(1280);
        return;
      }
      Z.readPixels(e, t, i, o, s, c, x);
    }
    function oh(e, t, i, o) {
      Z.renderbufferStorage(e, t, i, o);
    }
    function sh(e, t, i, o, s) {
      Z.renderbufferStorageMultisample(e, t, i, o, s);
    }
    function uh(e, t, i, o) {
      var s = te.getSource(e, t, i, o);
      Z.shaderSource(te.shaders[e], s);
    }
    function lh(e, t, i, o, s, c, h, b, x) {
      if (te.currentContext.version >= 2) {
        if (Z.currentPixelUnpackBufferBinding)
          Z.texImage2D(e, t, i, o, s, c, h, b, x);
        else if (x) {
          var F = vr(b);
          Z.texImage2D(e, t, i, o, s, c, h, b, F, x >> Er(F));
        } else
          Z.texImage2D(e, t, i, o, s, c, h, b, null);
        return;
      }
      Z.texImage2D(e, t, i, o, s, c, h, b, x ? Ei(b, h, o, s, x) : null);
    }
    function fh(e, t, i, o, s, c, h, b, x, F) {
      if (Z.currentPixelUnpackBufferBinding)
        Z.texImage3D(e, t, i, o, s, c, h, b, x, F);
      else if (F) {
        var P = vr(x);
        Z.texImage3D(e, t, i, o, s, c, h, b, x, P, F >> Er(P));
      } else
        Z.texImage3D(e, t, i, o, s, c, h, b, x, null);
    }
    function ch(e, t, i) {
      Z.texParameteri(e, t, i);
    }
    function dh(e, t, i, o, s) {
      Z.texStorage2D(e, t, i, o, s);
    }
    function hh(e, t, i, o, s, c, h, b, x) {
      if (te.currentContext.version >= 2) {
        if (Z.currentPixelUnpackBufferBinding)
          Z.texSubImage2D(e, t, i, o, s, c, h, b, x);
        else if (x) {
          var F = vr(b);
          Z.texSubImage2D(e, t, i, o, s, c, h, b, F, x >> Er(F));
        } else
          Z.texSubImage2D(e, t, i, o, s, c, h, b, null);
        return;
      }
      var P = null;
      x && (P = Ei(b, h, s, c, x)), Z.texSubImage2D(e, t, i, o, s, c, h, b, P);
    }
    function ph(e, t, i, o, s, c, h, b, x, F, P) {
      if (Z.currentPixelUnpackBufferBinding)
        Z.texSubImage3D(e, t, i, o, s, c, h, b, x, F, P);
      else if (P) {
        var W = vr(F);
        Z.texSubImage3D(e, t, i, o, s, c, h, b, x, F, W, P >> Er(W));
      } else
        Z.texSubImage3D(e, t, i, o, s, c, h, b, x, F, null);
    }
    function ao(e) {
      var t = Z.currentProgram;
      if (t) {
        var i = t.uniformLocsById[e];
        return typeof i == "number" && (t.uniformLocsById[e] = i = Z.getUniformLocation(t, t.uniformArrayNamesById[e] + (i > 0 ? "[" + i + "]" : ""))), i;
      } else
        te.recordError(1282);
    }
    function mh(e, t) {
      Z.uniform1i(ao(e), t);
    }
    function _h(e, t) {
      Z.uniform1ui(ao(e), t);
    }
    function bh(e) {
      e = te.programs[e], Z.useProgram(e), Z.currentProgram = e;
    }
    function yh(e, t, i, o, s) {
      Z.vertexAttribIPointer(e, t, i, o, s);
    }
    function gh(e, t, i, o, s, c) {
      Z.vertexAttribPointer(e, t, i, !!o, s, c);
    }
    function wh(e, t, i, o) {
      Z.viewport(e, t, i, o);
    }
    var vh = (e, t) => {
      for (var i = 0, o = 0; o <= t; i += e[o++])
        ;
      return i;
    }, oo = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], so = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Eh = (e, t) => {
      for (var i = new Date(e.getTime()); t > 0; ) {
        var o = Nr(i.getFullYear()), s = i.getMonth(), c = (o ? oo : so)[s];
        if (t > c - i.getDate())
          t -= c - i.getDate() + 1, i.setDate(1), s < 11 ? i.setMonth(s + 1) : (i.setMonth(0), i.setFullYear(i.getFullYear() + 1));
        else
          return i.setDate(i.getDate() + t), i;
      }
      return i;
    }, xh = (e, t) => {
      Ee.set(e, t);
    }, uo = (e, t, i, o) => {
      var s = I[o + 40 >> 2], c = { tm_sec: I[o >> 2], tm_min: I[o + 4 >> 2], tm_hour: I[o + 8 >> 2], tm_mday: I[o + 12 >> 2], tm_mon: I[o + 16 >> 2], tm_year: I[o + 20 >> 2], tm_wday: I[o + 24 >> 2], tm_yday: I[o + 28 >> 2], tm_isdst: I[o + 32 >> 2], tm_gmtoff: I[o + 36 >> 2], tm_zone: s ? Xe(s) : "" }, h = Xe(i), b = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var x in b)
        h = h.replace(new RegExp(x, "g"), b[x]);
      var F = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], P = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function W(H, ne, ve) {
        for (var Se = typeof H == "number" ? H.toString() : H || ""; Se.length < ne; )
          Se = ve[0] + Se;
        return Se;
      }
      function U(H, ne) {
        return W(H, ne, "0");
      }
      function G(H, ne) {
        function ve(ue) {
          return ue < 0 ? -1 : ue > 0 ? 1 : 0;
        }
        var Se;
        return (Se = ve(H.getFullYear() - ne.getFullYear())) === 0 && (Se = ve(H.getMonth() - ne.getMonth())) === 0 && (Se = ve(H.getDate() - ne.getDate())), Se;
      }
      function re(H) {
        switch (H.getDay()) {
          case 0:
            return new Date(H.getFullYear() - 1, 11, 29);
          case 1:
            return H;
          case 2:
            return new Date(H.getFullYear(), 0, 3);
          case 3:
            return new Date(H.getFullYear(), 0, 2);
          case 4:
            return new Date(H.getFullYear(), 0, 1);
          case 5:
            return new Date(H.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(H.getFullYear() - 1, 11, 30);
        }
      }
      function se(H) {
        var ne = Eh(new Date(H.tm_year + 1900, 0, 1), H.tm_yday), ve = new Date(ne.getFullYear(), 0, 4), Se = new Date(ne.getFullYear() + 1, 0, 4), ue = re(ve), Pe = re(Se);
        return G(ue, ne) <= 0 ? G(Pe, ne) <= 0 ? ne.getFullYear() + 1 : ne.getFullYear() : ne.getFullYear() - 1;
      }
      var fe = { "%a": (H) => F[H.tm_wday].substring(0, 3), "%A": (H) => F[H.tm_wday], "%b": (H) => P[H.tm_mon].substring(0, 3), "%B": (H) => P[H.tm_mon], "%C": (H) => {
        var ne = H.tm_year + 1900;
        return U(ne / 100 | 0, 2);
      }, "%d": (H) => U(H.tm_mday, 2), "%e": (H) => W(H.tm_mday, 2, " "), "%g": (H) => se(H).toString().substring(2), "%G": (H) => se(H), "%H": (H) => U(H.tm_hour, 2), "%I": (H) => {
        var ne = H.tm_hour;
        return ne == 0 ? ne = 12 : ne > 12 && (ne -= 12), U(ne, 2);
      }, "%j": (H) => U(H.tm_mday + vh(Nr(H.tm_year + 1900) ? oo : so, H.tm_mon - 1), 3), "%m": (H) => U(H.tm_mon + 1, 2), "%M": (H) => U(H.tm_min, 2), "%n": () => `
`, "%p": (H) => H.tm_hour >= 0 && H.tm_hour < 12 ? "AM" : "PM", "%S": (H) => U(H.tm_sec, 2), "%t": () => "	", "%u": (H) => H.tm_wday || 7, "%U": (H) => {
        var ne = H.tm_yday + 7 - H.tm_wday;
        return U(Math.floor(ne / 7), 2);
      }, "%V": (H) => {
        var ne = Math.floor((H.tm_yday + 7 - (H.tm_wday + 6) % 7) / 7);
        if ((H.tm_wday + 371 - H.tm_yday - 2) % 7 <= 2 && ne++, ne) {
          if (ne == 53) {
            var Se = (H.tm_wday + 371 - H.tm_yday) % 7;
            Se != 4 && (Se != 3 || !Nr(H.tm_year)) && (ne = 1);
          }
        } else {
          ne = 52;
          var ve = (H.tm_wday + 7 - H.tm_yday - 1) % 7;
          (ve == 4 || ve == 5 && Nr(H.tm_year % 400 - 1)) && ne++;
        }
        return U(ne, 2);
      }, "%w": (H) => H.tm_wday, "%W": (H) => {
        var ne = H.tm_yday + 7 - (H.tm_wday + 6) % 7;
        return U(Math.floor(ne / 7), 2);
      }, "%y": (H) => (H.tm_year + 1900).toString().substring(2), "%Y": (H) => H.tm_year + 1900, "%z": (H) => {
        var ne = H.tm_gmtoff, ve = ne >= 0;
        return ne = Math.abs(ne) / 60, ne = ne / 60 * 100 + ne % 60, (ve ? "+" : "-") + ("0000" + ne).slice(-4);
      }, "%Z": (H) => H.tm_zone, "%%": () => "%" };
      h = h.replace(/%%/g, "\0\0");
      for (var x in fe)
        h.includes(x) && (h = h.replace(new RegExp(x, "g"), fe[x](c)));
      h = h.replace(/\0\0/g, "%");
      var be = tn(h, !1);
      return be.length > t ? 0 : (xh(be, e), be.length - 1);
    }, Sh = (e, t, i, o, s) => uo(e, t, i, o), lo = function(e, t, i, o) {
      e || (e = this), this.parent = e, this.mount = e.mount, this.mounted = null, this.id = g.nextInode++, this.name = t, this.mode = i, this.node_ops = {}, this.stream_ops = {}, this.rdev = o;
    }, wn = 365, vn = 146;
    Object.defineProperties(lo.prototype, { read: { get: function() {
      return (this.mode & wn) === wn;
    }, set: function(e) {
      e ? this.mode |= wn : this.mode &= ~wn;
    } }, write: { get: function() {
      return (this.mode & vn) === vn;
    }, set: function(e) {
      e ? this.mode |= vn : this.mode &= ~vn;
    } }, isFolder: { get: function() {
      return g.isDir(this.mode);
    } }, isDevice: { get: function() {
      return g.isChrdev(this.mode);
    } } }), g.FSNode = lo, g.createPreloadedFile = rl, g.staticInit(), n.FS_createPath = g.createPath, n.FS_createDataFile = g.createDataFile, n.FS_createPreloadedFile = g.createPreloadedFile, n.FS_unlink = g.unlink, n.FS_createLazyFile = g.createLazyFile, n.FS_createDevice = g.createDevice, xl(), gr = n.BindingError = class extends Error {
      constructor(t) {
        super(t), this.name = "BindingError";
      }
    }, Ba = n.InternalError = class extends Error {
      constructor(t) {
        super(t), this.name = "InternalError";
      }
    }, Ul(), kl(), Zl(), $a = n.UnboundTypeError = ef(Error, "UnboundTypeError"), sf(), lf(), n.requestFullscreen = function(t, i) {
      z.requestFullscreen(t, i);
    }, n.requestAnimationFrame = function(t) {
      z.requestAnimationFrame(t);
    }, n.setCanvasSize = function(t, i, o) {
      z.setCanvasSize(t, i, o);
    }, n.pauseMainLoop = function() {
      z.mainLoop.pause();
    }, n.resumeMainLoop = function() {
      z.mainLoop.resume();
    }, n.getUserMedia = function() {
      z.getUserMedia();
    }, n.createContext = function(t, i, o, s) {
      return z.createContext(t, i, o, s);
    }, nt.init();
    for (var Z, xi = 0; xi < 32; ++xi)
      vi.push(new Array(xi));
    var fo = { __cxa_throw: Ve, __syscall_chmod: il, __syscall_fchmod: al, __syscall_fcntl64: sl, __syscall_fstat64: ul, __syscall_ftruncate64: ll, __syscall_getcwd: fl, __syscall_getdents64: cl, __syscall_ioctl: dl, __syscall_lstat64: hl, __syscall_mkdirat: pl, __syscall_newfstatat: ml, __syscall_openat: _l, __syscall_readlinkat: bl, __syscall_renameat: yl, __syscall_stat64: gl, __syscall_symlink: wl, __syscall_unlinkat: vl, _embind_register_bigint: El, _embind_register_bool: Cl, _embind_register_class: tf, _embind_register_class_class_function: rf, _embind_register_class_constructor: nf, _embind_register_class_function: af, _embind_register_class_property: of, _embind_register_emval: ff, _embind_register_enum: df, _embind_register_enum_value: hf, _embind_register_float: mf, _embind_register_function: _f, _embind_register_integer: yf, _embind_register_memory_view: gf, _embind_register_smart_ptr: wf, _embind_register_std_string: vf, _embind_register_std_wstring: Rf, _embind_register_void: Af, _emscripten_fetch_free: If, _emscripten_get_now_is_monotonic: kf, _emval_as: Df, _emval_call: Lf, _emval_call_method: Nf, _emval_call_void_method: Of, _emval_decref: mi, _emval_get_method_caller: Uf, _emval_get_module_property: Wf, _emval_get_property: $f, _emval_incref: Gf, _emval_is_number: Vf, _emval_new_cstring: zf, _emval_run_destructors: Hf, _emval_set_property: Kf, _emval_take_value: Yf, _gmtime_js: Xf, _localtime_js: Qf, _mktime_js: Jf, _mmap_js: ec, _munmap_js: tc, _tzset_js: rc, abort: nc, alBufferData: uc, alDeleteBuffers: lc, alDeleteSources: fc, alGenBuffers: cc, alGenSources: dc, alGetError: hc, alGetSourcei: pc, alGetString: mc, alSourcePause: _c, alSourcePlay: bc, alSourceStop: yc, alSourcef: gc, alSourcei: Ja, alcCloseDevice: wc, alcCreateContext: Ec, alcDestroyContext: xc, alcGetError: Sc, alcGetString: Cc, alcMakeContextCurrent: Tc, alcOpenDevice: Fc, bnb_get_random_value: f, bnb_randombytes_init_if_needed: C, create_video: S, delete_video: R, emscripten_date_now: Rc, emscripten_get_heap_max: Ac, emscripten_get_now: bn, emscripten_is_main_browser_thread: Ic, emscripten_memcpy_big: Pc, emscripten_resize_heap: Dc, emscripten_start_fetch: Bc, environ_get: jc, environ_sizes_get: Uc, exit: qa, fd_close: Wc, fd_fdstat_get: $c, fd_read: Vc, fd_seek: zc, fd_sync: Hc, fd_write: Yc, get_current_hostname: Ne, get_user_id_web: u, getaddrinfo: qc, getentropy: Qc, glActiveTexture: Jc, glAttachShader: ed, glBindBuffer: td, glBindBufferRange: rd, glBindFramebuffer: nd, glBindRenderbuffer: id, glBindTexture: ad, glBindVertexArray: od, glBlendEquation: sd, glBlendFunc: ud, glBlendFuncSeparate: ld, glBlitFramebuffer: fd, glBufferData: cd, glBufferSubData: dd, glClearBufferfv: hd, glColorMask: pd, glCompileShader: md, glCompressedTexImage2D: _d, glCompressedTexImage3D: bd, glCreateProgram: yd, glCreateShader: gd, glDeleteBuffers: wd, glDeleteFramebuffers: vd, glDeleteProgram: Ed, glDeleteRenderbuffers: xd, glDeleteShader: Sd, glDeleteTextures: Cd, glDeleteVertexArrays: Td, glDepthFunc: Fd, glDepthMask: Rd, glDisable: Ad, glDrawArrays: Id, glDrawArraysInstanced: Pd, glDrawBuffers: kd, glDrawElements: Dd, glDrawElementsInstanced: Ld, glEnable: Md, glEnableVertexAttribArray: Bd, glFramebufferRenderbuffer: Nd, glFramebufferTexture2D: Od, glGenBuffers: jd, glGenFramebuffers: Ud, glGenRenderbuffers: Wd, glGenTextures: $d, glGenVertexArrays: Gd, glGenerateMipmap: Vd, glGetError: zd, glGetIntegerv: Kd, glGetProgramInfoLog: Yd, glGetProgramiv: Xd, glGetShaderInfoLog: Zd, glGetShaderiv: qd, glGetUniformLocation: Jd, glInvalidateFramebuffer: eh, glLinkProgram: th, glPixelStorei: rh, glReadPixels: ah, glRenderbufferStorage: oh, glRenderbufferStorageMultisample: sh, glShaderSource: uh, glTexImage2D: lh, glTexImage3D: fh, glTexParameteri: ch, glTexStorage2D: dh, glTexSubImage2D: hh, glTexSubImage3D: ph, glUniform1i: mh, glUniform1ui: _h, glUseProgram: bh, glVertexAttribIPointer: yh, glVertexAttribPointer: gh, glViewport: wh, is_electron: Ce, strftime: uo, strftime_l: Sh, xnnLoadWasmModuleJS: y };
    B();
    var Lt = n._malloc = function() {
      return (Lt = n._malloc = n.asm.malloc).apply(null, arguments);
    }, co = function() {
      return (co = n.asm.__errno_location).apply(null, arguments);
    }, Mt = n._free = function() {
      return (Mt = n._free = n.asm.free).apply(null, arguments);
    }, ho = function() {
      return (ho = n.asm.__getTypeName).apply(null, arguments);
    };
    n.__embind_initialize_bindings = function() {
      return (n.__embind_initialize_bindings = n.asm._embind_initialize_bindings).apply(null, arguments);
    };
    var En = function() {
      return (En = n.asm.htonl).apply(null, arguments);
    }, xn = function() {
      return (xn = n.asm.htons).apply(null, arguments);
    }, po = function() {
      return (po = n.asm.emscripten_builtin_memalign).apply(null, arguments);
    }, mo = function() {
      return (mo = n.asm.ntohs).apply(null, arguments);
    }, _o = function() {
      return (_o = n.asm.setTempRet0).apply(null, arguments);
    }, bo = function() {
      return (bo = n.asm.__cxa_is_pointer_type).apply(null, arguments);
    };
    n.dynCall_jii = function() {
      return (n.dynCall_jii = n.asm.dynCall_jii).apply(null, arguments);
    }, n.dynCall_jiii = function() {
      return (n.dynCall_jiii = n.asm.dynCall_jiii).apply(null, arguments);
    }, n.dynCall_viiij = function() {
      return (n.dynCall_viiij = n.asm.dynCall_viiij).apply(null, arguments);
    }, n.dynCall_viijjiii = function() {
      return (n.dynCall_viijjiii = n.asm.dynCall_viijjiii).apply(null, arguments);
    }, n.dynCall_iiiiji = function() {
      return (n.dynCall_iiiiji = n.asm.dynCall_iiiiji).apply(null, arguments);
    }, n.dynCall_iiiijii = function() {
      return (n.dynCall_iiiijii = n.asm.dynCall_iiiijii).apply(null, arguments);
    }, n.dynCall_iijjj = function() {
      return (n.dynCall_iijjj = n.asm.dynCall_iijjj).apply(null, arguments);
    }, n.dynCall_viij = function() {
      return (n.dynCall_viij = n.asm.dynCall_viij).apply(null, arguments);
    }, n.dynCall_ji = function() {
      return (n.dynCall_ji = n.asm.dynCall_ji).apply(null, arguments);
    }, n.dynCall_iiffj = function() {
      return (n.dynCall_iiffj = n.asm.dynCall_iiffj).apply(null, arguments);
    }, n.dynCall_vijjiii = function() {
      return (n.dynCall_vijjiii = n.asm.dynCall_vijjiii).apply(null, arguments);
    }, n.dynCall_viiiji = function() {
      return (n.dynCall_viiiji = n.asm.dynCall_viiiji).apply(null, arguments);
    }, n.dynCall_viiijii = function() {
      return (n.dynCall_viiijii = n.asm.dynCall_viiijii).apply(null, arguments);
    }, n.dynCall_vij = function() {
      return (n.dynCall_vij = n.asm.dynCall_vij).apply(null, arguments);
    }, n.dynCall_iiiiiij = function() {
      return (n.dynCall_iiiiiij = n.asm.dynCall_iiiiiij).apply(null, arguments);
    }, n.dynCall_viijji = function() {
      return (n.dynCall_viijji = n.asm.dynCall_viijji).apply(null, arguments);
    }, n.dynCall_viiiij = function() {
      return (n.dynCall_viiiij = n.asm.dynCall_viiiij).apply(null, arguments);
    }, n.dynCall_viiiiji = function() {
      return (n.dynCall_viiiiji = n.asm.dynCall_viiiiji).apply(null, arguments);
    }, n.dynCall_iiiji = function() {
      return (n.dynCall_iiiji = n.asm.dynCall_iiiji).apply(null, arguments);
    }, n.dynCall_jijjiii = function() {
      return (n.dynCall_jijjiii = n.asm.dynCall_jijjiii).apply(null, arguments);
    }, n.dynCall_jijiii = function() {
      return (n.dynCall_jijiii = n.asm.dynCall_jijiii).apply(null, arguments);
    }, n.dynCall_jijiiii = function() {
      return (n.dynCall_jijiiii = n.asm.dynCall_jijiiii).apply(null, arguments);
    }, n.dynCall_jijii = function() {
      return (n.dynCall_jijii = n.asm.dynCall_jijii).apply(null, arguments);
    }, n.dynCall_jijiiiiii = function() {
      return (n.dynCall_jijiiiiii = n.asm.dynCall_jijiiiiii).apply(null, arguments);
    }, n.dynCall_jijj = function() {
      return (n.dynCall_jijj = n.asm.dynCall_jijj).apply(null, arguments);
    }, n.dynCall_viji = function() {
      return (n.dynCall_viji = n.asm.dynCall_viji).apply(null, arguments);
    }, n.dynCall_iijijjji = function() {
      return (n.dynCall_iijijjji = n.asm.dynCall_iijijjji).apply(null, arguments);
    }, n.dynCall_iiji = function() {
      return (n.dynCall_iiji = n.asm.dynCall_iiji).apply(null, arguments);
    }, n.dynCall_iiiij = function() {
      return (n.dynCall_iiiij = n.asm.dynCall_iiiij).apply(null, arguments);
    }, n.dynCall_jijij = function() {
      return (n.dynCall_jijij = n.asm.dynCall_jijij).apply(null, arguments);
    }, n.dynCall_iijijji = function() {
      return (n.dynCall_iijijji = n.asm.dynCall_iijijji).apply(null, arguments);
    }, n.dynCall_jiiii = function() {
      return (n.dynCall_jiiii = n.asm.dynCall_jiiii).apply(null, arguments);
    }, n.dynCall_jij = function() {
      return (n.dynCall_jij = n.asm.dynCall_jij).apply(null, arguments);
    }, n.dynCall_jiji = function() {
      return (n.dynCall_jiji = n.asm.dynCall_jiji).apply(null, arguments);
    }, n.dynCall_viiijj = function() {
      return (n.dynCall_viiijj = n.asm.dynCall_viiijj).apply(null, arguments);
    }, n.dynCall_iiij = function() {
      return (n.dynCall_iiij = n.asm.dynCall_iiij).apply(null, arguments);
    }, n.dynCall_iijii = function() {
      return (n.dynCall_iijii = n.asm.dynCall_iijii).apply(null, arguments);
    }, n.dynCall_iiijiji = function() {
      return (n.dynCall_iiijiji = n.asm.dynCall_iiijiji).apply(null, arguments);
    }, n.dynCall_iiijiii = function() {
      return (n.dynCall_iiijiii = n.asm.dynCall_iiijiii).apply(null, arguments);
    }, n.dynCall_viijii = function() {
      return (n.dynCall_viijii = n.asm.dynCall_viijii).apply(null, arguments);
    }, n.dynCall_iiiiij = function() {
      return (n.dynCall_iiiiij = n.asm.dynCall_iiiiij).apply(null, arguments);
    }, n.dynCall_iiiiijj = function() {
      return (n.dynCall_iiiiijj = n.asm.dynCall_iiiiijj).apply(null, arguments);
    }, n.dynCall_iiiiiijj = function() {
      return (n.dynCall_iiiiiijj = n.asm.dynCall_iiiiiijj).apply(null, arguments);
    }, n.dynCall_jjj = function() {
      return (n.dynCall_jjj = n.asm.dynCall_jjj).apply(null, arguments);
    }, n.dynCall_iiiijj = function() {
      return (n.dynCall_iiiijj = n.asm.dynCall_iiiijj).apply(null, arguments);
    }, n.dynCall_viijj = function() {
      return (n.dynCall_viijj = n.asm.dynCall_viijj).apply(null, arguments);
    }, n.dynCall_viiijjj = function() {
      return (n.dynCall_viiijjj = n.asm.dynCall_viiijjj).apply(null, arguments);
    }, n.dynCall_iiijj = function() {
      return (n.dynCall_iiijj = n.asm.dynCall_iiijj).apply(null, arguments);
    }, n.dynCall_viijjj = function() {
      return (n.dynCall_viijjj = n.asm.dynCall_viijjj).apply(null, arguments);
    }, n.___start_em_js = 1334580, n.___stop_em_js = 1337732, n.addRunDependency = mt, n.removeRunDependency = rt, n.FS_createPath = g.createPath, n.FS_createDataFile = g.createDataFile, n.FS_createLazyFile = g.createLazyFile, n.FS_createDevice = g.createDevice, n.FS_unlink = g.unlink, n.stringToNewUTF8 = wr, n.FS_createPreloadedFile = g.createPreloadedFile, n.FS = g, n.GL = te;
    var Sn;
    Ye = function e() {
      Sn || yo(), Sn || (Ye = e);
    };
    function yo() {
      if (Je > 0 || (we(), Je > 0))
        return;
      function e() {
        Sn || (Sn = !0, n.calledRun = !0, !Te && (Ie(), l(n), n.onRuntimeInitialized && n.onRuntimeInitialized(), gt()));
      }
      n.setStatus ? (n.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          n.setStatus("");
        }, 1), e();
      }, 1)) : e();
    }
    if (n.preInit)
      for (typeof n.preInit == "function" && (n.preInit = [n.preInit]); n.preInit.length > 0; )
        n.preInit.pop()();
    return yo(), eo = function() {
    }, a.ready;
  };
})();
const yp = bp, gp = () => {
  const r = document.createElement("canvas");
  return r.style.maxWidth = "100%", r.style.objectFit = "cover", r;
}, wp = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11])), vp = wp, Ep = (r) => (r !== "" && !r.endsWith("/") && (r += "/"), (a) => r + a), xp = (r) => (a) => r[a], Sp = async (r, a = {}) => {
  if (await vp())
    a.info?.('The platform supports SIMD. Going to use "BanubaSDK.simd.wasm"');
  else
    return a.info?.('The platform does not support SIMD. Using "BanubaSDK.wasm"'), r;
  const l = r("BanubaSDK.simd.wasm");
  return l ? await fetch(l, { method: "HEAD" }).then((v) => v.ok) ? (v) => {
    const [w, m] = v.split(".");
    if (m !== "wasm")
      return r(v);
    const D = [w, "simd", m].join(".");
    return r(D);
  } : (a.warn?.(
    `Unable to fetch "BanubaSDK.simd.wasm" from the "${l}". Using "BanubaSDK.wasm" as a fallback`
  ), r) : (a.warn?.(
    '"BanubaSDK.simd.wasm" is missing in the "locateFile" option. Using "BanubaSDK.wasm" as a fallback'
  ), r);
}, Cp = (() => {
  try {
    return new URL(".", self.location).toString();
  } catch {
    return "";
  }
})(), Tp = async (r, a) => (typeof r > "u" && (r = Cp), typeof r == "string" && (r = Ep(r)), typeof r == "object" && (r = xp(r)), r = await Sp(r, a), r);
var Gr = /* @__PURE__ */ ((r) => (r.ERROR = "error", r.WARNING = "warn", r.INFO = "info", r.DEBUG = "debug", r))(Gr || {});
function Fp(r) {
  const a = Object.keys(Gr).reverse().find((l) => typeof r[Gr[l]] == "function") ?? "ERROR", n = (l) => {
    for (const v in Gr)
      if (l.includes(v)) {
        const w = r[Gr[v]];
        if (typeof w == "function") {
          w.call(r, l);
          return;
        }
      }
    const _ = r.debug;
    typeof _ == "function" && _.call(r, l);
  };
  return {
    logLevel: a,
    print: n,
    printErr: n
  };
}
const Rp = ["isAliasOf", "clone", "delete", "isDeleted", "deleteLater"], Ap = ["size", "get", "set", "push_back"], Ws = (r) => {
  if (r == null || typeof r != "function")
    return !1;
  const { prototype: a } = r;
  return a ? Rp.every((n) => n in a) : !1;
}, $s = (r) => r == null || typeof r != "object" ? !1 : Ws(r.constructor), ko = (r) => $s(r) && Ap.every((a) => a in r), Ip = (r, a) => new Proxy(r, {
  // instance methods
  get(l, _) {
    const v = l[_];
    return typeof v == "function" ? Gs(v, a) : v;
  }
}), Gs = (r, a) => new Proxy(r, {
  apply(l, _, v) {
    try {
      const w = l.apply(_, v);
      return $s(w) ? Ip(w, a) : w;
    } catch (w) {
      throw typeof w == "number" && (w = new Error(a(w))), w;
    }
  }
}), Pp = (r, a) => new Proxy(r, {
  construct(l, _) {
    try {
      return new l(..._);
    } catch (v) {
      throw typeof v == "number" && (v = new Error(a(v))), v;
    }
  },
  // static methods
  get(l, _) {
    const v = l[_];
    return typeof v == "function" ? Gs(v, a) : v;
  }
}), kp = (r, a) => {
  for (const [n, l] of Object.entries(r))
    Ws(l) && Object.defineProperty(r, n, { value: Pp(l, a) });
}, Dp = "recognizer_features_update";
async function Lp({
  clientToken: r,
  locateFile: a,
  canvas: n = gp(),
  logger: l = { warn: console.warn, error: console.error },
  ..._
}) {
  const v = await Tp(a, l), { logLevel: w, print: m, printErr: D } = Fp(l), L = await new Promise(
    (O, J) => yp({
      locateFile: v,
      /**
       * Do *not* pass `canvas` here, it *must* be set later to workaround Emscripten memory leaks
       */
      // canvas,
      print: m,
      printErr: D,
      onAbort: (ae) => {
        ae instanceof WebAssembly.CompileError && J(
          new Error(
            `Failed to compile "BanubaSDK.wasm": the file "${v(
              "BanubaSDK.wasm"
            )}" is invalid. This error is usually caused by misconfigured "locateFile" option, see https://docs.banuba.com/face-ar-sdk-v1/generated/typedoc/modules.html#SDKOptions. Original Error: ` + ae
          )
        );
      },
      ..._
    }).then(O, J)
  );
  return kp(L, (O) => L.getExceptionMessage(O)), L.UtilityManager.initialize(new L.VectorString(), r), L.UtilityManager.setLogLevel(L.SeverityLevel[w]), L.setCanvasSize = (O, J) => {
    Object.assign(n, { width: O, height: J });
  }, L.createContext(n, !0, !0, {
    alpha: !0,
    antialias: !1,
    depth: !1,
    // desynchronized: true,
    // powerPreference: "high-performance",
    premultipliedAlpha: !1,
    preserveDrawingBuffer: !0,
    stencil: !1
  }), L.canvas = n, Vs(L.ctx), L;
}
function Vs(r) {
  const a = ["EXT_color_buffer_half_float", "EXT_color_buffer_float"];
  for (const n of a)
    r.getExtension(n);
}
var ht = /* @__PURE__ */ ((r) => (r[r.Running = 0] = "Running", r[r.Idle = 1] = "Idle", r[r.Paused = 2] = "Paused", r))(ht || {}), zs = { exports: {} }, Pi = { exports: {} }, er = {}, Qr = {};
Qr.byteLength = Np;
Qr.toByteArray = jp;
Qr.fromByteArray = $p;
var Ot = [], Ft = [], Mp = typeof Uint8Array < "u" ? Uint8Array : Array, ki = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Sr = 0, Bp = ki.length; Sr < Bp; ++Sr)
  Ot[Sr] = ki[Sr], Ft[ki.charCodeAt(Sr)] = Sr;
Ft["-".charCodeAt(0)] = 62;
Ft["_".charCodeAt(0)] = 63;
function Hs(r) {
  var a = r.length;
  if (a % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = r.indexOf("=");
  n === -1 && (n = a);
  var l = n === a ? 0 : 4 - n % 4;
  return [n, l];
}
function Np(r) {
  var a = Hs(r), n = a[0], l = a[1];
  return (n + l) * 3 / 4 - l;
}
function Op(r, a, n) {
  return (a + n) * 3 / 4 - n;
}
function jp(r) {
  var a, n = Hs(r), l = n[0], _ = n[1], v = new Mp(Op(r, l, _)), w = 0, m = _ > 0 ? l - 4 : l, D;
  for (D = 0; D < m; D += 4)
    a = Ft[r.charCodeAt(D)] << 18 | Ft[r.charCodeAt(D + 1)] << 12 | Ft[r.charCodeAt(D + 2)] << 6 | Ft[r.charCodeAt(D + 3)], v[w++] = a >> 16 & 255, v[w++] = a >> 8 & 255, v[w++] = a & 255;
  return _ === 2 && (a = Ft[r.charCodeAt(D)] << 2 | Ft[r.charCodeAt(D + 1)] >> 4, v[w++] = a & 255), _ === 1 && (a = Ft[r.charCodeAt(D)] << 10 | Ft[r.charCodeAt(D + 1)] << 4 | Ft[r.charCodeAt(D + 2)] >> 2, v[w++] = a >> 8 & 255, v[w++] = a & 255), v;
}
function Up(r) {
  return Ot[r >> 18 & 63] + Ot[r >> 12 & 63] + Ot[r >> 6 & 63] + Ot[r & 63];
}
function Wp(r, a, n) {
  for (var l, _ = [], v = a; v < n; v += 3)
    l = (r[v] << 16 & 16711680) + (r[v + 1] << 8 & 65280) + (r[v + 2] & 255), _.push(Up(l));
  return _.join("");
}
function $p(r) {
  for (var a, n = r.length, l = n % 3, _ = [], v = 16383, w = 0, m = n - l; w < m; w += v)
    _.push(Wp(r, w, w + v > m ? m : w + v));
  return l === 1 ? (a = r[n - 1], _.push(
    Ot[a >> 2] + Ot[a << 4 & 63] + "=="
  )) : l === 2 && (a = (r[n - 2] << 8) + r[n - 1], _.push(
    Ot[a >> 10] + Ot[a >> 4 & 63] + Ot[a << 2 & 63] + "="
  )), _.join("");
}
var Vn = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Vn.read = function(r, a, n, l, _) {
  var v, w, m = _ * 8 - l - 1, D = (1 << m) - 1, L = D >> 1, O = -7, J = n ? _ - 1 : 0, ae = n ? -1 : 1, q = r[a + J];
  for (J += ae, v = q & (1 << -O) - 1, q >>= -O, O += m; O > 0; v = v * 256 + r[a + J], J += ae, O -= 8)
    ;
  for (w = v & (1 << -O) - 1, v >>= -O, O += l; O > 0; w = w * 256 + r[a + J], J += ae, O -= 8)
    ;
  if (v === 0)
    v = 1 - L;
  else {
    if (v === D)
      return w ? NaN : (q ? -1 : 1) * (1 / 0);
    w = w + Math.pow(2, l), v = v - L;
  }
  return (q ? -1 : 1) * w * Math.pow(2, v - l);
};
Vn.write = function(r, a, n, l, _, v) {
  var w, m, D, L = v * 8 - _ - 1, O = (1 << L) - 1, J = O >> 1, ae = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = l ? 0 : v - 1, K = l ? 1 : -1, pe = a < 0 || a === 0 && 1 / a < 0 ? 1 : 0;
  for (a = Math.abs(a), isNaN(a) || a === 1 / 0 ? (m = isNaN(a) ? 1 : 0, w = O) : (w = Math.floor(Math.log(a) / Math.LN2), a * (D = Math.pow(2, -w)) < 1 && (w--, D *= 2), w + J >= 1 ? a += ae / D : a += ae * Math.pow(2, 1 - J), a * D >= 2 && (w++, D /= 2), w + J >= O ? (m = 0, w = O) : w + J >= 1 ? (m = (a * D - 1) * Math.pow(2, _), w = w + J) : (m = a * Math.pow(2, J - 1) * Math.pow(2, _), w = 0)); _ >= 8; r[n + q] = m & 255, q += K, m /= 256, _ -= 8)
    ;
  for (w = w << _ | m, L += _; L > 0; r[n + q] = w & 255, q += K, w /= 256, L -= 8)
    ;
  r[n + q - K] |= pe * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  const a = Qr, n = Vn, l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = m, r.SlowBuffer = ee, r.INSPECT_MAX_BYTES = 50;
  const _ = 2147483647;
  r.kMaxLength = _, m.TYPED_ARRAY_SUPPORT = v(), !m.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function v() {
    try {
      const y = new Uint8Array(1), u = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(u, Uint8Array.prototype), Object.setPrototypeOf(y, u), y.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(m.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (m.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(m.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (m.isBuffer(this))
        return this.byteOffset;
    }
  });
  function w(y) {
    if (y > _)
      throw new RangeError('The value "' + y + '" is invalid for option "size"');
    const u = new Uint8Array(y);
    return Object.setPrototypeOf(u, m.prototype), u;
  }
  function m(y, u, f) {
    if (typeof y == "number") {
      if (typeof u == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return J(y);
    }
    return D(y, u, f);
  }
  m.poolSize = 8192;
  function D(y, u, f) {
    if (typeof y == "string")
      return ae(y, u);
    if (ArrayBuffer.isView(y))
      return K(y);
    if (y == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
      );
    if (V(y, ArrayBuffer) || y && V(y.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (V(y, SharedArrayBuffer) || y && V(y.buffer, SharedArrayBuffer)))
      return pe(y, u, f);
    if (typeof y == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const C = y.valueOf && y.valueOf();
    if (C != null && C !== y)
      return m.from(C, u, f);
    const k = he(y);
    if (k)
      return k;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof y[Symbol.toPrimitive] == "function")
      return m.from(y[Symbol.toPrimitive]("string"), u, f);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
    );
  }
  m.from = function(y, u, f) {
    return D(y, u, f);
  }, Object.setPrototypeOf(m.prototype, Uint8Array.prototype), Object.setPrototypeOf(m, Uint8Array);
  function L(y) {
    if (typeof y != "number")
      throw new TypeError('"size" argument must be of type number');
    if (y < 0)
      throw new RangeError('The value "' + y + '" is invalid for option "size"');
  }
  function O(y, u, f) {
    return L(y), y <= 0 ? w(y) : u !== void 0 ? typeof f == "string" ? w(y).fill(u, f) : w(y).fill(u) : w(y);
  }
  m.alloc = function(y, u, f) {
    return O(y, u, f);
  };
  function J(y) {
    return L(y), w(y < 0 ? 0 : ce(y) | 0);
  }
  m.allocUnsafe = function(y) {
    return J(y);
  }, m.allocUnsafeSlow = function(y) {
    return J(y);
  };
  function ae(y, u) {
    if ((typeof u != "string" || u === "") && (u = "utf8"), !m.isEncoding(u))
      throw new TypeError("Unknown encoding: " + u);
    const f = Te(y, u) | 0;
    let C = w(f);
    const k = C.write(y, u);
    return k !== f && (C = C.slice(0, k)), C;
  }
  function q(y) {
    const u = y.length < 0 ? 0 : ce(y.length) | 0, f = w(u);
    for (let C = 0; C < u; C += 1)
      f[C] = y[C] & 255;
    return f;
  }
  function K(y) {
    if (V(y, Uint8Array)) {
      const u = new Uint8Array(y);
      return pe(u.buffer, u.byteOffset, u.byteLength);
    }
    return q(y);
  }
  function pe(y, u, f) {
    if (u < 0 || y.byteLength < u)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (y.byteLength < u + (f || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let C;
    return u === void 0 && f === void 0 ? C = new Uint8Array(y) : f === void 0 ? C = new Uint8Array(y, u) : C = new Uint8Array(y, u, f), Object.setPrototypeOf(C, m.prototype), C;
  }
  function he(y) {
    if (m.isBuffer(y)) {
      const u = ce(y.length) | 0, f = w(u);
      return f.length === 0 || y.copy(f, 0, 0, u), f;
    }
    if (y.length !== void 0)
      return typeof y.length != "number" || Ce(y.length) ? w(0) : q(y);
    if (y.type === "Buffer" && Array.isArray(y.data))
      return q(y.data);
  }
  function ce(y) {
    if (y >= _)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + _.toString(16) + " bytes");
    return y | 0;
  }
  function ee(y) {
    return +y != y && (y = 0), m.alloc(+y);
  }
  m.isBuffer = function(u) {
    return u != null && u._isBuffer === !0 && u !== m.prototype;
  }, m.compare = function(u, f) {
    if (V(u, Uint8Array) && (u = m.from(u, u.offset, u.byteLength)), V(f, Uint8Array) && (f = m.from(f, f.offset, f.byteLength)), !m.isBuffer(u) || !m.isBuffer(f))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (u === f)
      return 0;
    let C = u.length, k = f.length;
    for (let $ = 0, Y = Math.min(C, k); $ < Y; ++$)
      if (u[$] !== f[$]) {
        C = u[$], k = f[$];
        break;
      }
    return C < k ? -1 : k < C ? 1 : 0;
  }, m.isEncoding = function(u) {
    switch (String(u).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, m.concat = function(u, f) {
    if (!Array.isArray(u))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (u.length === 0)
      return m.alloc(0);
    let C;
    if (f === void 0)
      for (f = 0, C = 0; C < u.length; ++C)
        f += u[C].length;
    const k = m.allocUnsafe(f);
    let $ = 0;
    for (C = 0; C < u.length; ++C) {
      let Y = u[C];
      if (V(Y, Uint8Array))
        $ + Y.length > k.length ? (m.isBuffer(Y) || (Y = m.from(Y)), Y.copy(k, $)) : Uint8Array.prototype.set.call(
          k,
          Y,
          $
        );
      else if (m.isBuffer(Y))
        Y.copy(k, $);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      $ += Y.length;
    }
    return k;
  };
  function Te(y, u) {
    if (m.isBuffer(y))
      return y.length;
    if (ArrayBuffer.isView(y) || V(y, ArrayBuffer))
      return y.byteLength;
    if (typeof y != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof y
      );
    const f = y.length, C = arguments.length > 2 && arguments[2] === !0;
    if (!C && f === 0)
      return 0;
    let k = !1;
    for (; ; )
      switch (u) {
        case "ascii":
        case "latin1":
        case "binary":
          return f;
        case "utf8":
        case "utf-8":
          return d(y).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return f * 2;
        case "hex":
          return f >>> 1;
        case "base64":
          return B(y).length;
        default:
          if (k)
            return C ? -1 : d(y).length;
          u = ("" + u).toLowerCase(), k = !0;
      }
  }
  m.byteLength = Te;
  function Oe(y, u, f) {
    let C = !1;
    if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((f === void 0 || f > this.length) && (f = this.length), f <= 0) || (f >>>= 0, u >>>= 0, f <= u))
      return "";
    for (y || (y = "utf8"); ; )
      switch (y) {
        case "hex":
          return it(this, u, f);
        case "utf8":
        case "utf-8":
          return ke(this, u, f);
        case "ascii":
          return ze(this, u, f);
        case "latin1":
        case "binary":
          return Be(this, u, f);
        case "base64":
          return De(this, u, f);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, u, f);
        default:
          if (C)
            throw new TypeError("Unknown encoding: " + y);
          y = (y + "").toLowerCase(), C = !0;
      }
  }
  m.prototype._isBuffer = !0;
  function me(y, u, f) {
    const C = y[u];
    y[u] = y[f], y[f] = C;
  }
  m.prototype.swap16 = function() {
    const u = this.length;
    if (u % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let f = 0; f < u; f += 2)
      me(this, f, f + 1);
    return this;
  }, m.prototype.swap32 = function() {
    const u = this.length;
    if (u % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let f = 0; f < u; f += 4)
      me(this, f, f + 3), me(this, f + 1, f + 2);
    return this;
  }, m.prototype.swap64 = function() {
    const u = this.length;
    if (u % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let f = 0; f < u; f += 8)
      me(this, f, f + 7), me(this, f + 1, f + 6), me(this, f + 2, f + 5), me(this, f + 3, f + 4);
    return this;
  }, m.prototype.toString = function() {
    const u = this.length;
    return u === 0 ? "" : arguments.length === 0 ? ke(this, 0, u) : Oe.apply(this, arguments);
  }, m.prototype.toLocaleString = m.prototype.toString, m.prototype.equals = function(u) {
    if (!m.isBuffer(u))
      throw new TypeError("Argument must be a Buffer");
    return this === u ? !0 : m.compare(this, u) === 0;
  }, m.prototype.inspect = function() {
    let u = "";
    const f = r.INSPECT_MAX_BYTES;
    return u = this.toString("hex", 0, f).replace(/(.{2})/g, "$1 ").trim(), this.length > f && (u += " ... "), "<Buffer " + u + ">";
  }, l && (m.prototype[l] = m.prototype.inspect), m.prototype.compare = function(u, f, C, k, $) {
    if (V(u, Uint8Array) && (u = m.from(u, u.offset, u.byteLength)), !m.isBuffer(u))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u
      );
    if (f === void 0 && (f = 0), C === void 0 && (C = u ? u.length : 0), k === void 0 && (k = 0), $ === void 0 && ($ = this.length), f < 0 || C > u.length || k < 0 || $ > this.length)
      throw new RangeError("out of range index");
    if (k >= $ && f >= C)
      return 0;
    if (k >= $)
      return -1;
    if (f >= C)
      return 1;
    if (f >>>= 0, C >>>= 0, k >>>= 0, $ >>>= 0, this === u)
      return 0;
    let Y = $ - k, Fe = C - f;
    const Ve = Math.min(Y, Fe), _e = this.slice(k, $), Ge = u.slice(f, C);
    for (let Me = 0; Me < Ve; ++Me)
      if (_e[Me] !== Ge[Me]) {
        Y = _e[Me], Fe = Ge[Me];
        break;
      }
    return Y < Fe ? -1 : Fe < Y ? 1 : 0;
  };
  function Ee(y, u, f, C, k) {
    if (y.length === 0)
      return -1;
    if (typeof f == "string" ? (C = f, f = 0) : f > 2147483647 ? f = 2147483647 : f < -2147483648 && (f = -2147483648), f = +f, Ce(f) && (f = k ? 0 : y.length - 1), f < 0 && (f = y.length + f), f >= y.length) {
      if (k)
        return -1;
      f = y.length - 1;
    } else if (f < 0)
      if (k)
        f = 0;
      else
        return -1;
    if (typeof u == "string" && (u = m.from(u, C)), m.isBuffer(u))
      return u.length === 0 ? -1 : de(y, u, f, C, k);
    if (typeof u == "number")
      return u = u & 255, typeof Uint8Array.prototype.indexOf == "function" ? k ? Uint8Array.prototype.indexOf.call(y, u, f) : Uint8Array.prototype.lastIndexOf.call(y, u, f) : de(y, [u], f, C, k);
    throw new TypeError("val must be string, number or Buffer");
  }
  function de(y, u, f, C, k) {
    let $ = 1, Y = y.length, Fe = u.length;
    if (C !== void 0 && (C = String(C).toLowerCase(), C === "ucs2" || C === "ucs-2" || C === "utf16le" || C === "utf-16le")) {
      if (y.length < 2 || u.length < 2)
        return -1;
      $ = 2, Y /= 2, Fe /= 2, f /= 2;
    }
    function Ve(Ge, Me) {
      return $ === 1 ? Ge[Me] : Ge.readUInt16BE(Me * $);
    }
    let _e;
    if (k) {
      let Ge = -1;
      for (_e = f; _e < Y; _e++)
        if (Ve(y, _e) === Ve(u, Ge === -1 ? 0 : _e - Ge)) {
          if (Ge === -1 && (Ge = _e), _e - Ge + 1 === Fe)
            return Ge * $;
        } else
          Ge !== -1 && (_e -= _e - Ge), Ge = -1;
    } else
      for (f + Fe > Y && (f = Y - Fe), _e = f; _e >= 0; _e--) {
        let Ge = !0;
        for (let Me = 0; Me < Fe; Me++)
          if (Ve(y, _e + Me) !== Ve(u, Me)) {
            Ge = !1;
            break;
          }
        if (Ge)
          return _e;
      }
    return -1;
  }
  m.prototype.includes = function(u, f, C) {
    return this.indexOf(u, f, C) !== -1;
  }, m.prototype.indexOf = function(u, f, C) {
    return Ee(this, u, f, C, !0);
  }, m.prototype.lastIndexOf = function(u, f, C) {
    return Ee(this, u, f, C, !1);
  };
  function Re(y, u, f, C) {
    f = Number(f) || 0;
    const k = y.length - f;
    C ? (C = Number(C), C > k && (C = k)) : C = k;
    const $ = u.length;
    C > $ / 2 && (C = $ / 2);
    let Y;
    for (Y = 0; Y < C; ++Y) {
      const Fe = parseInt(u.substr(Y * 2, 2), 16);
      if (Ce(Fe))
        return Y;
      y[f + Y] = Fe;
    }
    return Y;
  }
  function ye(y, u, f, C) {
    return N(d(u, y.length - f), y, f, C);
  }
  function I(y, u, f, C) {
    return N(p(u), y, f, C);
  }
  function X(y, u, f, C) {
    return N(B(u), y, f, C);
  }
  function je(y, u, f, C) {
    return N(T(u, y.length - f), y, f, C);
  }
  m.prototype.write = function(u, f, C, k) {
    if (f === void 0)
      k = "utf8", C = this.length, f = 0;
    else if (C === void 0 && typeof f == "string")
      k = f, C = this.length, f = 0;
    else if (isFinite(f))
      f = f >>> 0, isFinite(C) ? (C = C >>> 0, k === void 0 && (k = "utf8")) : (k = C, C = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const $ = this.length - f;
    if ((C === void 0 || C > $) && (C = $), u.length > 0 && (C < 0 || f < 0) || f > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    k || (k = "utf8");
    let Y = !1;
    for (; ; )
      switch (k) {
        case "hex":
          return Re(this, u, f, C);
        case "utf8":
        case "utf-8":
          return ye(this, u, f, C);
        case "ascii":
        case "latin1":
        case "binary":
          return I(this, u, f, C);
        case "base64":
          return X(this, u, f, C);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return je(this, u, f, C);
        default:
          if (Y)
            throw new TypeError("Unknown encoding: " + k);
          k = ("" + k).toLowerCase(), Y = !0;
      }
  }, m.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function De(y, u, f) {
    return u === 0 && f === y.length ? a.fromByteArray(y) : a.fromByteArray(y.slice(u, f));
  }
  function ke(y, u, f) {
    f = Math.min(y.length, f);
    const C = [];
    let k = u;
    for (; k < f; ) {
      const $ = y[k];
      let Y = null, Fe = $ > 239 ? 4 : $ > 223 ? 3 : $ > 191 ? 2 : 1;
      if (k + Fe <= f) {
        let Ve, _e, Ge, Me;
        switch (Fe) {
          case 1:
            $ < 128 && (Y = $);
            break;
          case 2:
            Ve = y[k + 1], (Ve & 192) === 128 && (Me = ($ & 31) << 6 | Ve & 63, Me > 127 && (Y = Me));
            break;
          case 3:
            Ve = y[k + 1], _e = y[k + 2], (Ve & 192) === 128 && (_e & 192) === 128 && (Me = ($ & 15) << 12 | (Ve & 63) << 6 | _e & 63, Me > 2047 && (Me < 55296 || Me > 57343) && (Y = Me));
            break;
          case 4:
            Ve = y[k + 1], _e = y[k + 2], Ge = y[k + 3], (Ve & 192) === 128 && (_e & 192) === 128 && (Ge & 192) === 128 && (Me = ($ & 15) << 18 | (Ve & 63) << 12 | (_e & 63) << 6 | Ge & 63, Me > 65535 && Me < 1114112 && (Y = Me));
        }
      }
      Y === null ? (Y = 65533, Fe = 1) : Y > 65535 && (Y -= 65536, C.push(Y >>> 10 & 1023 | 55296), Y = 56320 | Y & 1023), C.push(Y), k += Fe;
    }
    return $e(C);
  }
  const ge = 4096;
  function $e(y) {
    const u = y.length;
    if (u <= ge)
      return String.fromCharCode.apply(String, y);
    let f = "", C = 0;
    for (; C < u; )
      f += String.fromCharCode.apply(
        String,
        y.slice(C, C += ge)
      );
    return f;
  }
  function ze(y, u, f) {
    let C = "";
    f = Math.min(y.length, f);
    for (let k = u; k < f; ++k)
      C += String.fromCharCode(y[k] & 127);
    return C;
  }
  function Be(y, u, f) {
    let C = "";
    f = Math.min(y.length, f);
    for (let k = u; k < f; ++k)
      C += String.fromCharCode(y[k]);
    return C;
  }
  function it(y, u, f) {
    const C = y.length;
    (!u || u < 0) && (u = 0), (!f || f < 0 || f > C) && (f = C);
    let k = "";
    for (let $ = u; $ < f; ++$)
      k += Ne[y[$]];
    return k;
  }
  function ie(y, u, f) {
    const C = y.slice(u, f);
    let k = "";
    for (let $ = 0; $ < C.length - 1; $ += 2)
      k += String.fromCharCode(C[$] + C[$ + 1] * 256);
    return k;
  }
  m.prototype.slice = function(u, f) {
    const C = this.length;
    u = ~~u, f = f === void 0 ? C : ~~f, u < 0 ? (u += C, u < 0 && (u = 0)) : u > C && (u = C), f < 0 ? (f += C, f < 0 && (f = 0)) : f > C && (f = C), f < u && (f = u);
    const k = this.subarray(u, f);
    return Object.setPrototypeOf(k, m.prototype), k;
  };
  function we(y, u, f) {
    if (y % 1 !== 0 || y < 0)
      throw new RangeError("offset is not uint");
    if (y + u > f)
      throw new RangeError("Trying to access beyond buffer length");
  }
  m.prototype.readUintLE = m.prototype.readUIntLE = function(u, f, C) {
    u = u >>> 0, f = f >>> 0, C || we(u, f, this.length);
    let k = this[u], $ = 1, Y = 0;
    for (; ++Y < f && ($ *= 256); )
      k += this[u + Y] * $;
    return k;
  }, m.prototype.readUintBE = m.prototype.readUIntBE = function(u, f, C) {
    u = u >>> 0, f = f >>> 0, C || we(u, f, this.length);
    let k = this[u + --f], $ = 1;
    for (; f > 0 && ($ *= 256); )
      k += this[u + --f] * $;
    return k;
  }, m.prototype.readUint8 = m.prototype.readUInt8 = function(u, f) {
    return u = u >>> 0, f || we(u, 1, this.length), this[u];
  }, m.prototype.readUint16LE = m.prototype.readUInt16LE = function(u, f) {
    return u = u >>> 0, f || we(u, 2, this.length), this[u] | this[u + 1] << 8;
  }, m.prototype.readUint16BE = m.prototype.readUInt16BE = function(u, f) {
    return u = u >>> 0, f || we(u, 2, this.length), this[u] << 8 | this[u + 1];
  }, m.prototype.readUint32LE = m.prototype.readUInt32LE = function(u, f) {
    return u = u >>> 0, f || we(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216;
  }, m.prototype.readUint32BE = m.prototype.readUInt32BE = function(u, f) {
    return u = u >>> 0, f || we(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
  }, m.prototype.readBigUInt64LE = S(function(u) {
    u = u >>> 0, M(u, "offset");
    const f = this[u], C = this[u + 7];
    (f === void 0 || C === void 0) && j(u, this.length - 8);
    const k = f + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24, $ = this[++u] + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + C * 2 ** 24;
    return BigInt(k) + (BigInt($) << BigInt(32));
  }), m.prototype.readBigUInt64BE = S(function(u) {
    u = u >>> 0, M(u, "offset");
    const f = this[u], C = this[u + 7];
    (f === void 0 || C === void 0) && j(u, this.length - 8);
    const k = f * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u], $ = this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + C;
    return (BigInt(k) << BigInt(32)) + BigInt($);
  }), m.prototype.readIntLE = function(u, f, C) {
    u = u >>> 0, f = f >>> 0, C || we(u, f, this.length);
    let k = this[u], $ = 1, Y = 0;
    for (; ++Y < f && ($ *= 256); )
      k += this[u + Y] * $;
    return $ *= 128, k >= $ && (k -= Math.pow(2, 8 * f)), k;
  }, m.prototype.readIntBE = function(u, f, C) {
    u = u >>> 0, f = f >>> 0, C || we(u, f, this.length);
    let k = f, $ = 1, Y = this[u + --k];
    for (; k > 0 && ($ *= 256); )
      Y += this[u + --k] * $;
    return $ *= 128, Y >= $ && (Y -= Math.pow(2, 8 * f)), Y;
  }, m.prototype.readInt8 = function(u, f) {
    return u = u >>> 0, f || we(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u];
  }, m.prototype.readInt16LE = function(u, f) {
    u = u >>> 0, f || we(u, 2, this.length);
    const C = this[u] | this[u + 1] << 8;
    return C & 32768 ? C | 4294901760 : C;
  }, m.prototype.readInt16BE = function(u, f) {
    u = u >>> 0, f || we(u, 2, this.length);
    const C = this[u + 1] | this[u] << 8;
    return C & 32768 ? C | 4294901760 : C;
  }, m.prototype.readInt32LE = function(u, f) {
    return u = u >>> 0, f || we(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
  }, m.prototype.readInt32BE = function(u, f) {
    return u = u >>> 0, f || we(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
  }, m.prototype.readBigInt64LE = S(function(u) {
    u = u >>> 0, M(u, "offset");
    const f = this[u], C = this[u + 7];
    (f === void 0 || C === void 0) && j(u, this.length - 8);
    const k = this[u + 4] + this[u + 5] * 2 ** 8 + this[u + 6] * 2 ** 16 + (C << 24);
    return (BigInt(k) << BigInt(32)) + BigInt(f + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24);
  }), m.prototype.readBigInt64BE = S(function(u) {
    u = u >>> 0, M(u, "offset");
    const f = this[u], C = this[u + 7];
    (f === void 0 || C === void 0) && j(u, this.length - 8);
    const k = (f << 24) + // Overflow
    this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u];
    return (BigInt(k) << BigInt(32)) + BigInt(this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + C);
  }), m.prototype.readFloatLE = function(u, f) {
    return u = u >>> 0, f || we(u, 4, this.length), n.read(this, u, !0, 23, 4);
  }, m.prototype.readFloatBE = function(u, f) {
    return u = u >>> 0, f || we(u, 4, this.length), n.read(this, u, !1, 23, 4);
  }, m.prototype.readDoubleLE = function(u, f) {
    return u = u >>> 0, f || we(u, 8, this.length), n.read(this, u, !0, 52, 8);
  }, m.prototype.readDoubleBE = function(u, f) {
    return u = u >>> 0, f || we(u, 8, this.length), n.read(this, u, !1, 52, 8);
  };
  function Ie(y, u, f, C, k, $) {
    if (!m.isBuffer(y))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (u > k || u < $)
      throw new RangeError('"value" argument is out of bounds');
    if (f + C > y.length)
      throw new RangeError("Index out of range");
  }
  m.prototype.writeUintLE = m.prototype.writeUIntLE = function(u, f, C, k) {
    if (u = +u, f = f >>> 0, C = C >>> 0, !k) {
      const Fe = Math.pow(2, 8 * C) - 1;
      Ie(this, u, f, C, Fe, 0);
    }
    let $ = 1, Y = 0;
    for (this[f] = u & 255; ++Y < C && ($ *= 256); )
      this[f + Y] = u / $ & 255;
    return f + C;
  }, m.prototype.writeUintBE = m.prototype.writeUIntBE = function(u, f, C, k) {
    if (u = +u, f = f >>> 0, C = C >>> 0, !k) {
      const Fe = Math.pow(2, 8 * C) - 1;
      Ie(this, u, f, C, Fe, 0);
    }
    let $ = C - 1, Y = 1;
    for (this[f + $] = u & 255; --$ >= 0 && (Y *= 256); )
      this[f + $] = u / Y & 255;
    return f + C;
  }, m.prototype.writeUint8 = m.prototype.writeUInt8 = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 1, 255, 0), this[f] = u & 255, f + 1;
  }, m.prototype.writeUint16LE = m.prototype.writeUInt16LE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 2, 65535, 0), this[f] = u & 255, this[f + 1] = u >>> 8, f + 2;
  }, m.prototype.writeUint16BE = m.prototype.writeUInt16BE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 2, 65535, 0), this[f] = u >>> 8, this[f + 1] = u & 255, f + 2;
  }, m.prototype.writeUint32LE = m.prototype.writeUInt32LE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 4, 4294967295, 0), this[f + 3] = u >>> 24, this[f + 2] = u >>> 16, this[f + 1] = u >>> 8, this[f] = u & 255, f + 4;
  }, m.prototype.writeUint32BE = m.prototype.writeUInt32BE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 4, 4294967295, 0), this[f] = u >>> 24, this[f + 1] = u >>> 16, this[f + 2] = u >>> 8, this[f + 3] = u & 255, f + 4;
  };
  function gt(y, u, f, C, k) {
    qe(u, C, k, y, f, 7);
    let $ = Number(u & BigInt(4294967295));
    y[f++] = $, $ = $ >> 8, y[f++] = $, $ = $ >> 8, y[f++] = $, $ = $ >> 8, y[f++] = $;
    let Y = Number(u >> BigInt(32) & BigInt(4294967295));
    return y[f++] = Y, Y = Y >> 8, y[f++] = Y, Y = Y >> 8, y[f++] = Y, Y = Y >> 8, y[f++] = Y, f;
  }
  function wt(y, u, f, C, k) {
    qe(u, C, k, y, f, 7);
    let $ = Number(u & BigInt(4294967295));
    y[f + 7] = $, $ = $ >> 8, y[f + 6] = $, $ = $ >> 8, y[f + 5] = $, $ = $ >> 8, y[f + 4] = $;
    let Y = Number(u >> BigInt(32) & BigInt(4294967295));
    return y[f + 3] = Y, Y = Y >> 8, y[f + 2] = Y, Y = Y >> 8, y[f + 1] = Y, Y = Y >> 8, y[f] = Y, f + 8;
  }
  m.prototype.writeBigUInt64LE = S(function(u, f = 0) {
    return gt(this, u, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), m.prototype.writeBigUInt64BE = S(function(u, f = 0) {
    return wt(this, u, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), m.prototype.writeIntLE = function(u, f, C, k) {
    if (u = +u, f = f >>> 0, !k) {
      const Ve = Math.pow(2, 8 * C - 1);
      Ie(this, u, f, C, Ve - 1, -Ve);
    }
    let $ = 0, Y = 1, Fe = 0;
    for (this[f] = u & 255; ++$ < C && (Y *= 256); )
      u < 0 && Fe === 0 && this[f + $ - 1] !== 0 && (Fe = 1), this[f + $] = (u / Y >> 0) - Fe & 255;
    return f + C;
  }, m.prototype.writeIntBE = function(u, f, C, k) {
    if (u = +u, f = f >>> 0, !k) {
      const Ve = Math.pow(2, 8 * C - 1);
      Ie(this, u, f, C, Ve - 1, -Ve);
    }
    let $ = C - 1, Y = 1, Fe = 0;
    for (this[f + $] = u & 255; --$ >= 0 && (Y *= 256); )
      u < 0 && Fe === 0 && this[f + $ + 1] !== 0 && (Fe = 1), this[f + $] = (u / Y >> 0) - Fe & 255;
    return f + C;
  }, m.prototype.writeInt8 = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[f] = u & 255, f + 1;
  }, m.prototype.writeInt16LE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 2, 32767, -32768), this[f] = u & 255, this[f + 1] = u >>> 8, f + 2;
  }, m.prototype.writeInt16BE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 2, 32767, -32768), this[f] = u >>> 8, this[f + 1] = u & 255, f + 2;
  }, m.prototype.writeInt32LE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 4, 2147483647, -2147483648), this[f] = u & 255, this[f + 1] = u >>> 8, this[f + 2] = u >>> 16, this[f + 3] = u >>> 24, f + 4;
  }, m.prototype.writeInt32BE = function(u, f, C) {
    return u = +u, f = f >>> 0, C || Ie(this, u, f, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[f] = u >>> 24, this[f + 1] = u >>> 16, this[f + 2] = u >>> 8, this[f + 3] = u & 255, f + 4;
  }, m.prototype.writeBigInt64LE = S(function(u, f = 0) {
    return gt(this, u, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), m.prototype.writeBigInt64BE = S(function(u, f = 0) {
    return wt(this, u, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function lt(y, u, f, C, k, $) {
    if (f + C > y.length)
      throw new RangeError("Index out of range");
    if (f < 0)
      throw new RangeError("Index out of range");
  }
  function Pt(y, u, f, C, k) {
    return u = +u, f = f >>> 0, k || lt(y, u, f, 4), n.write(y, u, f, C, 23, 4), f + 4;
  }
  m.prototype.writeFloatLE = function(u, f, C) {
    return Pt(this, u, f, !0, C);
  }, m.prototype.writeFloatBE = function(u, f, C) {
    return Pt(this, u, f, !1, C);
  };
  function Je(y, u, f, C, k) {
    return u = +u, f = f >>> 0, k || lt(y, u, f, 8), n.write(y, u, f, C, 52, 8), f + 8;
  }
  m.prototype.writeDoubleLE = function(u, f, C) {
    return Je(this, u, f, !0, C);
  }, m.prototype.writeDoubleBE = function(u, f, C) {
    return Je(this, u, f, !1, C);
  }, m.prototype.copy = function(u, f, C, k) {
    if (!m.isBuffer(u))
      throw new TypeError("argument should be a Buffer");
    if (C || (C = 0), !k && k !== 0 && (k = this.length), f >= u.length && (f = u.length), f || (f = 0), k > 0 && k < C && (k = C), k === C || u.length === 0 || this.length === 0)
      return 0;
    if (f < 0)
      throw new RangeError("targetStart out of bounds");
    if (C < 0 || C >= this.length)
      throw new RangeError("Index out of range");
    if (k < 0)
      throw new RangeError("sourceEnd out of bounds");
    k > this.length && (k = this.length), u.length - f < k - C && (k = u.length - f + C);
    const $ = k - C;
    return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(f, C, k) : Uint8Array.prototype.set.call(
      u,
      this.subarray(C, k),
      f
    ), $;
  }, m.prototype.fill = function(u, f, C, k) {
    if (typeof u == "string") {
      if (typeof f == "string" ? (k = f, f = 0, C = this.length) : typeof C == "string" && (k = C, C = this.length), k !== void 0 && typeof k != "string")
        throw new TypeError("encoding must be a string");
      if (typeof k == "string" && !m.isEncoding(k))
        throw new TypeError("Unknown encoding: " + k);
      if (u.length === 1) {
        const Y = u.charCodeAt(0);
        (k === "utf8" && Y < 128 || k === "latin1") && (u = Y);
      }
    } else
      typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
    if (f < 0 || this.length < f || this.length < C)
      throw new RangeError("Out of range index");
    if (C <= f)
      return this;
    f = f >>> 0, C = C === void 0 ? this.length : C >>> 0, u || (u = 0);
    let $;
    if (typeof u == "number")
      for ($ = f; $ < C; ++$)
        this[$] = u;
    else {
      const Y = m.isBuffer(u) ? u : m.from(u, k), Fe = Y.length;
      if (Fe === 0)
        throw new TypeError('The value "' + u + '" is invalid for argument "value"');
      for ($ = 0; $ < C - f; ++$)
        this[$ + f] = Y[$ % Fe];
    }
    return this;
  };
  const Ye = {};
  function ft(y, u, f) {
    Ye[y] = class extends f {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: u.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${y}]`, delete this.name;
      }
      get code() {
        return y;
      }
      set code(k) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: k,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${y}]: ${this.message}`;
      }
    };
  }
  ft(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(y) {
      return y ? `${y} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ft(
    "ERR_INVALID_ARG_TYPE",
    function(y, u) {
      return `The "${y}" argument must be of type number. Received type ${typeof u}`;
    },
    TypeError
  ), ft(
    "ERR_OUT_OF_RANGE",
    function(y, u, f) {
      let C = `The value of "${y}" is out of range.`, k = f;
      return Number.isInteger(f) && Math.abs(f) > 2 ** 32 ? k = mt(String(f)) : typeof f == "bigint" && (k = String(f), (f > BigInt(2) ** BigInt(32) || f < -(BigInt(2) ** BigInt(32))) && (k = mt(k)), k += "n"), C += ` It must be ${u}. Received ${k}`, C;
    },
    RangeError
  );
  function mt(y) {
    let u = "", f = y.length;
    const C = y[0] === "-" ? 1 : 0;
    for (; f >= C + 4; f -= 3)
      u = `_${y.slice(f - 3, f)}${u}`;
    return `${y.slice(0, f)}${u}`;
  }
  function rt(y, u, f) {
    M(u, "offset"), (y[u] === void 0 || y[u + f] === void 0) && j(u, y.length - (f + 1));
  }
  function qe(y, u, f, C, k, $) {
    if (y > f || y < u) {
      const Y = typeof u == "bigint" ? "n" : "";
      let Fe;
      throw $ > 3 ? u === 0 || u === BigInt(0) ? Fe = `>= 0${Y} and < 2${Y} ** ${($ + 1) * 8}${Y}` : Fe = `>= -(2${Y} ** ${($ + 1) * 8 - 1}${Y}) and < 2 ** ${($ + 1) * 8 - 1}${Y}` : Fe = `>= ${u}${Y} and <= ${f}${Y}`, new Ye.ERR_OUT_OF_RANGE("value", Fe, y);
    }
    rt(C, k, $);
  }
  function M(y, u) {
    if (typeof y != "number")
      throw new Ye.ERR_INVALID_ARG_TYPE(u, "number", y);
  }
  function j(y, u, f) {
    throw Math.floor(y) !== y ? (M(y, f), new Ye.ERR_OUT_OF_RANGE(f || "offset", "an integer", y)) : u < 0 ? new Ye.ERR_BUFFER_OUT_OF_BOUNDS() : new Ye.ERR_OUT_OF_RANGE(
      f || "offset",
      `>= ${f ? 1 : 0} and <= ${u}`,
      y
    );
  }
  const Q = /[^+/0-9A-Za-z-_]/g;
  function E(y) {
    if (y = y.split("=")[0], y = y.trim().replace(Q, ""), y.length < 2)
      return "";
    for (; y.length % 4 !== 0; )
      y = y + "=";
    return y;
  }
  function d(y, u) {
    u = u || 1 / 0;
    let f;
    const C = y.length;
    let k = null;
    const $ = [];
    for (let Y = 0; Y < C; ++Y) {
      if (f = y.charCodeAt(Y), f > 55295 && f < 57344) {
        if (!k) {
          if (f > 56319) {
            (u -= 3) > -1 && $.push(239, 191, 189);
            continue;
          } else if (Y + 1 === C) {
            (u -= 3) > -1 && $.push(239, 191, 189);
            continue;
          }
          k = f;
          continue;
        }
        if (f < 56320) {
          (u -= 3) > -1 && $.push(239, 191, 189), k = f;
          continue;
        }
        f = (k - 55296 << 10 | f - 56320) + 65536;
      } else
        k && (u -= 3) > -1 && $.push(239, 191, 189);
      if (k = null, f < 128) {
        if ((u -= 1) < 0)
          break;
        $.push(f);
      } else if (f < 2048) {
        if ((u -= 2) < 0)
          break;
        $.push(
          f >> 6 | 192,
          f & 63 | 128
        );
      } else if (f < 65536) {
        if ((u -= 3) < 0)
          break;
        $.push(
          f >> 12 | 224,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else if (f < 1114112) {
        if ((u -= 4) < 0)
          break;
        $.push(
          f >> 18 | 240,
          f >> 12 & 63 | 128,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return $;
  }
  function p(y) {
    const u = [];
    for (let f = 0; f < y.length; ++f)
      u.push(y.charCodeAt(f) & 255);
    return u;
  }
  function T(y, u) {
    let f, C, k;
    const $ = [];
    for (let Y = 0; Y < y.length && !((u -= 2) < 0); ++Y)
      f = y.charCodeAt(Y), C = f >> 8, k = f % 256, $.push(k), $.push(C);
    return $;
  }
  function B(y) {
    return a.toByteArray(E(y));
  }
  function N(y, u, f, C) {
    let k;
    for (k = 0; k < C && !(k + f >= u.length || k >= y.length); ++k)
      u[k + f] = y[k];
    return k;
  }
  function V(y, u) {
    return y instanceof u || y != null && y.constructor != null && y.constructor.name != null && y.constructor.name === u.name;
  }
  function Ce(y) {
    return y !== y;
  }
  const Ne = function() {
    const y = "0123456789abcdef", u = new Array(256);
    for (let f = 0; f < 16; ++f) {
      const C = f * 16;
      for (let k = 0; k < 16; ++k)
        u[C + k] = y[f] + y[k];
    }
    return u;
  }();
  function S(y) {
    return typeof BigInt > "u" ? R : y;
  }
  function R() {
    throw new Error("BigInt not supported");
  }
})(er);
var tt = {
  ArrayIsArray(r) {
    return Array.isArray(r);
  },
  ArrayPrototypeIncludes(r, a) {
    return r.includes(a);
  },
  ArrayPrototypeIndexOf(r, a) {
    return r.indexOf(a);
  },
  ArrayPrototypeJoin(r, a) {
    return r.join(a);
  },
  ArrayPrototypeMap(r, a) {
    return r.map(a);
  },
  ArrayPrototypePop(r, a) {
    return r.pop(a);
  },
  ArrayPrototypePush(r, a) {
    return r.push(a);
  },
  ArrayPrototypeSlice(r, a, n) {
    return r.slice(a, n);
  },
  Error,
  FunctionPrototypeCall(r, a, ...n) {
    return r.call(a, ...n);
  },
  FunctionPrototypeSymbolHasInstance(r, a) {
    return Function.prototype[Symbol.hasInstance].call(r, a);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(r, a) {
    return Object.defineProperties(r, a);
  },
  ObjectDefineProperty(r, a, n) {
    return Object.defineProperty(r, a, n);
  },
  ObjectGetOwnPropertyDescriptor(r, a) {
    return Object.getOwnPropertyDescriptor(r, a);
  },
  ObjectKeys(r) {
    return Object.keys(r);
  },
  ObjectSetPrototypeOf(r, a) {
    return Object.setPrototypeOf(r, a);
  },
  Promise,
  PromisePrototypeCatch(r, a) {
    return r.catch(a);
  },
  PromisePrototypeThen(r, a, n) {
    return r.then(a, n);
  },
  PromiseReject(r) {
    return Promise.reject(r);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(r, a) {
    return r.test(a);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(r, a, n) {
    return r.slice(a, n);
  },
  StringPrototypeToLowerCase(r) {
    return r.toLowerCase();
  },
  StringPrototypeToUpperCase(r) {
    return r.toUpperCase();
  },
  StringPrototypeTrim(r) {
    return r.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  TypedArrayPrototypeSet(r, a, n) {
    return r.set(a, n);
  },
  Uint8Array
}, Ks = { exports: {} };
(function(r) {
  const a = er, n = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || a.Blob, _ = typeof l < "u" ? function(m) {
    return m instanceof l;
  } : function(m) {
    return !1;
  };
  class v extends Error {
    constructor(m) {
      if (!Array.isArray(m))
        throw new TypeError(`Expected input to be an Array, got ${typeof m}`);
      let D = "";
      for (let L = 0; L < m.length; L++)
        D += `    ${m[L].stack}
`;
      super(D), this.name = "AggregateError", this.errors = m;
    }
  }
  r.exports = {
    AggregateError: v,
    kEmptyObject: Object.freeze({}),
    once(w) {
      let m = !1;
      return function(...D) {
        m || (m = !0, w.apply(this, D));
      };
    },
    createDeferredPromise: function() {
      let w, m;
      return {
        promise: new Promise((L, O) => {
          w = L, m = O;
        }),
        resolve: w,
        reject: m
      };
    },
    promisify(w) {
      return new Promise((m, D) => {
        w((L, ...O) => L ? D(L) : m(...O));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(w, ...m) {
      return w.replace(/%([sdifj])/g, function(...[D, L]) {
        const O = m.shift();
        return L === "f" ? O.toFixed(6) : L === "j" ? JSON.stringify(O) : L === "s" && typeof O == "object" ? `${O.constructor !== Object ? O.constructor.name : ""} {}`.trim() : O.toString();
      });
    },
    inspect(w) {
      switch (typeof w) {
        case "string":
          if (w.includes("'"))
            if (w.includes('"')) {
              if (!w.includes("`") && !w.includes("${"))
                return `\`${w}\``;
            } else
              return `"${w}"`;
          return `'${w}'`;
        case "number":
          return isNaN(w) ? "NaN" : Object.is(w, -0) ? String(w) : w;
        case "bigint":
          return `${String(w)}n`;
        case "boolean":
        case "undefined":
          return String(w);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(w) {
        return w instanceof n;
      },
      isArrayBufferView(w) {
        return ArrayBuffer.isView(w);
      }
    },
    isBlob: _
  }, r.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(Ks);
var Ht = Ks.exports, ba = {}, $r = { exports: {} }, Do;
function ya() {
  if (Do)
    return $r.exports;
  Do = 1;
  const { AbortController: r, AbortSignal: a } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return $r.exports = r, $r.exports.AbortSignal = a, $r.exports.default = r, $r.exports;
}
const { format: Gp, inspect: jn, AggregateError: Vp } = Ht, zp = globalThis.AggregateError || Vp, Hp = Symbol("kIsNodeError"), Kp = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], Yp = /^([A-Z][a-z0-9]*)+$/, Xp = "__node_internal_", zn = {};
function cr(r, a) {
  if (!r)
    throw new zn.ERR_INTERNAL_ASSERTION(a);
}
function Lo(r) {
  let a = "", n = r.length;
  const l = r[0] === "-" ? 1 : 0;
  for (; n >= l + 4; n -= 3)
    a = `_${r.slice(n - 3, n)}${a}`;
  return `${r.slice(0, n)}${a}`;
}
function Zp(r, a, n) {
  if (typeof a == "function")
    return cr(
      a.length <= n.length,
      // Default options do not count.
      `Code: ${r}; The provided arguments length (${n.length}) does not match the required ones (${a.length}).`
    ), a(...n);
  const l = (a.match(/%[dfijoOs]/g) || []).length;
  return cr(
    l === n.length,
    `Code: ${r}; The provided arguments length (${n.length}) does not match the required ones (${l}).`
  ), n.length === 0 ? a : Gp(a, ...n);
}
function st(r, a, n) {
  n || (n = Error);
  class l extends n {
    constructor(...v) {
      super(Zp(r, a, v));
    }
    toString() {
      return `${this.name} [${r}]: ${this.message}`;
    }
  }
  Object.defineProperties(l.prototype, {
    name: {
      value: n.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${r}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), l.prototype.code = r, l.prototype[Hp] = !0, zn[r] = l;
}
function Mo(r) {
  const a = Xp + r.name;
  return Object.defineProperty(r, "name", {
    value: a
  }), r;
}
function qp(r, a) {
  if (r && a && r !== a) {
    if (Array.isArray(a.errors))
      return a.errors.push(r), a;
    const n = new zp([a, r], a.message);
    return n.code = a.code, n;
  }
  return r || a;
}
let Qp = class extends Error {
  constructor(a = "The operation was aborted", n = void 0) {
    if (n !== void 0 && typeof n != "object")
      throw new zn.ERR_INVALID_ARG_TYPE("options", "Object", n);
    super(a, n), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
st("ERR_ASSERTION", "%s", Error);
st(
  "ERR_INVALID_ARG_TYPE",
  (r, a, n) => {
    cr(typeof r == "string", "'name' must be a string"), Array.isArray(a) || (a = [a]);
    let l = "The ";
    r.endsWith(" argument") ? l += `${r} ` : l += `"${r}" ${r.includes(".") ? "property" : "argument"} `, l += "must be ";
    const _ = [], v = [], w = [];
    for (const D of a)
      cr(typeof D == "string", "All expected entries have to be of type string"), Kp.includes(D) ? _.push(D.toLowerCase()) : Yp.test(D) ? v.push(D) : (cr(D !== "object", 'The value "object" should be written as "Object"'), w.push(D));
    if (v.length > 0) {
      const D = _.indexOf("object");
      D !== -1 && (_.splice(_, D, 1), v.push("Object"));
    }
    if (_.length > 0) {
      switch (_.length) {
        case 1:
          l += `of type ${_[0]}`;
          break;
        case 2:
          l += `one of type ${_[0]} or ${_[1]}`;
          break;
        default: {
          const D = _.pop();
          l += `one of type ${_.join(", ")}, or ${D}`;
        }
      }
      (v.length > 0 || w.length > 0) && (l += " or ");
    }
    if (v.length > 0) {
      switch (v.length) {
        case 1:
          l += `an instance of ${v[0]}`;
          break;
        case 2:
          l += `an instance of ${v[0]} or ${v[1]}`;
          break;
        default: {
          const D = v.pop();
          l += `an instance of ${v.join(", ")}, or ${D}`;
        }
      }
      w.length > 0 && (l += " or ");
    }
    switch (w.length) {
      case 0:
        break;
      case 1:
        w[0].toLowerCase() !== w[0] && (l += "an "), l += `${w[0]}`;
        break;
      case 2:
        l += `one of ${w[0]} or ${w[1]}`;
        break;
      default: {
        const D = w.pop();
        l += `one of ${w.join(", ")}, or ${D}`;
      }
    }
    if (n == null)
      l += `. Received ${n}`;
    else if (typeof n == "function" && n.name)
      l += `. Received function ${n.name}`;
    else if (typeof n == "object") {
      var m;
      if ((m = n.constructor) !== null && m !== void 0 && m.name)
        l += `. Received an instance of ${n.constructor.name}`;
      else {
        const D = jn(n, {
          depth: -1
        });
        l += `. Received ${D}`;
      }
    } else {
      let D = jn(n, {
        colors: !1
      });
      D.length > 25 && (D = `${D.slice(0, 25)}...`), l += `. Received type ${typeof n} (${D})`;
    }
    return l;
  },
  TypeError
);
st(
  "ERR_INVALID_ARG_VALUE",
  (r, a, n = "is invalid") => {
    let l = jn(a);
    return l.length > 128 && (l = l.slice(0, 128) + "..."), `The ${r.includes(".") ? "property" : "argument"} '${r}' ${n}. Received ${l}`;
  },
  TypeError
);
st(
  "ERR_INVALID_RETURN_VALUE",
  (r, a, n) => {
    var l;
    const _ = n != null && (l = n.constructor) !== null && l !== void 0 && l.name ? `instance of ${n.constructor.name}` : `type ${typeof n}`;
    return `Expected ${r} to be returned from the "${a}" function but got ${_}.`;
  },
  TypeError
);
st(
  "ERR_MISSING_ARGS",
  (...r) => {
    cr(r.length > 0, "At least one arg needs to be specified");
    let a;
    const n = r.length;
    switch (r = (Array.isArray(r) ? r : [r]).map((l) => `"${l}"`).join(" or "), n) {
      case 1:
        a += `The ${r[0]} argument`;
        break;
      case 2:
        a += `The ${r[0]} and ${r[1]} arguments`;
        break;
      default:
        {
          const l = r.pop();
          a += `The ${r.join(", ")}, and ${l} arguments`;
        }
        break;
    }
    return `${a} must be specified`;
  },
  TypeError
);
st(
  "ERR_OUT_OF_RANGE",
  (r, a, n) => {
    cr(a, 'Missing "range" argument');
    let l;
    return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? l = Lo(String(n)) : typeof n == "bigint" ? (l = String(n), (n > 2n ** 32n || n < -(2n ** 32n)) && (l = Lo(l)), l += "n") : l = jn(n), `The value of "${r}" is out of range. It must be ${a}. Received ${l}`;
  },
  RangeError
);
st("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
st("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
st("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
st("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
st("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
st("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
st("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
st("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
st("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
st("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
st("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var yt = {
  AbortError: Qp,
  aggregateTwoErrors: Mo(qp),
  hideStackFrames: Mo,
  codes: zn
};
const {
  ArrayIsArray: ga,
  ArrayPrototypeIncludes: Ys,
  ArrayPrototypeJoin: Xs,
  ArrayPrototypeMap: Jp,
  NumberIsInteger: wa,
  NumberIsNaN: e0,
  NumberMAX_SAFE_INTEGER: t0,
  NumberMIN_SAFE_INTEGER: r0,
  NumberParseInt: n0,
  ObjectPrototypeHasOwnProperty: i0,
  RegExpPrototypeExec: Zs,
  String: a0,
  StringPrototypeToUpperCase: o0,
  StringPrototypeTrim: s0
} = tt, {
  hideStackFrames: Rt,
  codes: { ERR_SOCKET_BAD_PORT: u0, ERR_INVALID_ARG_TYPE: pt, ERR_INVALID_ARG_VALUE: Pr, ERR_OUT_OF_RANGE: dr, ERR_UNKNOWN_SIGNAL: Bo }
} = yt, { normalizeEncoding: l0 } = Ht, { isAsyncFunction: f0, isArrayBufferView: c0 } = Ht.types, No = {};
function d0(r) {
  return r === (r | 0);
}
function h0(r) {
  return r === r >>> 0;
}
const p0 = /^[0-7]+$/, m0 = "must be a 32-bit unsigned integer or an octal string";
function _0(r, a, n) {
  if (typeof r > "u" && (r = n), typeof r == "string") {
    if (Zs(p0, r) === null)
      throw new Pr(a, r, m0);
    r = n0(r, 8);
  }
  return qs(r, a), r;
}
const b0 = Rt((r, a, n = r0, l = t0) => {
  if (typeof r != "number")
    throw new pt(a, "number", r);
  if (!wa(r))
    throw new dr(a, "an integer", r);
  if (r < n || r > l)
    throw new dr(a, `>= ${n} && <= ${l}`, r);
}), y0 = Rt((r, a, n = -2147483648, l = 2147483647) => {
  if (typeof r != "number")
    throw new pt(a, "number", r);
  if (!wa(r))
    throw new dr(a, "an integer", r);
  if (r < n || r > l)
    throw new dr(a, `>= ${n} && <= ${l}`, r);
}), qs = Rt((r, a, n = !1) => {
  if (typeof r != "number")
    throw new pt(a, "number", r);
  if (!wa(r))
    throw new dr(a, "an integer", r);
  const l = n ? 1 : 0, _ = 4294967295;
  if (r < l || r > _)
    throw new dr(a, `>= ${l} && <= ${_}`, r);
});
function va(r, a) {
  if (typeof r != "string")
    throw new pt(a, "string", r);
}
function g0(r, a, n = void 0, l) {
  if (typeof r != "number")
    throw new pt(a, "number", r);
  if (n != null && r < n || l != null && r > l || (n != null || l != null) && e0(r))
    throw new dr(
      a,
      `${n != null ? `>= ${n}` : ""}${n != null && l != null ? " && " : ""}${l != null ? `<= ${l}` : ""}`,
      r
    );
}
const w0 = Rt((r, a, n) => {
  if (!Ys(n, r)) {
    const _ = "must be one of: " + Xs(
      Jp(n, (v) => typeof v == "string" ? `'${v}'` : a0(v)),
      ", "
    );
    throw new Pr(a, r, _);
  }
});
function Qs(r, a) {
  if (typeof r != "boolean")
    throw new pt(a, "boolean", r);
}
function Di(r, a, n) {
  return r == null || !i0(r, a) ? n : r[a];
}
const v0 = Rt((r, a, n = null) => {
  const l = Di(n, "allowArray", !1), _ = Di(n, "allowFunction", !1);
  if (!Di(n, "nullable", !1) && r === null || !l && ga(r) || typeof r != "object" && (!_ || typeof r != "function"))
    throw new pt(a, "Object", r);
}), E0 = Rt((r, a) => {
  if (r != null && typeof r != "object" && typeof r != "function")
    throw new pt(a, "a dictionary", r);
}), Ea = Rt((r, a, n = 0) => {
  if (!ga(r))
    throw new pt(a, "Array", r);
  if (r.length < n) {
    const l = `must be longer than ${n}`;
    throw new Pr(a, r, l);
  }
});
function x0(r, a) {
  Ea(r, a);
  for (let n = 0; n < r.length; n++)
    va(r[n], `${a}[${n}]`);
}
function S0(r, a) {
  Ea(r, a);
  for (let n = 0; n < r.length; n++)
    Qs(r[n], `${a}[${n}]`);
}
function C0(r, a = "signal") {
  if (va(r, a), No[r] === void 0)
    throw No[o0(r)] !== void 0 ? new Bo(r + " (signals must use all capital letters)") : new Bo(r);
}
const T0 = Rt((r, a = "buffer") => {
  if (!c0(r))
    throw new pt(a, ["Buffer", "TypedArray", "DataView"], r);
});
function F0(r, a) {
  const n = l0(a), l = r.length;
  if (n === "hex" && l % 2 !== 0)
    throw new Pr("encoding", a, `is invalid for data of length ${l}`);
}
function R0(r, a = "Port", n = !0) {
  if (typeof r != "number" && typeof r != "string" || typeof r == "string" && s0(r).length === 0 || +r !== +r >>> 0 || r > 65535 || r === 0 && !n)
    throw new u0(a, r, n);
  return r | 0;
}
const A0 = Rt((r, a) => {
  if (r !== void 0 && (r === null || typeof r != "object" || !("aborted" in r)))
    throw new pt(a, "AbortSignal", r);
}), I0 = Rt((r, a) => {
  if (typeof r != "function")
    throw new pt(a, "Function", r);
}), P0 = Rt((r, a) => {
  if (typeof r != "function" || f0(r))
    throw new pt(a, "Function", r);
}), k0 = Rt((r, a) => {
  if (r !== void 0)
    throw new pt(a, "undefined", r);
});
function D0(r, a, n) {
  if (!Ys(n, r))
    throw new pt(a, `('${Xs(n, "|")}')`, r);
}
const L0 = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function Oo(r, a) {
  if (typeof r > "u" || !Zs(L0, r))
    throw new Pr(
      a,
      r,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function M0(r) {
  if (typeof r == "string")
    return Oo(r, "hints"), r;
  if (ga(r)) {
    const a = r.length;
    let n = "";
    if (a === 0)
      return n;
    for (let l = 0; l < a; l++) {
      const _ = r[l];
      Oo(_, "hints"), n += _, l !== a - 1 && (n += ", ");
    }
    return n;
  }
  throw new Pr(
    "hints",
    r,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var Hn = {
  isInt32: d0,
  isUint32: h0,
  parseFileMode: _0,
  validateArray: Ea,
  validateStringArray: x0,
  validateBooleanArray: S0,
  validateBoolean: Qs,
  validateBuffer: T0,
  validateDictionary: E0,
  validateEncoding: F0,
  validateFunction: I0,
  validateInt32: y0,
  validateInteger: b0,
  validateNumber: g0,
  validateObject: v0,
  validateOneOf: w0,
  validatePlainFunction: P0,
  validatePort: R0,
  validateSignalName: C0,
  validateString: va,
  validateUint32: qs,
  validateUndefined: k0,
  validateUnion: D0,
  validateAbortSignal: A0,
  validateLinkHeaderValue: M0
}, xa = { exports: {} }, Js = { exports: {} }, Ze = Js.exports = {}, Bt, Nt;
function Qi() {
  throw new Error("setTimeout has not been defined");
}
function Ji() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Bt = setTimeout : Bt = Qi;
  } catch {
    Bt = Qi;
  }
  try {
    typeof clearTimeout == "function" ? Nt = clearTimeout : Nt = Ji;
  } catch {
    Nt = Ji;
  }
})();
function eu(r) {
  if (Bt === setTimeout)
    return setTimeout(r, 0);
  if ((Bt === Qi || !Bt) && setTimeout)
    return Bt = setTimeout, setTimeout(r, 0);
  try {
    return Bt(r, 0);
  } catch {
    try {
      return Bt.call(null, r, 0);
    } catch {
      return Bt.call(this, r, 0);
    }
  }
}
function B0(r) {
  if (Nt === clearTimeout)
    return clearTimeout(r);
  if ((Nt === Ji || !Nt) && clearTimeout)
    return Nt = clearTimeout, clearTimeout(r);
  try {
    return Nt(r);
  } catch {
    try {
      return Nt.call(null, r);
    } catch {
      return Nt.call(this, r);
    }
  }
}
var $t = [], Rr = !1, fr, Mn = -1;
function N0() {
  !Rr || !fr || (Rr = !1, fr.length ? $t = fr.concat($t) : Mn = -1, $t.length && tu());
}
function tu() {
  if (!Rr) {
    var r = eu(N0);
    Rr = !0;
    for (var a = $t.length; a; ) {
      for (fr = $t, $t = []; ++Mn < a; )
        fr && fr[Mn].run();
      Mn = -1, a = $t.length;
    }
    fr = null, Rr = !1, B0(r);
  }
}
Ze.nextTick = function(r) {
  var a = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      a[n - 1] = arguments[n];
  $t.push(new ru(r, a)), $t.length === 1 && !Rr && eu(tu);
};
function ru(r, a) {
  this.fun = r, this.array = a;
}
ru.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Ze.title = "browser";
Ze.browser = !0;
Ze.env = {};
Ze.argv = [];
Ze.version = "";
Ze.versions = {};
function Kt() {
}
Ze.on = Kt;
Ze.addListener = Kt;
Ze.once = Kt;
Ze.off = Kt;
Ze.removeListener = Kt;
Ze.removeAllListeners = Kt;
Ze.emit = Kt;
Ze.prependListener = Kt;
Ze.prependOnceListener = Kt;
Ze.listeners = function(r) {
  return [];
};
Ze.binding = function(r) {
  throw new Error("process.binding is not supported");
};
Ze.cwd = function() {
  return "/";
};
Ze.chdir = function(r) {
  throw new Error("process.chdir is not supported");
};
Ze.umask = function() {
  return 0;
};
var hr = Js.exports;
const { Symbol: Kn, SymbolAsyncIterator: jo, SymbolIterator: Uo, SymbolFor: nu } = tt, iu = Kn("kDestroyed"), au = Kn("kIsErrored"), ea = Kn("kIsReadable"), ou = Kn("kIsDisturbed"), O0 = nu("nodejs.webstream.isClosedPromise"), j0 = nu("nodejs.webstream.controllerErrorFunction");
function Yn(r, a = !1) {
  var n;
  return !!(r && typeof r.pipe == "function" && typeof r.on == "function" && (!a || typeof r.pause == "function" && typeof r.resume == "function") && (!r._writableState || ((n = r._readableState) === null || n === void 0 ? void 0 : n.readable) !== !1) && // Duplex
  (!r._writableState || r._readableState));
}
function Xn(r) {
  var a;
  return !!(r && typeof r.write == "function" && typeof r.on == "function" && (!r._readableState || ((a = r._writableState) === null || a === void 0 ? void 0 : a.writable) !== !1));
}
function U0(r) {
  return !!(r && typeof r.pipe == "function" && r._readableState && typeof r.on == "function" && typeof r.write == "function");
}
function Wt(r) {
  return r && (r._readableState || r._writableState || typeof r.write == "function" && typeof r.on == "function" || typeof r.pipe == "function" && typeof r.on == "function");
}
function su(r) {
  return !!(r && !Wt(r) && typeof r.pipeThrough == "function" && typeof r.getReader == "function" && typeof r.cancel == "function");
}
function uu(r) {
  return !!(r && !Wt(r) && typeof r.getWriter == "function" && typeof r.abort == "function");
}
function lu(r) {
  return !!(r && !Wt(r) && typeof r.readable == "object" && typeof r.writable == "object");
}
function W0(r) {
  return su(r) || uu(r) || lu(r);
}
function $0(r, a) {
  return r == null ? !1 : a === !0 ? typeof r[jo] == "function" : a === !1 ? typeof r[Uo] == "function" : typeof r[jo] == "function" || typeof r[Uo] == "function";
}
function Zn(r) {
  if (!Wt(r))
    return null;
  const a = r._writableState, n = r._readableState, l = a || n;
  return !!(r.destroyed || r[iu] || l != null && l.destroyed);
}
function fu(r) {
  if (!Xn(r))
    return null;
  if (r.writableEnded === !0)
    return !0;
  const a = r._writableState;
  return a != null && a.errored ? !1 : typeof a?.ended != "boolean" ? null : a.ended;
}
function G0(r, a) {
  if (!Xn(r))
    return null;
  if (r.writableFinished === !0)
    return !0;
  const n = r._writableState;
  return n != null && n.errored ? !1 : typeof n?.finished != "boolean" ? null : !!(n.finished || a === !1 && n.ended === !0 && n.length === 0);
}
function V0(r) {
  if (!Yn(r))
    return null;
  if (r.readableEnded === !0)
    return !0;
  const a = r._readableState;
  return !a || a.errored ? !1 : typeof a?.ended != "boolean" ? null : a.ended;
}
function cu(r, a) {
  if (!Yn(r))
    return null;
  const n = r._readableState;
  return n != null && n.errored ? !1 : typeof n?.endEmitted != "boolean" ? null : !!(n.endEmitted || a === !1 && n.ended === !0 && n.length === 0);
}
function du(r) {
  return r && r[ea] != null ? r[ea] : typeof r?.readable != "boolean" ? null : Zn(r) ? !1 : Yn(r) && r.readable && !cu(r);
}
function hu(r) {
  return typeof r?.writable != "boolean" ? null : Zn(r) ? !1 : Xn(r) && r.writable && !fu(r);
}
function z0(r, a) {
  return Wt(r) ? Zn(r) ? !0 : !(a?.readable !== !1 && du(r) || a?.writable !== !1 && hu(r)) : null;
}
function H0(r) {
  var a, n;
  return Wt(r) ? r.writableErrored ? r.writableErrored : (a = (n = r._writableState) === null || n === void 0 ? void 0 : n.errored) !== null && a !== void 0 ? a : null : null;
}
function K0(r) {
  var a, n;
  return Wt(r) ? r.readableErrored ? r.readableErrored : (a = (n = r._readableState) === null || n === void 0 ? void 0 : n.errored) !== null && a !== void 0 ? a : null : null;
}
function Y0(r) {
  if (!Wt(r))
    return null;
  if (typeof r.closed == "boolean")
    return r.closed;
  const a = r._writableState, n = r._readableState;
  return typeof a?.closed == "boolean" || typeof n?.closed == "boolean" ? a?.closed || n?.closed : typeof r._closed == "boolean" && pu(r) ? r._closed : null;
}
function pu(r) {
  return typeof r._closed == "boolean" && typeof r._defaultKeepAlive == "boolean" && typeof r._removedConnection == "boolean" && typeof r._removedContLen == "boolean";
}
function mu(r) {
  return typeof r._sent100 == "boolean" && pu(r);
}
function X0(r) {
  var a;
  return typeof r._consuming == "boolean" && typeof r._dumped == "boolean" && ((a = r.req) === null || a === void 0 ? void 0 : a.upgradeOrConnect) === void 0;
}
function Z0(r) {
  if (!Wt(r))
    return null;
  const a = r._writableState, n = r._readableState, l = a || n;
  return !l && mu(r) || !!(l && l.autoDestroy && l.emitClose && l.closed === !1);
}
function q0(r) {
  var a;
  return !!(r && ((a = r[ou]) !== null && a !== void 0 ? a : r.readableDidRead || r.readableAborted));
}
function Q0(r) {
  var a, n, l, _, v, w, m, D, L, O;
  return !!(r && ((a = (n = (l = (_ = (v = (w = r[au]) !== null && w !== void 0 ? w : r.readableErrored) !== null && v !== void 0 ? v : r.writableErrored) !== null && _ !== void 0 ? _ : (m = r._readableState) === null || m === void 0 ? void 0 : m.errorEmitted) !== null && l !== void 0 ? l : (D = r._writableState) === null || D === void 0 ? void 0 : D.errorEmitted) !== null && n !== void 0 ? n : (L = r._readableState) === null || L === void 0 ? void 0 : L.errored) !== null && a !== void 0 ? a : !((O = r._writableState) === null || O === void 0) && O.errored));
}
var Yt = {
  kDestroyed: iu,
  isDisturbed: q0,
  kIsDisturbed: ou,
  isErrored: Q0,
  kIsErrored: au,
  isReadable: du,
  kIsReadable: ea,
  kIsClosedPromise: O0,
  kControllerErrorFunction: j0,
  isClosed: Y0,
  isDestroyed: Zn,
  isDuplexNodeStream: U0,
  isFinished: z0,
  isIterable: $0,
  isReadableNodeStream: Yn,
  isReadableStream: su,
  isReadableEnded: V0,
  isReadableFinished: cu,
  isReadableErrored: K0,
  isNodeStream: Wt,
  isWebStream: W0,
  isWritable: hu,
  isWritableNodeStream: Xn,
  isWritableStream: uu,
  isWritableEnded: fu,
  isWritableFinished: G0,
  isWritableErrored: H0,
  isServerRequest: X0,
  isServerResponse: mu,
  willEmitClose: Z0,
  isTransformStream: lu
};
const Qt = hr, { AbortError: _u, codes: J0 } = yt, { ERR_INVALID_ARG_TYPE: em, ERR_STREAM_PREMATURE_CLOSE: Wo } = J0, { kEmptyObject: ta, once: ra } = Ht, { validateAbortSignal: tm, validateFunction: rm, validateObject: nm, validateBoolean: im } = Hn, { Promise: am, PromisePrototypeThen: om } = tt, {
  isClosed: sm,
  isReadable: $o,
  isReadableNodeStream: Li,
  isReadableStream: um,
  isReadableFinished: Go,
  isReadableErrored: Vo,
  isWritable: zo,
  isWritableNodeStream: Ho,
  isWritableStream: lm,
  isWritableFinished: Ko,
  isWritableErrored: Yo,
  isNodeStream: fm,
  willEmitClose: cm,
  kIsClosedPromise: dm
} = Yt;
function hm(r) {
  return r.setHeader && typeof r.abort == "function";
}
const na = () => {
};
function bu(r, a, n) {
  var l, _;
  if (arguments.length === 2 ? (n = a, a = ta) : a == null ? a = ta : nm(a, "options"), rm(n, "callback"), tm(a.signal, "options.signal"), n = ra(n), um(r) || lm(r))
    return pm(r, a, n);
  if (!fm(r))
    throw new em("stream", ["ReadableStream", "WritableStream", "Stream"], r);
  const v = (l = a.readable) !== null && l !== void 0 ? l : Li(r), w = (_ = a.writable) !== null && _ !== void 0 ? _ : Ho(r), m = r._writableState, D = r._readableState, L = () => {
    r.writable || ae();
  };
  let O = cm(r) && Li(r) === v && Ho(r) === w, J = Ko(r, !1);
  const ae = () => {
    J = !0, r.destroyed && (O = !1), !(O && (!r.readable || v)) && (!v || q) && n.call(r);
  };
  let q = Go(r, !1);
  const K = () => {
    q = !0, r.destroyed && (O = !1), !(O && (!r.writable || w)) && (!w || J) && n.call(r);
  }, pe = (me) => {
    n.call(r, me);
  };
  let he = sm(r);
  const ce = () => {
    he = !0;
    const me = Yo(r) || Vo(r);
    if (me && typeof me != "boolean")
      return n.call(r, me);
    if (v && !q && Li(r, !0) && !Go(r, !1))
      return n.call(r, new Wo());
    if (w && !J && !Ko(r, !1))
      return n.call(r, new Wo());
    n.call(r);
  }, ee = () => {
    he = !0;
    const me = Yo(r) || Vo(r);
    if (me && typeof me != "boolean")
      return n.call(r, me);
    n.call(r);
  }, Te = () => {
    r.req.on("finish", ae);
  };
  hm(r) ? (r.on("complete", ae), O || r.on("abort", ce), r.req ? Te() : r.on("request", Te)) : w && !m && (r.on("end", L), r.on("close", L)), !O && typeof r.aborted == "boolean" && r.on("aborted", ce), r.on("end", K), r.on("finish", ae), a.error !== !1 && r.on("error", pe), r.on("close", ce), he ? Qt.nextTick(ce) : m != null && m.errorEmitted || D != null && D.errorEmitted ? O || Qt.nextTick(ee) : (!v && (!O || $o(r)) && (J || zo(r) === !1) || !w && (!O || zo(r)) && (q || $o(r) === !1) || D && r.req && r.aborted) && Qt.nextTick(ee);
  const Oe = () => {
    n = na, r.removeListener("aborted", ce), r.removeListener("complete", ae), r.removeListener("abort", ce), r.removeListener("request", Te), r.req && r.req.removeListener("finish", ae), r.removeListener("end", L), r.removeListener("close", L), r.removeListener("finish", ae), r.removeListener("end", K), r.removeListener("error", pe), r.removeListener("close", ce);
  };
  if (a.signal && !he) {
    const me = () => {
      const Ee = n;
      Oe(), Ee.call(
        r,
        new _u(void 0, {
          cause: a.signal.reason
        })
      );
    };
    if (a.signal.aborted)
      Qt.nextTick(me);
    else {
      const Ee = n;
      n = ra((...de) => {
        a.signal.removeEventListener("abort", me), Ee.apply(r, de);
      }), a.signal.addEventListener("abort", me);
    }
  }
  return Oe;
}
function pm(r, a, n) {
  let l = !1, _ = na;
  if (a.signal)
    if (_ = () => {
      l = !0, n.call(
        r,
        new _u(void 0, {
          cause: a.signal.reason
        })
      );
    }, a.signal.aborted)
      Qt.nextTick(_);
    else {
      const w = n;
      n = ra((...m) => {
        a.signal.removeEventListener("abort", _), w.apply(r, m);
      }), a.signal.addEventListener("abort", _);
    }
  const v = (...w) => {
    l || Qt.nextTick(() => n.apply(r, w));
  };
  return om(r[dm].promise, v, v), na;
}
function mm(r, a) {
  var n;
  let l = !1;
  return a === null && (a = ta), (n = a) !== null && n !== void 0 && n.cleanup && (im(a.cleanup, "cleanup"), l = a.cleanup), new am((_, v) => {
    const w = bu(r, a, (m) => {
      l && w(), m ? v(m) : _();
    });
  });
}
xa.exports = bu;
xa.exports.finished = mm;
var tr = xa.exports;
const jt = hr, {
  aggregateTwoErrors: _m,
  codes: { ERR_MULTIPLE_CALLBACK: bm },
  AbortError: ym
} = yt, { Symbol: yu } = tt, { kDestroyed: gm, isDestroyed: wm, isFinished: vm, isServerRequest: Em } = Yt, gu = yu("kDestroy"), ia = yu("kConstruct");
function wu(r, a, n) {
  r && (a && !a.errored && (a.errored = r), n && !n.errored && (n.errored = r));
}
function xm(r, a) {
  const n = this._readableState, l = this._writableState, _ = l || n;
  return l != null && l.destroyed || n != null && n.destroyed ? (typeof a == "function" && a(), this) : (wu(r, l, n), l && (l.destroyed = !0), n && (n.destroyed = !0), _.constructed ? Xo(this, r, a) : this.once(gu, function(v) {
    Xo(this, _m(v, r), a);
  }), this);
}
function Xo(r, a, n) {
  let l = !1;
  function _(v) {
    if (l)
      return;
    l = !0;
    const w = r._readableState, m = r._writableState;
    wu(v, m, w), m && (m.closed = !0), w && (w.closed = !0), typeof n == "function" && n(v), v ? jt.nextTick(Sm, r, v) : jt.nextTick(vu, r);
  }
  try {
    r._destroy(a || null, _);
  } catch (v) {
    _(v);
  }
}
function Sm(r, a) {
  aa(r, a), vu(r);
}
function vu(r) {
  const a = r._readableState, n = r._writableState;
  n && (n.closeEmitted = !0), a && (a.closeEmitted = !0), (n != null && n.emitClose || a != null && a.emitClose) && r.emit("close");
}
function aa(r, a) {
  const n = r._readableState, l = r._writableState;
  l != null && l.errorEmitted || n != null && n.errorEmitted || (l && (l.errorEmitted = !0), n && (n.errorEmitted = !0), r.emit("error", a));
}
function Cm() {
  const r = this._readableState, a = this._writableState;
  r && (r.constructed = !0, r.closed = !1, r.closeEmitted = !1, r.destroyed = !1, r.errored = null, r.errorEmitted = !1, r.reading = !1, r.ended = r.readable === !1, r.endEmitted = r.readable === !1), a && (a.constructed = !0, a.destroyed = !1, a.closed = !1, a.closeEmitted = !1, a.errored = null, a.errorEmitted = !1, a.finalCalled = !1, a.prefinished = !1, a.ended = a.writable === !1, a.ending = a.writable === !1, a.finished = a.writable === !1);
}
function oa(r, a, n) {
  const l = r._readableState, _ = r._writableState;
  if (_ != null && _.destroyed || l != null && l.destroyed)
    return this;
  l != null && l.autoDestroy || _ != null && _.autoDestroy ? r.destroy(a) : a && (_ && !_.errored && (_.errored = a), l && !l.errored && (l.errored = a), n ? jt.nextTick(aa, r, a) : aa(r, a));
}
function Tm(r, a) {
  if (typeof r._construct != "function")
    return;
  const n = r._readableState, l = r._writableState;
  n && (n.constructed = !1), l && (l.constructed = !1), r.once(ia, a), !(r.listenerCount(ia) > 1) && jt.nextTick(Fm, r);
}
function Fm(r) {
  let a = !1;
  function n(l) {
    if (a) {
      oa(r, l ?? new bm());
      return;
    }
    a = !0;
    const _ = r._readableState, v = r._writableState, w = v || _;
    _ && (_.constructed = !0), v && (v.constructed = !0), w.destroyed ? r.emit(gu, l) : l ? oa(r, l, !0) : jt.nextTick(Rm, r);
  }
  try {
    r._construct((l) => {
      jt.nextTick(n, l);
    });
  } catch (l) {
    jt.nextTick(n, l);
  }
}
function Rm(r) {
  r.emit(ia);
}
function Zo(r) {
  return r?.setHeader && typeof r.abort == "function";
}
function Eu(r) {
  r.emit("close");
}
function Am(r, a) {
  r.emit("error", a), jt.nextTick(Eu, r);
}
function Im(r, a) {
  !r || wm(r) || (!a && !vm(r) && (a = new ym()), Em(r) ? (r.socket = null, r.destroy(a)) : Zo(r) ? r.abort() : Zo(r.req) ? r.req.abort() : typeof r.destroy == "function" ? r.destroy(a) : typeof r.close == "function" ? r.close() : a ? jt.nextTick(Am, r, a) : jt.nextTick(Eu, r), r.destroyed || (r[gm] = !0));
}
var kr = {
  construct: Tm,
  destroyer: Im,
  destroy: xm,
  undestroy: Cm,
  errorOrDestroy: oa
}, Sa = { exports: {} }, Ar = typeof Reflect == "object" ? Reflect : null, qo = Ar && typeof Ar.apply == "function" ? Ar.apply : function(a, n, l) {
  return Function.prototype.apply.call(a, n, l);
}, Bn;
Ar && typeof Ar.ownKeys == "function" ? Bn = Ar.ownKeys : Object.getOwnPropertySymbols ? Bn = function(a) {
  return Object.getOwnPropertyNames(a).concat(Object.getOwnPropertySymbols(a));
} : Bn = function(a) {
  return Object.getOwnPropertyNames(a);
};
function Pm(r) {
  console && console.warn && console.warn(r);
}
var xu = Number.isNaN || function(a) {
  return a !== a;
};
function We() {
  We.init.call(this);
}
Sa.exports = We;
Sa.exports.once = Mm;
We.EventEmitter = We;
We.prototype._events = void 0;
We.prototype._eventsCount = 0;
We.prototype._maxListeners = void 0;
var Qo = 10;
function qn(r) {
  if (typeof r != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
}
Object.defineProperty(We, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Qo;
  },
  set: function(r) {
    if (typeof r != "number" || r < 0 || xu(r))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
    Qo = r;
  }
});
We.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
We.prototype.setMaxListeners = function(a) {
  if (typeof a != "number" || a < 0 || xu(a))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + a + ".");
  return this._maxListeners = a, this;
};
function Su(r) {
  return r._maxListeners === void 0 ? We.defaultMaxListeners : r._maxListeners;
}
We.prototype.getMaxListeners = function() {
  return Su(this);
};
We.prototype.emit = function(a) {
  for (var n = [], l = 1; l < arguments.length; l++)
    n.push(arguments[l]);
  var _ = a === "error", v = this._events;
  if (v !== void 0)
    _ = _ && v.error === void 0;
  else if (!_)
    return !1;
  if (_) {
    var w;
    if (n.length > 0 && (w = n[0]), w instanceof Error)
      throw w;
    var m = new Error("Unhandled error." + (w ? " (" + w.message + ")" : ""));
    throw m.context = w, m;
  }
  var D = v[a];
  if (D === void 0)
    return !1;
  if (typeof D == "function")
    qo(D, this, n);
  else
    for (var L = D.length, O = Au(D, L), l = 0; l < L; ++l)
      qo(O[l], this, n);
  return !0;
};
function Cu(r, a, n, l) {
  var _, v, w;
  if (qn(n), v = r._events, v === void 0 ? (v = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (v.newListener !== void 0 && (r.emit(
    "newListener",
    a,
    n.listener ? n.listener : n
  ), v = r._events), w = v[a]), w === void 0)
    w = v[a] = n, ++r._eventsCount;
  else if (typeof w == "function" ? w = v[a] = l ? [n, w] : [w, n] : l ? w.unshift(n) : w.push(n), _ = Su(r), _ > 0 && w.length > _ && !w.warned) {
    w.warned = !0;
    var m = new Error("Possible EventEmitter memory leak detected. " + w.length + " " + String(a) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    m.name = "MaxListenersExceededWarning", m.emitter = r, m.type = a, m.count = w.length, Pm(m);
  }
  return r;
}
We.prototype.addListener = function(a, n) {
  return Cu(this, a, n, !1);
};
We.prototype.on = We.prototype.addListener;
We.prototype.prependListener = function(a, n) {
  return Cu(this, a, n, !0);
};
function km() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Tu(r, a, n) {
  var l = { fired: !1, wrapFn: void 0, target: r, type: a, listener: n }, _ = km.bind(l);
  return _.listener = n, l.wrapFn = _, _;
}
We.prototype.once = function(a, n) {
  return qn(n), this.on(a, Tu(this, a, n)), this;
};
We.prototype.prependOnceListener = function(a, n) {
  return qn(n), this.prependListener(a, Tu(this, a, n)), this;
};
We.prototype.removeListener = function(a, n) {
  var l, _, v, w, m;
  if (qn(n), _ = this._events, _ === void 0)
    return this;
  if (l = _[a], l === void 0)
    return this;
  if (l === n || l.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete _[a], _.removeListener && this.emit("removeListener", a, l.listener || n));
  else if (typeof l != "function") {
    for (v = -1, w = l.length - 1; w >= 0; w--)
      if (l[w] === n || l[w].listener === n) {
        m = l[w].listener, v = w;
        break;
      }
    if (v < 0)
      return this;
    v === 0 ? l.shift() : Dm(l, v), l.length === 1 && (_[a] = l[0]), _.removeListener !== void 0 && this.emit("removeListener", a, m || n);
  }
  return this;
};
We.prototype.off = We.prototype.removeListener;
We.prototype.removeAllListeners = function(a) {
  var n, l, _;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[a] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[a]), this;
  if (arguments.length === 0) {
    var v = Object.keys(l), w;
    for (_ = 0; _ < v.length; ++_)
      w = v[_], w !== "removeListener" && this.removeAllListeners(w);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = l[a], typeof n == "function")
    this.removeListener(a, n);
  else if (n !== void 0)
    for (_ = n.length - 1; _ >= 0; _--)
      this.removeListener(a, n[_]);
  return this;
};
function Fu(r, a, n) {
  var l = r._events;
  if (l === void 0)
    return [];
  var _ = l[a];
  return _ === void 0 ? [] : typeof _ == "function" ? n ? [_.listener || _] : [_] : n ? Lm(_) : Au(_, _.length);
}
We.prototype.listeners = function(a) {
  return Fu(this, a, !0);
};
We.prototype.rawListeners = function(a) {
  return Fu(this, a, !1);
};
We.listenerCount = function(r, a) {
  return typeof r.listenerCount == "function" ? r.listenerCount(a) : Ru.call(r, a);
};
We.prototype.listenerCount = Ru;
function Ru(r) {
  var a = this._events;
  if (a !== void 0) {
    var n = a[r];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
We.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Bn(this._events) : [];
};
function Au(r, a) {
  for (var n = new Array(a), l = 0; l < a; ++l)
    n[l] = r[l];
  return n;
}
function Dm(r, a) {
  for (; a + 1 < r.length; a++)
    r[a] = r[a + 1];
  r.pop();
}
function Lm(r) {
  for (var a = new Array(r.length), n = 0; n < a.length; ++n)
    a[n] = r[n].listener || r[n];
  return a;
}
function Mm(r, a) {
  return new Promise(function(n, l) {
    function _(w) {
      r.removeListener(a, v), l(w);
    }
    function v() {
      typeof r.removeListener == "function" && r.removeListener("error", _), n([].slice.call(arguments));
    }
    Iu(r, a, v, { once: !0 }), a !== "error" && Bm(r, _, { once: !0 });
  });
}
function Bm(r, a, n) {
  typeof r.on == "function" && Iu(r, "error", a, n);
}
function Iu(r, a, n, l) {
  if (typeof r.on == "function")
    l.once ? r.once(a, n) : r.on(a, n);
  else if (typeof r.addEventListener == "function")
    r.addEventListener(a, function _(v) {
      l.once && r.removeEventListener(a, _), n(v);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
}
var Ca = Sa.exports;
const { ArrayIsArray: Nm, ObjectSetPrototypeOf: Pu } = tt, { EventEmitter: Qn } = Ca;
function Jn(r) {
  Qn.call(this, r);
}
Pu(Jn.prototype, Qn.prototype);
Pu(Jn, Qn);
Jn.prototype.pipe = function(r, a) {
  const n = this;
  function l(O) {
    r.writable && r.write(O) === !1 && n.pause && n.pause();
  }
  n.on("data", l);
  function _() {
    n.readable && n.resume && n.resume();
  }
  r.on("drain", _), !r._isStdio && (!a || a.end !== !1) && (n.on("end", w), n.on("close", m));
  let v = !1;
  function w() {
    v || (v = !0, r.end());
  }
  function m() {
    v || (v = !0, typeof r.destroy == "function" && r.destroy());
  }
  function D(O) {
    L(), Qn.listenerCount(this, "error") === 0 && this.emit("error", O);
  }
  sa(n, "error", D), sa(r, "error", D);
  function L() {
    n.removeListener("data", l), r.removeListener("drain", _), n.removeListener("end", w), n.removeListener("close", m), n.removeListener("error", D), r.removeListener("error", D), n.removeListener("end", L), n.removeListener("close", L), r.removeListener("close", L);
  }
  return n.on("end", L), n.on("close", L), r.on("close", L), r.emit("pipe", n), r;
};
function sa(r, a, n) {
  if (typeof r.prependListener == "function")
    return r.prependListener(a, n);
  !r._events || !r._events[a] ? r.on(a, n) : Nm(r._events[a]) ? r._events[a].unshift(n) : r._events[a] = [n, r._events[a]];
}
var Ta = {
  Stream: Jn,
  prependListener: sa
}, ku = { exports: {} };
(function(r) {
  const { AbortError: a, codes: n } = yt, { isNodeStream: l, isWebStream: _, kControllerErrorFunction: v } = Yt, w = tr, { ERR_INVALID_ARG_TYPE: m } = n, D = (L, O) => {
    if (typeof L != "object" || !("aborted" in L))
      throw new m(O, "AbortSignal", L);
  };
  r.exports.addAbortSignal = function(O, J) {
    if (D(O, "signal"), !l(J) && !_(J))
      throw new m("stream", ["ReadableStream", "WritableStream", "Stream"], J);
    return r.exports.addAbortSignalNoValidate(O, J);
  }, r.exports.addAbortSignalNoValidate = function(L, O) {
    if (typeof L != "object" || !("aborted" in L))
      return O;
    const J = l(O) ? () => {
      O.destroy(
        new a(void 0, {
          cause: L.reason
        })
      );
    } : () => {
      O[v](
        new a(void 0, {
          cause: L.reason
        })
      );
    };
    return L.aborted ? J() : (L.addEventListener("abort", J), w(O, () => L.removeEventListener("abort", J))), O;
  };
})(ku);
var ei = ku.exports;
const { StringPrototypeSlice: Jo, SymbolIterator: Om, TypedArrayPrototypeSet: Pn, Uint8Array: jm } = tt, { Buffer: Mi } = er, { inspect: Um } = Ht;
var Wm = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(a) {
    const n = {
      data: a,
      next: null
    };
    this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
  }
  unshift(a) {
    const n = {
      data: a,
      next: this.head
    };
    this.length === 0 && (this.tail = n), this.head = n, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const a = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, a;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(a) {
    if (this.length === 0)
      return "";
    let n = this.head, l = "" + n.data;
    for (; (n = n.next) !== null; )
      l += a + n.data;
    return l;
  }
  concat(a) {
    if (this.length === 0)
      return Mi.alloc(0);
    const n = Mi.allocUnsafe(a >>> 0);
    let l = this.head, _ = 0;
    for (; l; )
      Pn(n, l.data, _), _ += l.data.length, l = l.next;
    return n;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(a, n) {
    const l = this.head.data;
    if (a < l.length) {
      const _ = l.slice(0, a);
      return this.head.data = l.slice(a), _;
    }
    return a === l.length ? this.shift() : n ? this._getString(a) : this._getBuffer(a);
  }
  first() {
    return this.head.data;
  }
  *[Om]() {
    for (let a = this.head; a; a = a.next)
      yield a.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(a) {
    let n = "", l = this.head, _ = 0;
    do {
      const v = l.data;
      if (a > v.length)
        n += v, a -= v.length;
      else {
        a === v.length ? (n += v, ++_, l.next ? this.head = l.next : this.head = this.tail = null) : (n += Jo(v, 0, a), this.head = l, l.data = Jo(v, a));
        break;
      }
      ++_;
    } while ((l = l.next) !== null);
    return this.length -= _, n;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(a) {
    const n = Mi.allocUnsafe(a), l = a;
    let _ = this.head, v = 0;
    do {
      const w = _.data;
      if (a > w.length)
        Pn(n, w, l - a), a -= w.length;
      else {
        a === w.length ? (Pn(n, w, l - a), ++v, _.next ? this.head = _.next : this.head = this.tail = null) : (Pn(n, new jm(w.buffer, w.byteOffset, a), l - a), this.head = _, _.data = w.slice(a));
        break;
      }
      ++v;
    } while ((_ = _.next) !== null);
    return this.length -= v, n;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](a, n) {
    return Um(this, {
      ...n,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: $m, NumberIsInteger: Gm } = tt, { ERR_INVALID_ARG_VALUE: Vm } = yt.codes;
function zm(r, a, n) {
  return r.highWaterMark != null ? r.highWaterMark : a ? r[n] : null;
}
function Du(r) {
  return r ? 16 : 16 * 1024;
}
function Hm(r, a, n, l) {
  const _ = zm(a, l, n);
  if (_ != null) {
    if (!Gm(_) || _ < 0) {
      const v = l ? `options.${n}` : "options.highWaterMark";
      throw new Vm(v, _);
    }
    return $m(_);
  }
  return Du(r.objectMode);
}
var Fa = {
  getHighWaterMark: Hm,
  getDefaultHighWaterMark: Du
}, Lu = {}, ua = { exports: {} }, Mu = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  var a = Qr, n = Vn, l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = m, r.SlowBuffer = ee, r.INSPECT_MAX_BYTES = 50;
  var _ = 2147483647;
  r.kMaxLength = _, m.TYPED_ARRAY_SUPPORT = v(), !m.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function v() {
    try {
      var E = new Uint8Array(1), d = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(d, Uint8Array.prototype), Object.setPrototypeOf(E, d), E.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(m.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (m.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(m.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (m.isBuffer(this))
        return this.byteOffset;
    }
  });
  function w(E) {
    if (E > _)
      throw new RangeError('The value "' + E + '" is invalid for option "size"');
    var d = new Uint8Array(E);
    return Object.setPrototypeOf(d, m.prototype), d;
  }
  function m(E, d, p) {
    if (typeof E == "number") {
      if (typeof d == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return J(E);
    }
    return D(E, d, p);
  }
  m.poolSize = 8192;
  function D(E, d, p) {
    if (typeof E == "string")
      return ae(E, d);
    if (ArrayBuffer.isView(E))
      return K(E);
    if (E == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
      );
    if (M(E, ArrayBuffer) || E && M(E.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (M(E, SharedArrayBuffer) || E && M(E.buffer, SharedArrayBuffer)))
      return pe(E, d, p);
    if (typeof E == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var T = E.valueOf && E.valueOf();
    if (T != null && T !== E)
      return m.from(T, d, p);
    var B = he(E);
    if (B)
      return B;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof E[Symbol.toPrimitive] == "function")
      return m.from(
        E[Symbol.toPrimitive]("string"),
        d,
        p
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
    );
  }
  m.from = function(E, d, p) {
    return D(E, d, p);
  }, Object.setPrototypeOf(m.prototype, Uint8Array.prototype), Object.setPrototypeOf(m, Uint8Array);
  function L(E) {
    if (typeof E != "number")
      throw new TypeError('"size" argument must be of type number');
    if (E < 0)
      throw new RangeError('The value "' + E + '" is invalid for option "size"');
  }
  function O(E, d, p) {
    return L(E), E <= 0 ? w(E) : d !== void 0 ? typeof p == "string" ? w(E).fill(d, p) : w(E).fill(d) : w(E);
  }
  m.alloc = function(E, d, p) {
    return O(E, d, p);
  };
  function J(E) {
    return L(E), w(E < 0 ? 0 : ce(E) | 0);
  }
  m.allocUnsafe = function(E) {
    return J(E);
  }, m.allocUnsafeSlow = function(E) {
    return J(E);
  };
  function ae(E, d) {
    if ((typeof d != "string" || d === "") && (d = "utf8"), !m.isEncoding(d))
      throw new TypeError("Unknown encoding: " + d);
    var p = Te(E, d) | 0, T = w(p), B = T.write(E, d);
    return B !== p && (T = T.slice(0, B)), T;
  }
  function q(E) {
    for (var d = E.length < 0 ? 0 : ce(E.length) | 0, p = w(d), T = 0; T < d; T += 1)
      p[T] = E[T] & 255;
    return p;
  }
  function K(E) {
    if (M(E, Uint8Array)) {
      var d = new Uint8Array(E);
      return pe(d.buffer, d.byteOffset, d.byteLength);
    }
    return q(E);
  }
  function pe(E, d, p) {
    if (d < 0 || E.byteLength < d)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (E.byteLength < d + (p || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var T;
    return d === void 0 && p === void 0 ? T = new Uint8Array(E) : p === void 0 ? T = new Uint8Array(E, d) : T = new Uint8Array(E, d, p), Object.setPrototypeOf(T, m.prototype), T;
  }
  function he(E) {
    if (m.isBuffer(E)) {
      var d = ce(E.length) | 0, p = w(d);
      return p.length === 0 || E.copy(p, 0, 0, d), p;
    }
    if (E.length !== void 0)
      return typeof E.length != "number" || j(E.length) ? w(0) : q(E);
    if (E.type === "Buffer" && Array.isArray(E.data))
      return q(E.data);
  }
  function ce(E) {
    if (E >= _)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + _.toString(16) + " bytes");
    return E | 0;
  }
  function ee(E) {
    return +E != E && (E = 0), m.alloc(+E);
  }
  m.isBuffer = function(d) {
    return d != null && d._isBuffer === !0 && d !== m.prototype;
  }, m.compare = function(d, p) {
    if (M(d, Uint8Array) && (d = m.from(d, d.offset, d.byteLength)), M(p, Uint8Array) && (p = m.from(p, p.offset, p.byteLength)), !m.isBuffer(d) || !m.isBuffer(p))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (d === p)
      return 0;
    for (var T = d.length, B = p.length, N = 0, V = Math.min(T, B); N < V; ++N)
      if (d[N] !== p[N]) {
        T = d[N], B = p[N];
        break;
      }
    return T < B ? -1 : B < T ? 1 : 0;
  }, m.isEncoding = function(d) {
    switch (String(d).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, m.concat = function(d, p) {
    if (!Array.isArray(d))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (d.length === 0)
      return m.alloc(0);
    var T;
    if (p === void 0)
      for (p = 0, T = 0; T < d.length; ++T)
        p += d[T].length;
    var B = m.allocUnsafe(p), N = 0;
    for (T = 0; T < d.length; ++T) {
      var V = d[T];
      if (M(V, Uint8Array))
        N + V.length > B.length ? m.from(V).copy(B, N) : Uint8Array.prototype.set.call(
          B,
          V,
          N
        );
      else if (m.isBuffer(V))
        V.copy(B, N);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      N += V.length;
    }
    return B;
  };
  function Te(E, d) {
    if (m.isBuffer(E))
      return E.length;
    if (ArrayBuffer.isView(E) || M(E, ArrayBuffer))
      return E.byteLength;
    if (typeof E != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof E
      );
    var p = E.length, T = arguments.length > 2 && arguments[2] === !0;
    if (!T && p === 0)
      return 0;
    for (var B = !1; ; )
      switch (d) {
        case "ascii":
        case "latin1":
        case "binary":
          return p;
        case "utf8":
        case "utf-8":
          return Ye(E).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return p * 2;
        case "hex":
          return p >>> 1;
        case "base64":
          return rt(E).length;
        default:
          if (B)
            return T ? -1 : Ye(E).length;
          d = ("" + d).toLowerCase(), B = !0;
      }
  }
  m.byteLength = Te;
  function Oe(E, d, p) {
    var T = !1;
    if ((d === void 0 || d < 0) && (d = 0), d > this.length || ((p === void 0 || p > this.length) && (p = this.length), p <= 0) || (p >>>= 0, d >>>= 0, p <= d))
      return "";
    for (E || (E = "utf8"); ; )
      switch (E) {
        case "hex":
          return it(this, d, p);
        case "utf8":
        case "utf-8":
          return ke(this, d, p);
        case "ascii":
          return ze(this, d, p);
        case "latin1":
        case "binary":
          return Be(this, d, p);
        case "base64":
          return De(this, d, p);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, d, p);
        default:
          if (T)
            throw new TypeError("Unknown encoding: " + E);
          E = (E + "").toLowerCase(), T = !0;
      }
  }
  m.prototype._isBuffer = !0;
  function me(E, d, p) {
    var T = E[d];
    E[d] = E[p], E[p] = T;
  }
  m.prototype.swap16 = function() {
    var d = this.length;
    if (d % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var p = 0; p < d; p += 2)
      me(this, p, p + 1);
    return this;
  }, m.prototype.swap32 = function() {
    var d = this.length;
    if (d % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var p = 0; p < d; p += 4)
      me(this, p, p + 3), me(this, p + 1, p + 2);
    return this;
  }, m.prototype.swap64 = function() {
    var d = this.length;
    if (d % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var p = 0; p < d; p += 8)
      me(this, p, p + 7), me(this, p + 1, p + 6), me(this, p + 2, p + 5), me(this, p + 3, p + 4);
    return this;
  }, m.prototype.toString = function() {
    var d = this.length;
    return d === 0 ? "" : arguments.length === 0 ? ke(this, 0, d) : Oe.apply(this, arguments);
  }, m.prototype.toLocaleString = m.prototype.toString, m.prototype.equals = function(d) {
    if (!m.isBuffer(d))
      throw new TypeError("Argument must be a Buffer");
    return this === d ? !0 : m.compare(this, d) === 0;
  }, m.prototype.inspect = function() {
    var d = "", p = r.INSPECT_MAX_BYTES;
    return d = this.toString("hex", 0, p).replace(/(.{2})/g, "$1 ").trim(), this.length > p && (d += " ... "), "<Buffer " + d + ">";
  }, l && (m.prototype[l] = m.prototype.inspect), m.prototype.compare = function(d, p, T, B, N) {
    if (M(d, Uint8Array) && (d = m.from(d, d.offset, d.byteLength)), !m.isBuffer(d))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof d
      );
    if (p === void 0 && (p = 0), T === void 0 && (T = d ? d.length : 0), B === void 0 && (B = 0), N === void 0 && (N = this.length), p < 0 || T > d.length || B < 0 || N > this.length)
      throw new RangeError("out of range index");
    if (B >= N && p >= T)
      return 0;
    if (B >= N)
      return -1;
    if (p >= T)
      return 1;
    if (p >>>= 0, T >>>= 0, B >>>= 0, N >>>= 0, this === d)
      return 0;
    for (var V = N - B, Ce = T - p, Ne = Math.min(V, Ce), S = this.slice(B, N), R = d.slice(p, T), y = 0; y < Ne; ++y)
      if (S[y] !== R[y]) {
        V = S[y], Ce = R[y];
        break;
      }
    return V < Ce ? -1 : Ce < V ? 1 : 0;
  };
  function Ee(E, d, p, T, B) {
    if (E.length === 0)
      return -1;
    if (typeof p == "string" ? (T = p, p = 0) : p > 2147483647 ? p = 2147483647 : p < -2147483648 && (p = -2147483648), p = +p, j(p) && (p = B ? 0 : E.length - 1), p < 0 && (p = E.length + p), p >= E.length) {
      if (B)
        return -1;
      p = E.length - 1;
    } else if (p < 0)
      if (B)
        p = 0;
      else
        return -1;
    if (typeof d == "string" && (d = m.from(d, T)), m.isBuffer(d))
      return d.length === 0 ? -1 : de(E, d, p, T, B);
    if (typeof d == "number")
      return d = d & 255, typeof Uint8Array.prototype.indexOf == "function" ? B ? Uint8Array.prototype.indexOf.call(E, d, p) : Uint8Array.prototype.lastIndexOf.call(E, d, p) : de(E, [d], p, T, B);
    throw new TypeError("val must be string, number or Buffer");
  }
  function de(E, d, p, T, B) {
    var N = 1, V = E.length, Ce = d.length;
    if (T !== void 0 && (T = String(T).toLowerCase(), T === "ucs2" || T === "ucs-2" || T === "utf16le" || T === "utf-16le")) {
      if (E.length < 2 || d.length < 2)
        return -1;
      N = 2, V /= 2, Ce /= 2, p /= 2;
    }
    function Ne(f, C) {
      return N === 1 ? f[C] : f.readUInt16BE(C * N);
    }
    var S;
    if (B) {
      var R = -1;
      for (S = p; S < V; S++)
        if (Ne(E, S) === Ne(d, R === -1 ? 0 : S - R)) {
          if (R === -1 && (R = S), S - R + 1 === Ce)
            return R * N;
        } else
          R !== -1 && (S -= S - R), R = -1;
    } else
      for (p + Ce > V && (p = V - Ce), S = p; S >= 0; S--) {
        for (var y = !0, u = 0; u < Ce; u++)
          if (Ne(E, S + u) !== Ne(d, u)) {
            y = !1;
            break;
          }
        if (y)
          return S;
      }
    return -1;
  }
  m.prototype.includes = function(d, p, T) {
    return this.indexOf(d, p, T) !== -1;
  }, m.prototype.indexOf = function(d, p, T) {
    return Ee(this, d, p, T, !0);
  }, m.prototype.lastIndexOf = function(d, p, T) {
    return Ee(this, d, p, T, !1);
  };
  function Re(E, d, p, T) {
    p = Number(p) || 0;
    var B = E.length - p;
    T ? (T = Number(T), T > B && (T = B)) : T = B;
    var N = d.length;
    T > N / 2 && (T = N / 2);
    for (var V = 0; V < T; ++V) {
      var Ce = parseInt(d.substr(V * 2, 2), 16);
      if (j(Ce))
        return V;
      E[p + V] = Ce;
    }
    return V;
  }
  function ye(E, d, p, T) {
    return qe(Ye(d, E.length - p), E, p, T);
  }
  function I(E, d, p, T) {
    return qe(ft(d), E, p, T);
  }
  function X(E, d, p, T) {
    return qe(rt(d), E, p, T);
  }
  function je(E, d, p, T) {
    return qe(mt(d, E.length - p), E, p, T);
  }
  m.prototype.write = function(d, p, T, B) {
    if (p === void 0)
      B = "utf8", T = this.length, p = 0;
    else if (T === void 0 && typeof p == "string")
      B = p, T = this.length, p = 0;
    else if (isFinite(p))
      p = p >>> 0, isFinite(T) ? (T = T >>> 0, B === void 0 && (B = "utf8")) : (B = T, T = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var N = this.length - p;
    if ((T === void 0 || T > N) && (T = N), d.length > 0 && (T < 0 || p < 0) || p > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    B || (B = "utf8");
    for (var V = !1; ; )
      switch (B) {
        case "hex":
          return Re(this, d, p, T);
        case "utf8":
        case "utf-8":
          return ye(this, d, p, T);
        case "ascii":
        case "latin1":
        case "binary":
          return I(this, d, p, T);
        case "base64":
          return X(this, d, p, T);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return je(this, d, p, T);
        default:
          if (V)
            throw new TypeError("Unknown encoding: " + B);
          B = ("" + B).toLowerCase(), V = !0;
      }
  }, m.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function De(E, d, p) {
    return d === 0 && p === E.length ? a.fromByteArray(E) : a.fromByteArray(E.slice(d, p));
  }
  function ke(E, d, p) {
    p = Math.min(E.length, p);
    for (var T = [], B = d; B < p; ) {
      var N = E[B], V = null, Ce = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1;
      if (B + Ce <= p) {
        var Ne, S, R, y;
        switch (Ce) {
          case 1:
            N < 128 && (V = N);
            break;
          case 2:
            Ne = E[B + 1], (Ne & 192) === 128 && (y = (N & 31) << 6 | Ne & 63, y > 127 && (V = y));
            break;
          case 3:
            Ne = E[B + 1], S = E[B + 2], (Ne & 192) === 128 && (S & 192) === 128 && (y = (N & 15) << 12 | (Ne & 63) << 6 | S & 63, y > 2047 && (y < 55296 || y > 57343) && (V = y));
            break;
          case 4:
            Ne = E[B + 1], S = E[B + 2], R = E[B + 3], (Ne & 192) === 128 && (S & 192) === 128 && (R & 192) === 128 && (y = (N & 15) << 18 | (Ne & 63) << 12 | (S & 63) << 6 | R & 63, y > 65535 && y < 1114112 && (V = y));
        }
      }
      V === null ? (V = 65533, Ce = 1) : V > 65535 && (V -= 65536, T.push(V >>> 10 & 1023 | 55296), V = 56320 | V & 1023), T.push(V), B += Ce;
    }
    return $e(T);
  }
  var ge = 4096;
  function $e(E) {
    var d = E.length;
    if (d <= ge)
      return String.fromCharCode.apply(String, E);
    for (var p = "", T = 0; T < d; )
      p += String.fromCharCode.apply(
        String,
        E.slice(T, T += ge)
      );
    return p;
  }
  function ze(E, d, p) {
    var T = "";
    p = Math.min(E.length, p);
    for (var B = d; B < p; ++B)
      T += String.fromCharCode(E[B] & 127);
    return T;
  }
  function Be(E, d, p) {
    var T = "";
    p = Math.min(E.length, p);
    for (var B = d; B < p; ++B)
      T += String.fromCharCode(E[B]);
    return T;
  }
  function it(E, d, p) {
    var T = E.length;
    (!d || d < 0) && (d = 0), (!p || p < 0 || p > T) && (p = T);
    for (var B = "", N = d; N < p; ++N)
      B += Q[E[N]];
    return B;
  }
  function ie(E, d, p) {
    for (var T = E.slice(d, p), B = "", N = 0; N < T.length - 1; N += 2)
      B += String.fromCharCode(T[N] + T[N + 1] * 256);
    return B;
  }
  m.prototype.slice = function(d, p) {
    var T = this.length;
    d = ~~d, p = p === void 0 ? T : ~~p, d < 0 ? (d += T, d < 0 && (d = 0)) : d > T && (d = T), p < 0 ? (p += T, p < 0 && (p = 0)) : p > T && (p = T), p < d && (p = d);
    var B = this.subarray(d, p);
    return Object.setPrototypeOf(B, m.prototype), B;
  };
  function we(E, d, p) {
    if (E % 1 !== 0 || E < 0)
      throw new RangeError("offset is not uint");
    if (E + d > p)
      throw new RangeError("Trying to access beyond buffer length");
  }
  m.prototype.readUintLE = m.prototype.readUIntLE = function(d, p, T) {
    d = d >>> 0, p = p >>> 0, T || we(d, p, this.length);
    for (var B = this[d], N = 1, V = 0; ++V < p && (N *= 256); )
      B += this[d + V] * N;
    return B;
  }, m.prototype.readUintBE = m.prototype.readUIntBE = function(d, p, T) {
    d = d >>> 0, p = p >>> 0, T || we(d, p, this.length);
    for (var B = this[d + --p], N = 1; p > 0 && (N *= 256); )
      B += this[d + --p] * N;
    return B;
  }, m.prototype.readUint8 = m.prototype.readUInt8 = function(d, p) {
    return d = d >>> 0, p || we(d, 1, this.length), this[d];
  }, m.prototype.readUint16LE = m.prototype.readUInt16LE = function(d, p) {
    return d = d >>> 0, p || we(d, 2, this.length), this[d] | this[d + 1] << 8;
  }, m.prototype.readUint16BE = m.prototype.readUInt16BE = function(d, p) {
    return d = d >>> 0, p || we(d, 2, this.length), this[d] << 8 | this[d + 1];
  }, m.prototype.readUint32LE = m.prototype.readUInt32LE = function(d, p) {
    return d = d >>> 0, p || we(d, 4, this.length), (this[d] | this[d + 1] << 8 | this[d + 2] << 16) + this[d + 3] * 16777216;
  }, m.prototype.readUint32BE = m.prototype.readUInt32BE = function(d, p) {
    return d = d >>> 0, p || we(d, 4, this.length), this[d] * 16777216 + (this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3]);
  }, m.prototype.readIntLE = function(d, p, T) {
    d = d >>> 0, p = p >>> 0, T || we(d, p, this.length);
    for (var B = this[d], N = 1, V = 0; ++V < p && (N *= 256); )
      B += this[d + V] * N;
    return N *= 128, B >= N && (B -= Math.pow(2, 8 * p)), B;
  }, m.prototype.readIntBE = function(d, p, T) {
    d = d >>> 0, p = p >>> 0, T || we(d, p, this.length);
    for (var B = p, N = 1, V = this[d + --B]; B > 0 && (N *= 256); )
      V += this[d + --B] * N;
    return N *= 128, V >= N && (V -= Math.pow(2, 8 * p)), V;
  }, m.prototype.readInt8 = function(d, p) {
    return d = d >>> 0, p || we(d, 1, this.length), this[d] & 128 ? (255 - this[d] + 1) * -1 : this[d];
  }, m.prototype.readInt16LE = function(d, p) {
    d = d >>> 0, p || we(d, 2, this.length);
    var T = this[d] | this[d + 1] << 8;
    return T & 32768 ? T | 4294901760 : T;
  }, m.prototype.readInt16BE = function(d, p) {
    d = d >>> 0, p || we(d, 2, this.length);
    var T = this[d + 1] | this[d] << 8;
    return T & 32768 ? T | 4294901760 : T;
  }, m.prototype.readInt32LE = function(d, p) {
    return d = d >>> 0, p || we(d, 4, this.length), this[d] | this[d + 1] << 8 | this[d + 2] << 16 | this[d + 3] << 24;
  }, m.prototype.readInt32BE = function(d, p) {
    return d = d >>> 0, p || we(d, 4, this.length), this[d] << 24 | this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3];
  }, m.prototype.readFloatLE = function(d, p) {
    return d = d >>> 0, p || we(d, 4, this.length), n.read(this, d, !0, 23, 4);
  }, m.prototype.readFloatBE = function(d, p) {
    return d = d >>> 0, p || we(d, 4, this.length), n.read(this, d, !1, 23, 4);
  }, m.prototype.readDoubleLE = function(d, p) {
    return d = d >>> 0, p || we(d, 8, this.length), n.read(this, d, !0, 52, 8);
  }, m.prototype.readDoubleBE = function(d, p) {
    return d = d >>> 0, p || we(d, 8, this.length), n.read(this, d, !1, 52, 8);
  };
  function Ie(E, d, p, T, B, N) {
    if (!m.isBuffer(E))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (d > B || d < N)
      throw new RangeError('"value" argument is out of bounds');
    if (p + T > E.length)
      throw new RangeError("Index out of range");
  }
  m.prototype.writeUintLE = m.prototype.writeUIntLE = function(d, p, T, B) {
    if (d = +d, p = p >>> 0, T = T >>> 0, !B) {
      var N = Math.pow(2, 8 * T) - 1;
      Ie(this, d, p, T, N, 0);
    }
    var V = 1, Ce = 0;
    for (this[p] = d & 255; ++Ce < T && (V *= 256); )
      this[p + Ce] = d / V & 255;
    return p + T;
  }, m.prototype.writeUintBE = m.prototype.writeUIntBE = function(d, p, T, B) {
    if (d = +d, p = p >>> 0, T = T >>> 0, !B) {
      var N = Math.pow(2, 8 * T) - 1;
      Ie(this, d, p, T, N, 0);
    }
    var V = T - 1, Ce = 1;
    for (this[p + V] = d & 255; --V >= 0 && (Ce *= 256); )
      this[p + V] = d / Ce & 255;
    return p + T;
  }, m.prototype.writeUint8 = m.prototype.writeUInt8 = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 1, 255, 0), this[p] = d & 255, p + 1;
  }, m.prototype.writeUint16LE = m.prototype.writeUInt16LE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 2, 65535, 0), this[p] = d & 255, this[p + 1] = d >>> 8, p + 2;
  }, m.prototype.writeUint16BE = m.prototype.writeUInt16BE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 2, 65535, 0), this[p] = d >>> 8, this[p + 1] = d & 255, p + 2;
  }, m.prototype.writeUint32LE = m.prototype.writeUInt32LE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 4, 4294967295, 0), this[p + 3] = d >>> 24, this[p + 2] = d >>> 16, this[p + 1] = d >>> 8, this[p] = d & 255, p + 4;
  }, m.prototype.writeUint32BE = m.prototype.writeUInt32BE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 4, 4294967295, 0), this[p] = d >>> 24, this[p + 1] = d >>> 16, this[p + 2] = d >>> 8, this[p + 3] = d & 255, p + 4;
  }, m.prototype.writeIntLE = function(d, p, T, B) {
    if (d = +d, p = p >>> 0, !B) {
      var N = Math.pow(2, 8 * T - 1);
      Ie(this, d, p, T, N - 1, -N);
    }
    var V = 0, Ce = 1, Ne = 0;
    for (this[p] = d & 255; ++V < T && (Ce *= 256); )
      d < 0 && Ne === 0 && this[p + V - 1] !== 0 && (Ne = 1), this[p + V] = (d / Ce >> 0) - Ne & 255;
    return p + T;
  }, m.prototype.writeIntBE = function(d, p, T, B) {
    if (d = +d, p = p >>> 0, !B) {
      var N = Math.pow(2, 8 * T - 1);
      Ie(this, d, p, T, N - 1, -N);
    }
    var V = T - 1, Ce = 1, Ne = 0;
    for (this[p + V] = d & 255; --V >= 0 && (Ce *= 256); )
      d < 0 && Ne === 0 && this[p + V + 1] !== 0 && (Ne = 1), this[p + V] = (d / Ce >> 0) - Ne & 255;
    return p + T;
  }, m.prototype.writeInt8 = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 1, 127, -128), d < 0 && (d = 255 + d + 1), this[p] = d & 255, p + 1;
  }, m.prototype.writeInt16LE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 2, 32767, -32768), this[p] = d & 255, this[p + 1] = d >>> 8, p + 2;
  }, m.prototype.writeInt16BE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 2, 32767, -32768), this[p] = d >>> 8, this[p + 1] = d & 255, p + 2;
  }, m.prototype.writeInt32LE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 4, 2147483647, -2147483648), this[p] = d & 255, this[p + 1] = d >>> 8, this[p + 2] = d >>> 16, this[p + 3] = d >>> 24, p + 4;
  }, m.prototype.writeInt32BE = function(d, p, T) {
    return d = +d, p = p >>> 0, T || Ie(this, d, p, 4, 2147483647, -2147483648), d < 0 && (d = 4294967295 + d + 1), this[p] = d >>> 24, this[p + 1] = d >>> 16, this[p + 2] = d >>> 8, this[p + 3] = d & 255, p + 4;
  };
  function gt(E, d, p, T, B, N) {
    if (p + T > E.length)
      throw new RangeError("Index out of range");
    if (p < 0)
      throw new RangeError("Index out of range");
  }
  function wt(E, d, p, T, B) {
    return d = +d, p = p >>> 0, B || gt(E, d, p, 4), n.write(E, d, p, T, 23, 4), p + 4;
  }
  m.prototype.writeFloatLE = function(d, p, T) {
    return wt(this, d, p, !0, T);
  }, m.prototype.writeFloatBE = function(d, p, T) {
    return wt(this, d, p, !1, T);
  };
  function lt(E, d, p, T, B) {
    return d = +d, p = p >>> 0, B || gt(E, d, p, 8), n.write(E, d, p, T, 52, 8), p + 8;
  }
  m.prototype.writeDoubleLE = function(d, p, T) {
    return lt(this, d, p, !0, T);
  }, m.prototype.writeDoubleBE = function(d, p, T) {
    return lt(this, d, p, !1, T);
  }, m.prototype.copy = function(d, p, T, B) {
    if (!m.isBuffer(d))
      throw new TypeError("argument should be a Buffer");
    if (T || (T = 0), !B && B !== 0 && (B = this.length), p >= d.length && (p = d.length), p || (p = 0), B > 0 && B < T && (B = T), B === T || d.length === 0 || this.length === 0)
      return 0;
    if (p < 0)
      throw new RangeError("targetStart out of bounds");
    if (T < 0 || T >= this.length)
      throw new RangeError("Index out of range");
    if (B < 0)
      throw new RangeError("sourceEnd out of bounds");
    B > this.length && (B = this.length), d.length - p < B - T && (B = d.length - p + T);
    var N = B - T;
    return this === d && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(p, T, B) : Uint8Array.prototype.set.call(
      d,
      this.subarray(T, B),
      p
    ), N;
  }, m.prototype.fill = function(d, p, T, B) {
    if (typeof d == "string") {
      if (typeof p == "string" ? (B = p, p = 0, T = this.length) : typeof T == "string" && (B = T, T = this.length), B !== void 0 && typeof B != "string")
        throw new TypeError("encoding must be a string");
      if (typeof B == "string" && !m.isEncoding(B))
        throw new TypeError("Unknown encoding: " + B);
      if (d.length === 1) {
        var N = d.charCodeAt(0);
        (B === "utf8" && N < 128 || B === "latin1") && (d = N);
      }
    } else
      typeof d == "number" ? d = d & 255 : typeof d == "boolean" && (d = Number(d));
    if (p < 0 || this.length < p || this.length < T)
      throw new RangeError("Out of range index");
    if (T <= p)
      return this;
    p = p >>> 0, T = T === void 0 ? this.length : T >>> 0, d || (d = 0);
    var V;
    if (typeof d == "number")
      for (V = p; V < T; ++V)
        this[V] = d;
    else {
      var Ce = m.isBuffer(d) ? d : m.from(d, B), Ne = Ce.length;
      if (Ne === 0)
        throw new TypeError('The value "' + d + '" is invalid for argument "value"');
      for (V = 0; V < T - p; ++V)
        this[V + p] = Ce[V % Ne];
    }
    return this;
  };
  var Pt = /[^+/0-9A-Za-z-_]/g;
  function Je(E) {
    if (E = E.split("=")[0], E = E.trim().replace(Pt, ""), E.length < 2)
      return "";
    for (; E.length % 4 !== 0; )
      E = E + "=";
    return E;
  }
  function Ye(E, d) {
    d = d || 1 / 0;
    for (var p, T = E.length, B = null, N = [], V = 0; V < T; ++V) {
      if (p = E.charCodeAt(V), p > 55295 && p < 57344) {
        if (!B) {
          if (p > 56319) {
            (d -= 3) > -1 && N.push(239, 191, 189);
            continue;
          } else if (V + 1 === T) {
            (d -= 3) > -1 && N.push(239, 191, 189);
            continue;
          }
          B = p;
          continue;
        }
        if (p < 56320) {
          (d -= 3) > -1 && N.push(239, 191, 189), B = p;
          continue;
        }
        p = (B - 55296 << 10 | p - 56320) + 65536;
      } else
        B && (d -= 3) > -1 && N.push(239, 191, 189);
      if (B = null, p < 128) {
        if ((d -= 1) < 0)
          break;
        N.push(p);
      } else if (p < 2048) {
        if ((d -= 2) < 0)
          break;
        N.push(
          p >> 6 | 192,
          p & 63 | 128
        );
      } else if (p < 65536) {
        if ((d -= 3) < 0)
          break;
        N.push(
          p >> 12 | 224,
          p >> 6 & 63 | 128,
          p & 63 | 128
        );
      } else if (p < 1114112) {
        if ((d -= 4) < 0)
          break;
        N.push(
          p >> 18 | 240,
          p >> 12 & 63 | 128,
          p >> 6 & 63 | 128,
          p & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return N;
  }
  function ft(E) {
    for (var d = [], p = 0; p < E.length; ++p)
      d.push(E.charCodeAt(p) & 255);
    return d;
  }
  function mt(E, d) {
    for (var p, T, B, N = [], V = 0; V < E.length && !((d -= 2) < 0); ++V)
      p = E.charCodeAt(V), T = p >> 8, B = p % 256, N.push(B), N.push(T);
    return N;
  }
  function rt(E) {
    return a.toByteArray(Je(E));
  }
  function qe(E, d, p, T) {
    for (var B = 0; B < T && !(B + p >= d.length || B >= E.length); ++B)
      d[B + p] = E[B];
    return B;
  }
  function M(E, d) {
    return E instanceof d || E != null && E.constructor != null && E.constructor.name != null && E.constructor.name === d.name;
  }
  function j(E) {
    return E !== E;
  }
  var Q = function() {
    for (var E = "0123456789abcdef", d = new Array(256), p = 0; p < 16; ++p)
      for (var T = p * 16, B = 0; B < 16; ++B)
        d[T + B] = E[p] + E[B];
    return d;
  }();
})(Mu);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(r, a) {
  var n = Mu, l = n.Buffer;
  function _(w, m) {
    for (var D in w)
      m[D] = w[D];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? r.exports = n : (_(n, a), a.Buffer = v);
  function v(w, m, D) {
    return l(w, m, D);
  }
  v.prototype = Object.create(l.prototype), _(l, v), v.from = function(w, m, D) {
    if (typeof w == "number")
      throw new TypeError("Argument must not be a number");
    return l(w, m, D);
  }, v.alloc = function(w, m, D) {
    if (typeof w != "number")
      throw new TypeError("Argument must be a number");
    var L = l(w);
    return m !== void 0 ? typeof D == "string" ? L.fill(m, D) : L.fill(m) : L.fill(0), L;
  }, v.allocUnsafe = function(w) {
    if (typeof w != "number")
      throw new TypeError("Argument must be a number");
    return l(w);
  }, v.allocUnsafeSlow = function(w) {
    if (typeof w != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(w);
  };
})(ua, ua.exports);
var Km = ua.exports, Ra = Km.Buffer, es = Ra.isEncoding || function(r) {
  switch (r = "" + r, r && r.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function Ym(r) {
  if (!r)
    return "utf8";
  for (var a; ; )
    switch (r) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return r;
      default:
        if (a)
          return;
        r = ("" + r).toLowerCase(), a = !0;
    }
}
function Xm(r) {
  var a = Ym(r);
  if (typeof a != "string" && (Ra.isEncoding === es || !es(r)))
    throw new Error("Unknown encoding: " + r);
  return a || r;
}
Lu.StringDecoder = Jr;
function Jr(r) {
  this.encoding = Xm(r);
  var a;
  switch (this.encoding) {
    case "utf16le":
      this.text = t_, this.end = r_, a = 4;
      break;
    case "utf8":
      this.fillLast = Qm, a = 4;
      break;
    case "base64":
      this.text = n_, this.end = i_, a = 3;
      break;
    default:
      this.write = a_, this.end = o_;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Ra.allocUnsafe(a);
}
Jr.prototype.write = function(r) {
  if (r.length === 0)
    return "";
  var a, n;
  if (this.lastNeed) {
    if (a = this.fillLast(r), a === void 0)
      return "";
    n = this.lastNeed, this.lastNeed = 0;
  } else
    n = 0;
  return n < r.length ? a ? a + this.text(r, n) : this.text(r, n) : a || "";
};
Jr.prototype.end = e_;
Jr.prototype.text = Jm;
Jr.prototype.fillLast = function(r) {
  if (this.lastNeed <= r.length)
    return r.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  r.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, r.length), this.lastNeed -= r.length;
};
function Bi(r) {
  return r <= 127 ? 0 : r >> 5 === 6 ? 2 : r >> 4 === 14 ? 3 : r >> 3 === 30 ? 4 : r >> 6 === 2 ? -1 : -2;
}
function Zm(r, a, n) {
  var l = a.length - 1;
  if (l < n)
    return 0;
  var _ = Bi(a[l]);
  return _ >= 0 ? (_ > 0 && (r.lastNeed = _ - 1), _) : --l < n || _ === -2 ? 0 : (_ = Bi(a[l]), _ >= 0 ? (_ > 0 && (r.lastNeed = _ - 2), _) : --l < n || _ === -2 ? 0 : (_ = Bi(a[l]), _ >= 0 ? (_ > 0 && (_ === 2 ? _ = 0 : r.lastNeed = _ - 3), _) : 0));
}
function qm(r, a, n) {
  if ((a[0] & 192) !== 128)
    return r.lastNeed = 0, "ï¿½";
  if (r.lastNeed > 1 && a.length > 1) {
    if ((a[1] & 192) !== 128)
      return r.lastNeed = 1, "ï¿½";
    if (r.lastNeed > 2 && a.length > 2 && (a[2] & 192) !== 128)
      return r.lastNeed = 2, "ï¿½";
  }
}
function Qm(r) {
  var a = this.lastTotal - this.lastNeed, n = qm(this, r);
  if (n !== void 0)
    return n;
  if (this.lastNeed <= r.length)
    return r.copy(this.lastChar, a, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  r.copy(this.lastChar, a, 0, r.length), this.lastNeed -= r.length;
}
function Jm(r, a) {
  var n = Zm(this, r, a);
  if (!this.lastNeed)
    return r.toString("utf8", a);
  this.lastTotal = n;
  var l = r.length - (n - this.lastNeed);
  return r.copy(this.lastChar, 0, l), r.toString("utf8", a, l);
}
function e_(r) {
  var a = r && r.length ? this.write(r) : "";
  return this.lastNeed ? a + "ï¿½" : a;
}
function t_(r, a) {
  if ((r.length - a) % 2 === 0) {
    var n = r.toString("utf16le", a);
    if (n) {
      var l = n.charCodeAt(n.length - 1);
      if (l >= 55296 && l <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = r[r.length - 2], this.lastChar[1] = r[r.length - 1], n.slice(0, -1);
    }
    return n;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = r[r.length - 1], r.toString("utf16le", a, r.length - 1);
}
function r_(r) {
  var a = r && r.length ? this.write(r) : "";
  if (this.lastNeed) {
    var n = this.lastTotal - this.lastNeed;
    return a + this.lastChar.toString("utf16le", 0, n);
  }
  return a;
}
function n_(r, a) {
  var n = (r.length - a) % 3;
  return n === 0 ? r.toString("base64", a) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = r[r.length - 1] : (this.lastChar[0] = r[r.length - 2], this.lastChar[1] = r[r.length - 1]), r.toString("base64", a, r.length - n));
}
function i_(r) {
  var a = r && r.length ? this.write(r) : "";
  return this.lastNeed ? a + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : a;
}
function a_(r) {
  return r.toString(this.encoding);
}
function o_(r) {
  return r && r.length ? this.write(r) : "";
}
const ts = hr, { PromisePrototypeThen: s_, SymbolAsyncIterator: rs, SymbolIterator: ns } = tt, { Buffer: u_ } = er, { ERR_INVALID_ARG_TYPE: l_, ERR_STREAM_NULL_VALUES: f_ } = yt.codes;
function c_(r, a, n) {
  let l;
  if (typeof a == "string" || a instanceof u_)
    return new r({
      objectMode: !0,
      ...n,
      read() {
        this.push(a), this.push(null);
      }
    });
  let _;
  if (a && a[rs])
    _ = !0, l = a[rs]();
  else if (a && a[ns])
    _ = !1, l = a[ns]();
  else
    throw new l_("iterable", ["Iterable"], a);
  const v = new r({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...n
  });
  let w = !1;
  v._read = function() {
    w || (w = !0, D());
  }, v._destroy = function(L, O) {
    s_(
      m(L),
      () => ts.nextTick(O, L),
      // nextTick is here in case cb throws
      (J) => ts.nextTick(O, J || L)
    );
  };
  async function m(L) {
    const O = L != null, J = typeof l.throw == "function";
    if (O && J) {
      const { value: ae, done: q } = await l.throw(L);
      if (await ae, q)
        return;
    }
    if (typeof l.return == "function") {
      const { value: ae } = await l.return();
      await ae;
    }
  }
  async function D() {
    for (; ; ) {
      try {
        const { value: L, done: O } = _ ? await l.next() : l.next();
        if (O)
          v.push(null);
        else {
          const J = L && typeof L.then == "function" ? await L : L;
          if (J === null)
            throw w = !1, new f_();
          if (v.push(J))
            continue;
          w = !1;
        }
      } catch (L) {
        v.destroy(L);
      }
      break;
    }
  }
  return v;
}
var Bu = c_, Ni, is;
function ti() {
  if (is)
    return Ni;
  is = 1;
  const r = hr, {
    ArrayPrototypeIndexOf: a,
    NumberIsInteger: n,
    NumberIsNaN: l,
    NumberParseInt: _,
    ObjectDefineProperties: v,
    ObjectKeys: w,
    ObjectSetPrototypeOf: m,
    Promise: D,
    SafeSet: L,
    SymbolAsyncIterator: O,
    Symbol: J
  } = tt;
  Ni = ie, ie.ReadableState = it;
  const { EventEmitter: ae } = Ca, { Stream: q, prependListener: K } = Ta, { Buffer: pe } = er, { addAbortSignal: he } = ei, ce = tr;
  let ee = Ht.debuglog("stream", (S) => {
    ee = S;
  });
  const Te = Wm, Oe = kr, { getHighWaterMark: me, getDefaultHighWaterMark: Ee } = Fa, {
    aggregateTwoErrors: de,
    codes: {
      ERR_INVALID_ARG_TYPE: Re,
      ERR_METHOD_NOT_IMPLEMENTED: ye,
      ERR_OUT_OF_RANGE: I,
      ERR_STREAM_PUSH_AFTER_EOF: X,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: je
    }
  } = yt, { validateObject: De } = Hn, ke = J("kPaused"), { StringDecoder: ge } = Lu, $e = Bu;
  m(ie.prototype, q.prototype), m(ie, q);
  const ze = () => {
  }, { errorOrDestroy: Be } = Oe;
  function it(S, R, y) {
    typeof y != "boolean" && (y = R instanceof Vt()), this.objectMode = !!(S && S.objectMode), y && (this.objectMode = this.objectMode || !!(S && S.readableObjectMode)), this.highWaterMark = S ? me(this, S, "readableHighWaterMark", y) : Ee(!1), this.buffer = new Te(), this.length = 0, this.pipes = [], this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.constructed = !0, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this[ke] = null, this.errorEmitted = !1, this.emitClose = !S || S.emitClose !== !1, this.autoDestroy = !S || S.autoDestroy !== !1, this.destroyed = !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this.defaultEncoding = S && S.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = !1, this.readingMore = !1, this.dataEmitted = !1, this.decoder = null, this.encoding = null, S && S.encoding && (this.decoder = new ge(S.encoding), this.encoding = S.encoding);
  }
  function ie(S) {
    if (!(this instanceof ie))
      return new ie(S);
    const R = this instanceof Vt();
    this._readableState = new it(S, this, R), S && (typeof S.read == "function" && (this._read = S.read), typeof S.destroy == "function" && (this._destroy = S.destroy), typeof S.construct == "function" && (this._construct = S.construct), S.signal && !R && he(S.signal, this)), q.call(this, S), Oe.construct(this, () => {
      this._readableState.needReadable && ft(this, this._readableState);
    });
  }
  ie.prototype.destroy = Oe.destroy, ie.prototype._undestroy = Oe.undestroy, ie.prototype._destroy = function(S, R) {
    R(S);
  }, ie.prototype[ae.captureRejectionSymbol] = function(S) {
    this.destroy(S);
  }, ie.prototype.push = function(S, R) {
    return we(this, S, R, !1);
  }, ie.prototype.unshift = function(S, R) {
    return we(this, S, R, !0);
  };
  function we(S, R, y, u) {
    ee("readableAddChunk", R);
    const f = S._readableState;
    let C;
    if (f.objectMode || (typeof R == "string" ? (y = y || f.defaultEncoding, f.encoding !== y && (u && f.encoding ? R = pe.from(R, y).toString(f.encoding) : (R = pe.from(R, y), y = ""))) : R instanceof pe ? y = "" : q._isUint8Array(R) ? (R = q._uint8ArrayToBuffer(R), y = "") : R != null && (C = new Re("chunk", ["string", "Buffer", "Uint8Array"], R))), C)
      Be(S, C);
    else if (R === null)
      f.reading = !1, Pt(S, f);
    else if (f.objectMode || R && R.length > 0)
      if (u)
        if (f.endEmitted)
          Be(S, new je());
        else {
          if (f.destroyed || f.errored)
            return !1;
          Ie(S, f, R, !0);
        }
      else if (f.ended)
        Be(S, new X());
      else {
        if (f.destroyed || f.errored)
          return !1;
        f.reading = !1, f.decoder && !y ? (R = f.decoder.write(R), f.objectMode || R.length !== 0 ? Ie(S, f, R, !1) : ft(S, f)) : Ie(S, f, R, !1);
      }
    else
      u || (f.reading = !1, ft(S, f));
    return !f.ended && (f.length < f.highWaterMark || f.length === 0);
  }
  function Ie(S, R, y, u) {
    R.flowing && R.length === 0 && !R.sync && S.listenerCount("data") > 0 ? (R.multiAwaitDrain ? R.awaitDrainWriters.clear() : R.awaitDrainWriters = null, R.dataEmitted = !0, S.emit("data", y)) : (R.length += R.objectMode ? 1 : y.length, u ? R.buffer.unshift(y) : R.buffer.push(y), R.needReadable && Je(S)), ft(S, R);
  }
  ie.prototype.isPaused = function() {
    const S = this._readableState;
    return S[ke] === !0 || S.flowing === !1;
  }, ie.prototype.setEncoding = function(S) {
    const R = new ge(S);
    this._readableState.decoder = R, this._readableState.encoding = this._readableState.decoder.encoding;
    const y = this._readableState.buffer;
    let u = "";
    for (const f of y)
      u += R.write(f);
    return y.clear(), u !== "" && y.push(u), this._readableState.length = u.length, this;
  };
  const gt = 1073741824;
  function wt(S) {
    if (S > gt)
      throw new I("size", "<= 1GiB", S);
    return S--, S |= S >>> 1, S |= S >>> 2, S |= S >>> 4, S |= S >>> 8, S |= S >>> 16, S++, S;
  }
  function lt(S, R) {
    return S <= 0 || R.length === 0 && R.ended ? 0 : R.objectMode ? 1 : l(S) ? R.flowing && R.length ? R.buffer.first().length : R.length : S <= R.length ? S : R.ended ? R.length : 0;
  }
  ie.prototype.read = function(S) {
    ee("read", S), S === void 0 ? S = NaN : n(S) || (S = _(S, 10));
    const R = this._readableState, y = S;
    if (S > R.highWaterMark && (R.highWaterMark = wt(S)), S !== 0 && (R.emittedReadable = !1), S === 0 && R.needReadable && ((R.highWaterMark !== 0 ? R.length >= R.highWaterMark : R.length > 0) || R.ended))
      return ee("read: emitReadable", R.length, R.ended), R.length === 0 && R.ended ? B(this) : Je(this), null;
    if (S = lt(S, R), S === 0 && R.ended)
      return R.length === 0 && B(this), null;
    let u = R.needReadable;
    if (ee("need readable", u), (R.length === 0 || R.length - S < R.highWaterMark) && (u = !0, ee("length less than watermark", u)), R.ended || R.reading || R.destroyed || R.errored || !R.constructed)
      u = !1, ee("reading, ended or constructing", u);
    else if (u) {
      ee("do read"), R.reading = !0, R.sync = !0, R.length === 0 && (R.needReadable = !0);
      try {
        this._read(R.highWaterMark);
      } catch (C) {
        Be(this, C);
      }
      R.sync = !1, R.reading || (S = lt(y, R));
    }
    let f;
    return S > 0 ? f = T(S, R) : f = null, f === null ? (R.needReadable = R.length <= R.highWaterMark, S = 0) : (R.length -= S, R.multiAwaitDrain ? R.awaitDrainWriters.clear() : R.awaitDrainWriters = null), R.length === 0 && (R.ended || (R.needReadable = !0), y !== S && R.ended && B(this)), f !== null && !R.errorEmitted && !R.closeEmitted && (R.dataEmitted = !0, this.emit("data", f)), f;
  };
  function Pt(S, R) {
    if (ee("onEofChunk"), !R.ended) {
      if (R.decoder) {
        const y = R.decoder.end();
        y && y.length && (R.buffer.push(y), R.length += R.objectMode ? 1 : y.length);
      }
      R.ended = !0, R.sync ? Je(S) : (R.needReadable = !1, R.emittedReadable = !0, Ye(S));
    }
  }
  function Je(S) {
    const R = S._readableState;
    ee("emitReadable", R.needReadable, R.emittedReadable), R.needReadable = !1, R.emittedReadable || (ee("emitReadable", R.flowing), R.emittedReadable = !0, r.nextTick(Ye, S));
  }
  function Ye(S) {
    const R = S._readableState;
    ee("emitReadable_", R.destroyed, R.length, R.ended), !R.destroyed && !R.errored && (R.length || R.ended) && (S.emit("readable"), R.emittedReadable = !1), R.needReadable = !R.flowing && !R.ended && R.length <= R.highWaterMark, E(S);
  }
  function ft(S, R) {
    !R.readingMore && R.constructed && (R.readingMore = !0, r.nextTick(mt, S, R));
  }
  function mt(S, R) {
    for (; !R.reading && !R.ended && (R.length < R.highWaterMark || R.flowing && R.length === 0); ) {
      const y = R.length;
      if (ee("maybeReadMore read 0"), S.read(0), y === R.length)
        break;
    }
    R.readingMore = !1;
  }
  ie.prototype._read = function(S) {
    throw new ye("_read()");
  }, ie.prototype.pipe = function(S, R) {
    const y = this, u = this._readableState;
    u.pipes.length === 1 && (u.multiAwaitDrain || (u.multiAwaitDrain = !0, u.awaitDrainWriters = new L(u.awaitDrainWriters ? [u.awaitDrainWriters] : []))), u.pipes.push(S), ee("pipe count=%d opts=%j", u.pipes.length, R);
    const C = (!R || R.end !== !1) && S !== r.stdout && S !== r.stderr ? $ : xt;
    u.endEmitted ? r.nextTick(C) : y.once("end", C), S.on("unpipe", k);
    function k(At, at) {
      ee("onunpipe"), At === y && at && at.hasUnpiped === !1 && (at.hasUnpiped = !0, Ve());
    }
    function $() {
      ee("onend"), S.end();
    }
    let Y, Fe = !1;
    function Ve() {
      ee("cleanup"), S.removeListener("close", vt), S.removeListener("finish", _r), Y && S.removeListener("drain", Y), S.removeListener("error", Me), S.removeListener("unpipe", k), y.removeListener("end", $), y.removeListener("end", xt), y.removeListener("data", Ge), Fe = !0, Y && u.awaitDrainWriters && (!S._writableState || S._writableState.needDrain) && Y();
    }
    function _e() {
      Fe || (u.pipes.length === 1 && u.pipes[0] === S ? (ee("false write response, pause", 0), u.awaitDrainWriters = S, u.multiAwaitDrain = !1) : u.pipes.length > 1 && u.pipes.includes(S) && (ee("false write response, pause", u.awaitDrainWriters.size), u.awaitDrainWriters.add(S)), y.pause()), Y || (Y = rt(y, S), S.on("drain", Y));
    }
    y.on("data", Ge);
    function Ge(At) {
      ee("ondata");
      const at = S.write(At);
      ee("dest.write", at), at === !1 && _e();
    }
    function Me(At) {
      if (ee("onerror", At), xt(), S.removeListener("error", Me), S.listenerCount("error") === 0) {
        const at = S._writableState || S._readableState;
        at && !at.errorEmitted ? Be(S, At) : S.emit("error", At);
      }
    }
    K(S, "error", Me);
    function vt() {
      S.removeListener("finish", _r), xt();
    }
    S.once("close", vt);
    function _r() {
      ee("onfinish"), S.removeListener("close", vt), xt();
    }
    S.once("finish", _r);
    function xt() {
      ee("unpipe"), y.unpipe(S);
    }
    return S.emit("pipe", y), S.writableNeedDrain === !0 ? u.flowing && _e() : u.flowing || (ee("pipe resume"), y.resume()), S;
  };
  function rt(S, R) {
    return function() {
      const u = S._readableState;
      u.awaitDrainWriters === R ? (ee("pipeOnDrain", 1), u.awaitDrainWriters = null) : u.multiAwaitDrain && (ee("pipeOnDrain", u.awaitDrainWriters.size), u.awaitDrainWriters.delete(R)), (!u.awaitDrainWriters || u.awaitDrainWriters.size === 0) && S.listenerCount("data") && S.resume();
    };
  }
  ie.prototype.unpipe = function(S) {
    const R = this._readableState, y = {
      hasUnpiped: !1
    };
    if (R.pipes.length === 0)
      return this;
    if (!S) {
      const f = R.pipes;
      R.pipes = [], this.pause();
      for (let C = 0; C < f.length; C++)
        f[C].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const u = a(R.pipes, S);
    return u === -1 ? this : (R.pipes.splice(u, 1), R.pipes.length === 0 && this.pause(), S.emit("unpipe", this, y), this);
  }, ie.prototype.on = function(S, R) {
    const y = q.prototype.on.call(this, S, R), u = this._readableState;
    return S === "data" ? (u.readableListening = this.listenerCount("readable") > 0, u.flowing !== !1 && this.resume()) : S === "readable" && !u.endEmitted && !u.readableListening && (u.readableListening = u.needReadable = !0, u.flowing = !1, u.emittedReadable = !1, ee("on readable", u.length, u.reading), u.length ? Je(this) : u.reading || r.nextTick(M, this)), y;
  }, ie.prototype.addListener = ie.prototype.on, ie.prototype.removeListener = function(S, R) {
    const y = q.prototype.removeListener.call(this, S, R);
    return S === "readable" && r.nextTick(qe, this), y;
  }, ie.prototype.off = ie.prototype.removeListener, ie.prototype.removeAllListeners = function(S) {
    const R = q.prototype.removeAllListeners.apply(this, arguments);
    return (S === "readable" || S === void 0) && r.nextTick(qe, this), R;
  };
  function qe(S) {
    const R = S._readableState;
    R.readableListening = S.listenerCount("readable") > 0, R.resumeScheduled && R[ke] === !1 ? R.flowing = !0 : S.listenerCount("data") > 0 ? S.resume() : R.readableListening || (R.flowing = null);
  }
  function M(S) {
    ee("readable nexttick read 0"), S.read(0);
  }
  ie.prototype.resume = function() {
    const S = this._readableState;
    return S.flowing || (ee("resume"), S.flowing = !S.readableListening, j(this, S)), S[ke] = !1, this;
  };
  function j(S, R) {
    R.resumeScheduled || (R.resumeScheduled = !0, r.nextTick(Q, S, R));
  }
  function Q(S, R) {
    ee("resume", R.reading), R.reading || S.read(0), R.resumeScheduled = !1, S.emit("resume"), E(S), R.flowing && !R.reading && S.read(0);
  }
  ie.prototype.pause = function() {
    return ee("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ee("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[ke] = !0, this;
  };
  function E(S) {
    const R = S._readableState;
    for (ee("flow", R.flowing); R.flowing && S.read() !== null; )
      ;
  }
  ie.prototype.wrap = function(S) {
    let R = !1;
    S.on("data", (u) => {
      !this.push(u) && S.pause && (R = !0, S.pause());
    }), S.on("end", () => {
      this.push(null);
    }), S.on("error", (u) => {
      Be(this, u);
    }), S.on("close", () => {
      this.destroy();
    }), S.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      R && S.resume && (R = !1, S.resume());
    };
    const y = w(S);
    for (let u = 1; u < y.length; u++) {
      const f = y[u];
      this[f] === void 0 && typeof S[f] == "function" && (this[f] = S[f].bind(S));
    }
    return this;
  }, ie.prototype[O] = function() {
    return d(this);
  }, ie.prototype.iterator = function(S) {
    return S !== void 0 && De(S, "options"), d(this, S);
  };
  function d(S, R) {
    typeof S.read != "function" && (S = ie.wrap(S, {
      objectMode: !0
    }));
    const y = p(S, R);
    return y.stream = S, y;
  }
  async function* p(S, R) {
    let y = ze;
    function u(k) {
      this === S ? (y(), y = ze) : y = k;
    }
    S.on("readable", u);
    let f;
    const C = ce(
      S,
      {
        writable: !1
      },
      (k) => {
        f = k ? de(f, k) : null, y(), y = ze;
      }
    );
    try {
      for (; ; ) {
        const k = S.destroyed ? null : S.read();
        if (k !== null)
          yield k;
        else {
          if (f)
            throw f;
          if (f === null)
            return;
          await new D(u);
        }
      }
    } catch (k) {
      throw f = de(f, k), f;
    } finally {
      (f || R?.destroyOnReturn !== !1) && (f === void 0 || S._readableState.autoDestroy) ? Oe.destroyer(S, null) : (S.off("readable", u), C());
    }
  }
  v(ie.prototype, {
    readable: {
      __proto__: null,
      get() {
        const S = this._readableState;
        return !!S && S.readable !== !1 && !S.destroyed && !S.errorEmitted && !S.endEmitted;
      },
      set(S) {
        this._readableState && (this._readableState.readable = !!S);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(S) {
        this._readableState && (this._readableState.flowing = S);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(S) {
        this._readableState && (this._readableState.destroyed = S);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), v(it.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[ke] !== !1;
      },
      set(S) {
        this[ke] = !!S;
      }
    }
  }), ie._fromList = T;
  function T(S, R) {
    if (R.length === 0)
      return null;
    let y;
    return R.objectMode ? y = R.buffer.shift() : !S || S >= R.length ? (R.decoder ? y = R.buffer.join("") : R.buffer.length === 1 ? y = R.buffer.first() : y = R.buffer.concat(R.length), R.buffer.clear()) : y = R.buffer.consume(S, R.decoder), y;
  }
  function B(S) {
    const R = S._readableState;
    ee("endReadable", R.endEmitted), R.endEmitted || (R.ended = !0, r.nextTick(N, R, S));
  }
  function N(S, R) {
    if (ee("endReadableNT", S.endEmitted, S.length), !S.errored && !S.closeEmitted && !S.endEmitted && S.length === 0) {
      if (S.endEmitted = !0, R.emit("end"), R.writable && R.allowHalfOpen === !1)
        r.nextTick(V, R);
      else if (S.autoDestroy) {
        const y = R._writableState;
        (!y || y.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (y.finished || y.writable === !1)) && R.destroy();
      }
    }
  }
  function V(S) {
    S.writable && !S.writableEnded && !S.destroyed && S.end();
  }
  ie.from = function(S, R) {
    return $e(ie, S, R);
  };
  let Ce;
  function Ne() {
    return Ce === void 0 && (Ce = {}), Ce;
  }
  return ie.fromWeb = function(S, R) {
    return Ne().newStreamReadableFromReadableStream(S, R);
  }, ie.toWeb = function(S, R) {
    return Ne().newReadableStreamFromStreamReadable(S, R);
  }, ie.wrap = function(S, R) {
    var y, u;
    return new ie({
      objectMode: (y = (u = S.readableObjectMode) !== null && u !== void 0 ? u : S.objectMode) !== null && y !== void 0 ? y : !0,
      ...R,
      destroy(f, C) {
        Oe.destroyer(S, f), C(f);
      }
    }).wrap(S);
  }, Ni;
}
var Oi, as;
function Nu() {
  if (as)
    return Oi;
  as = 1;
  const r = hr, {
    ArrayPrototypeSlice: a,
    Error: n,
    FunctionPrototypeSymbolHasInstance: l,
    ObjectDefineProperty: _,
    ObjectDefineProperties: v,
    ObjectSetPrototypeOf: w,
    StringPrototypeToLowerCase: m,
    Symbol: D,
    SymbolHasInstance: L
  } = tt;
  Oi = ge, ge.WritableState = De;
  const { EventEmitter: O } = Ca, J = Ta.Stream, { Buffer: ae } = er, q = kr, { addAbortSignal: K } = ei, { getHighWaterMark: pe, getDefaultHighWaterMark: he } = Fa, {
    ERR_INVALID_ARG_TYPE: ce,
    ERR_METHOD_NOT_IMPLEMENTED: ee,
    ERR_MULTIPLE_CALLBACK: Te,
    ERR_STREAM_CANNOT_PIPE: Oe,
    ERR_STREAM_DESTROYED: me,
    ERR_STREAM_ALREADY_FINISHED: Ee,
    ERR_STREAM_NULL_VALUES: de,
    ERR_STREAM_WRITE_AFTER_END: Re,
    ERR_UNKNOWN_ENCODING: ye
  } = yt.codes, { errorOrDestroy: I } = q;
  w(ge.prototype, J.prototype), w(ge, J);
  function X() {
  }
  const je = D("kOnFinished");
  function De(M, j, Q) {
    typeof Q != "boolean" && (Q = j instanceof Vt()), this.objectMode = !!(M && M.objectMode), Q && (this.objectMode = this.objectMode || !!(M && M.writableObjectMode)), this.highWaterMark = M ? pe(this, M, "writableHighWaterMark", Q) : he(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const E = !!(M && M.decodeStrings === !1);
    this.decodeStrings = !E, this.defaultEncoding = M && M.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = ie.bind(void 0, j), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, ke(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !M || M.emitClose !== !1, this.autoDestroy = !M || M.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[je] = [];
  }
  function ke(M) {
    M.buffered = [], M.bufferedIndex = 0, M.allBuffers = !0, M.allNoop = !0;
  }
  De.prototype.getBuffer = function() {
    return a(this.buffered, this.bufferedIndex);
  }, _(De.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function ge(M) {
    const j = this instanceof Vt();
    if (!j && !l(ge, this))
      return new ge(M);
    this._writableState = new De(M, this, j), M && (typeof M.write == "function" && (this._write = M.write), typeof M.writev == "function" && (this._writev = M.writev), typeof M.destroy == "function" && (this._destroy = M.destroy), typeof M.final == "function" && (this._final = M.final), typeof M.construct == "function" && (this._construct = M.construct), M.signal && K(M.signal, this)), J.call(this, M), q.construct(this, () => {
      const Q = this._writableState;
      Q.writing || wt(this, Q), Ye(this, Q);
    });
  }
  _(ge, L, {
    __proto__: null,
    value: function(M) {
      return l(this, M) ? !0 : this !== ge ? !1 : M && M._writableState instanceof De;
    }
  }), ge.prototype.pipe = function() {
    I(this, new Oe());
  };
  function $e(M, j, Q, E) {
    const d = M._writableState;
    if (typeof Q == "function")
      E = Q, Q = d.defaultEncoding;
    else {
      if (!Q)
        Q = d.defaultEncoding;
      else if (Q !== "buffer" && !ae.isEncoding(Q))
        throw new ye(Q);
      typeof E != "function" && (E = X);
    }
    if (j === null)
      throw new de();
    if (!d.objectMode)
      if (typeof j == "string")
        d.decodeStrings !== !1 && (j = ae.from(j, Q), Q = "buffer");
      else if (j instanceof ae)
        Q = "buffer";
      else if (J._isUint8Array(j))
        j = J._uint8ArrayToBuffer(j), Q = "buffer";
      else
        throw new ce("chunk", ["string", "Buffer", "Uint8Array"], j);
    let p;
    return d.ending ? p = new Re() : d.destroyed && (p = new me("write")), p ? (r.nextTick(E, p), I(M, p, !0), p) : (d.pendingcb++, ze(M, d, j, Q, E));
  }
  ge.prototype.write = function(M, j, Q) {
    return $e(this, M, j, Q) === !0;
  }, ge.prototype.cork = function() {
    this._writableState.corked++;
  }, ge.prototype.uncork = function() {
    const M = this._writableState;
    M.corked && (M.corked--, M.writing || wt(this, M));
  }, ge.prototype.setDefaultEncoding = function(j) {
    if (typeof j == "string" && (j = m(j)), !ae.isEncoding(j))
      throw new ye(j);
    return this._writableState.defaultEncoding = j, this;
  };
  function ze(M, j, Q, E, d) {
    const p = j.objectMode ? 1 : Q.length;
    j.length += p;
    const T = j.length < j.highWaterMark;
    return T || (j.needDrain = !0), j.writing || j.corked || j.errored || !j.constructed ? (j.buffered.push({
      chunk: Q,
      encoding: E,
      callback: d
    }), j.allBuffers && E !== "buffer" && (j.allBuffers = !1), j.allNoop && d !== X && (j.allNoop = !1)) : (j.writelen = p, j.writecb = d, j.writing = !0, j.sync = !0, M._write(Q, E, j.onwrite), j.sync = !1), T && !j.errored && !j.destroyed;
  }
  function Be(M, j, Q, E, d, p, T) {
    j.writelen = E, j.writecb = T, j.writing = !0, j.sync = !0, j.destroyed ? j.onwrite(new me("write")) : Q ? M._writev(d, j.onwrite) : M._write(d, p, j.onwrite), j.sync = !1;
  }
  function it(M, j, Q, E) {
    --j.pendingcb, E(Q), gt(j), I(M, Q);
  }
  function ie(M, j) {
    const Q = M._writableState, E = Q.sync, d = Q.writecb;
    if (typeof d != "function") {
      I(M, new Te());
      return;
    }
    Q.writing = !1, Q.writecb = null, Q.length -= Q.writelen, Q.writelen = 0, j ? (Q.errored || (Q.errored = j), M._readableState && !M._readableState.errored && (M._readableState.errored = j), E ? r.nextTick(it, M, Q, j, d) : it(M, Q, j, d)) : (Q.buffered.length > Q.bufferedIndex && wt(M, Q), E ? Q.afterWriteTickInfo !== null && Q.afterWriteTickInfo.cb === d ? Q.afterWriteTickInfo.count++ : (Q.afterWriteTickInfo = {
      count: 1,
      cb: d,
      stream: M,
      state: Q
    }, r.nextTick(we, Q.afterWriteTickInfo)) : Ie(M, Q, 1, d));
  }
  function we({ stream: M, state: j, count: Q, cb: E }) {
    return j.afterWriteTickInfo = null, Ie(M, j, Q, E);
  }
  function Ie(M, j, Q, E) {
    for (!j.ending && !M.destroyed && j.length === 0 && j.needDrain && (j.needDrain = !1, M.emit("drain")); Q-- > 0; )
      j.pendingcb--, E();
    j.destroyed && gt(j), Ye(M, j);
  }
  function gt(M) {
    if (M.writing)
      return;
    for (let d = M.bufferedIndex; d < M.buffered.length; ++d) {
      var j;
      const { chunk: p, callback: T } = M.buffered[d], B = M.objectMode ? 1 : p.length;
      M.length -= B, T(
        (j = M.errored) !== null && j !== void 0 ? j : new me("write")
      );
    }
    const Q = M[je].splice(0);
    for (let d = 0; d < Q.length; d++) {
      var E;
      Q[d](
        (E = M.errored) !== null && E !== void 0 ? E : new me("end")
      );
    }
    ke(M);
  }
  function wt(M, j) {
    if (j.corked || j.bufferProcessing || j.destroyed || !j.constructed)
      return;
    const { buffered: Q, bufferedIndex: E, objectMode: d } = j, p = Q.length - E;
    if (!p)
      return;
    let T = E;
    if (j.bufferProcessing = !0, p > 1 && M._writev) {
      j.pendingcb -= p - 1;
      const B = j.allNoop ? X : (V) => {
        for (let Ce = T; Ce < Q.length; ++Ce)
          Q[Ce].callback(V);
      }, N = j.allNoop && T === 0 ? Q : a(Q, T);
      N.allBuffers = j.allBuffers, Be(M, j, !0, j.length, N, "", B), ke(j);
    } else {
      do {
        const { chunk: B, encoding: N, callback: V } = Q[T];
        Q[T++] = null;
        const Ce = d ? 1 : B.length;
        Be(M, j, !1, Ce, B, N, V);
      } while (T < Q.length && !j.writing);
      T === Q.length ? ke(j) : T > 256 ? (Q.splice(0, T), j.bufferedIndex = 0) : j.bufferedIndex = T;
    }
    j.bufferProcessing = !1;
  }
  ge.prototype._write = function(M, j, Q) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: M,
            encoding: j
          }
        ],
        Q
      );
    else
      throw new ee("_write()");
  }, ge.prototype._writev = null, ge.prototype.end = function(M, j, Q) {
    const E = this._writableState;
    typeof M == "function" ? (Q = M, M = null, j = null) : typeof j == "function" && (Q = j, j = null);
    let d;
    if (M != null) {
      const p = $e(this, M, j);
      p instanceof n && (d = p);
    }
    return E.corked && (E.corked = 1, this.uncork()), d || (!E.errored && !E.ending ? (E.ending = !0, Ye(this, E, !0), E.ended = !0) : E.finished ? d = new Ee("end") : E.destroyed && (d = new me("end"))), typeof Q == "function" && (d || E.finished ? r.nextTick(Q, d) : E[je].push(Q)), this;
  };
  function lt(M) {
    return M.ending && !M.destroyed && M.constructed && M.length === 0 && !M.errored && M.buffered.length === 0 && !M.finished && !M.writing && !M.errorEmitted && !M.closeEmitted;
  }
  function Pt(M, j) {
    let Q = !1;
    function E(d) {
      if (Q) {
        I(M, d ?? Te());
        return;
      }
      if (Q = !0, j.pendingcb--, d) {
        const p = j[je].splice(0);
        for (let T = 0; T < p.length; T++)
          p[T](d);
        I(M, d, j.sync);
      } else
        lt(j) && (j.prefinished = !0, M.emit("prefinish"), j.pendingcb++, r.nextTick(ft, M, j));
    }
    j.sync = !0, j.pendingcb++;
    try {
      M._final(E);
    } catch (d) {
      E(d);
    }
    j.sync = !1;
  }
  function Je(M, j) {
    !j.prefinished && !j.finalCalled && (typeof M._final == "function" && !j.destroyed ? (j.finalCalled = !0, Pt(M, j)) : (j.prefinished = !0, M.emit("prefinish")));
  }
  function Ye(M, j, Q) {
    lt(j) && (Je(M, j), j.pendingcb === 0 && (Q ? (j.pendingcb++, r.nextTick(
      (E, d) => {
        lt(d) ? ft(E, d) : d.pendingcb--;
      },
      M,
      j
    )) : lt(j) && (j.pendingcb++, ft(M, j))));
  }
  function ft(M, j) {
    j.pendingcb--, j.finished = !0;
    const Q = j[je].splice(0);
    for (let E = 0; E < Q.length; E++)
      Q[E]();
    if (M.emit("finish"), j.autoDestroy) {
      const E = M._readableState;
      (!E || E.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (E.endEmitted || E.readable === !1)) && M.destroy();
    }
  }
  v(ge.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(M) {
        this._writableState && (this._writableState.destroyed = M);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const M = this._writableState;
        return !!M && M.writable !== !1 && !M.destroyed && !M.errored && !M.ending && !M.ended;
      },
      set(M) {
        this._writableState && (this._writableState.writable = !!M);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const M = this._writableState;
        return M ? !M.destroyed && !M.ending && M.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const mt = q.destroy;
  ge.prototype.destroy = function(M, j) {
    const Q = this._writableState;
    return !Q.destroyed && (Q.bufferedIndex < Q.buffered.length || Q[je].length) && r.nextTick(gt, Q), mt.call(this, M, j), this;
  }, ge.prototype._undestroy = q.undestroy, ge.prototype._destroy = function(M, j) {
    j(M);
  }, ge.prototype[O.captureRejectionSymbol] = function(M) {
    this.destroy(M);
  };
  let rt;
  function qe() {
    return rt === void 0 && (rt = {}), rt;
  }
  return ge.fromWeb = function(M, j) {
    return qe().newStreamWritableFromWritableStream(M, j);
  }, ge.toWeb = function(M) {
    return qe().newWritableStreamFromStreamWritable(M);
  }, Oi;
}
var ji, os;
function d_() {
  if (os)
    return ji;
  os = 1;
  const r = hr, a = er, {
    isReadable: n,
    isWritable: l,
    isIterable: _,
    isNodeStream: v,
    isReadableNodeStream: w,
    isWritableNodeStream: m,
    isDuplexNodeStream: D
  } = Yt, L = tr, {
    AbortError: O,
    codes: { ERR_INVALID_ARG_TYPE: J, ERR_INVALID_RETURN_VALUE: ae }
  } = yt, { destroyer: q } = kr, K = Vt(), pe = ti(), { createDeferredPromise: he } = Ht, ce = Bu, ee = globalThis.Blob || a.Blob, Te = typeof ee < "u" ? function(I) {
    return I instanceof ee;
  } : function(I) {
    return !1;
  }, Oe = globalThis.AbortController || ya().AbortController, { FunctionPrototypeCall: me } = tt;
  class Ee extends K {
    constructor(I) {
      super(I), I?.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), I?.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  ji = function ye(I, X) {
    if (D(I))
      return I;
    if (w(I))
      return Re({
        readable: I
      });
    if (m(I))
      return Re({
        writable: I
      });
    if (v(I))
      return Re({
        writable: !1,
        readable: !1
      });
    if (typeof I == "function") {
      const { value: De, write: ke, final: ge, destroy: $e } = de(I);
      if (_(De))
        return ce(Ee, De, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: ke,
          final: ge,
          destroy: $e
        });
      const ze = De?.then;
      if (typeof ze == "function") {
        let Be;
        const it = me(
          ze,
          De,
          (ie) => {
            if (ie != null)
              throw new ae("nully", "body", ie);
          },
          (ie) => {
            q(Be, ie);
          }
        );
        return Be = new Ee({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: ke,
          final(ie) {
            ge(async () => {
              try {
                await it, r.nextTick(ie, null);
              } catch (we) {
                r.nextTick(ie, we);
              }
            });
          },
          destroy: $e
        });
      }
      throw new ae("Iterable, AsyncIterable or AsyncFunction", X, De);
    }
    if (Te(I))
      return ye(I.arrayBuffer());
    if (_(I))
      return ce(Ee, I, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (typeof I?.writable == "object" || typeof I?.readable == "object") {
      const De = I != null && I.readable ? w(I?.readable) ? I?.readable : ye(I.readable) : void 0, ke = I != null && I.writable ? m(I?.writable) ? I?.writable : ye(I.writable) : void 0;
      return Re({
        readable: De,
        writable: ke
      });
    }
    const je = I?.then;
    if (typeof je == "function") {
      let De;
      return me(
        je,
        I,
        (ke) => {
          ke != null && De.push(ke), De.push(null);
        },
        (ke) => {
          q(De, ke);
        }
      ), De = new Ee({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new J(
      X,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      I
    );
  };
  function de(ye) {
    let { promise: I, resolve: X } = he();
    const je = new Oe(), De = je.signal;
    return {
      value: ye(
        async function* () {
          for (; ; ) {
            const ge = I;
            I = null;
            const { chunk: $e, done: ze, cb: Be } = await ge;
            if (r.nextTick(Be), ze)
              return;
            if (De.aborted)
              throw new O(void 0, {
                cause: De.reason
              });
            ({ promise: I, resolve: X } = he()), yield $e;
          }
        }(),
        {
          signal: De
        }
      ),
      write(ge, $e, ze) {
        const Be = X;
        X = null, Be({
          chunk: ge,
          done: !1,
          cb: ze
        });
      },
      final(ge) {
        const $e = X;
        X = null, $e({
          done: !0,
          cb: ge
        });
      },
      destroy(ge, $e) {
        je.abort(), $e(ge);
      }
    };
  }
  function Re(ye) {
    const I = ye.readable && typeof ye.readable.read != "function" ? pe.wrap(ye.readable) : ye.readable, X = ye.writable;
    let je = !!n(I), De = !!l(X), ke, ge, $e, ze, Be;
    function it(ie) {
      const we = ze;
      ze = null, we ? we(ie) : ie && Be.destroy(ie);
    }
    return Be = new Ee({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(I != null && I.readableObjectMode),
      writableObjectMode: !!(X != null && X.writableObjectMode),
      readable: je,
      writable: De
    }), De && (L(X, (ie) => {
      De = !1, ie && q(I, ie), it(ie);
    }), Be._write = function(ie, we, Ie) {
      X.write(ie, we) ? Ie() : ke = Ie;
    }, Be._final = function(ie) {
      X.end(), ge = ie;
    }, X.on("drain", function() {
      if (ke) {
        const ie = ke;
        ke = null, ie();
      }
    }), X.on("finish", function() {
      if (ge) {
        const ie = ge;
        ge = null, ie();
      }
    })), je && (L(I, (ie) => {
      je = !1, ie && q(I, ie), it(ie);
    }), I.on("readable", function() {
      if ($e) {
        const ie = $e;
        $e = null, ie();
      }
    }), I.on("end", function() {
      Be.push(null);
    }), Be._read = function() {
      for (; ; ) {
        const ie = I.read();
        if (ie === null) {
          $e = Be._read;
          return;
        }
        if (!Be.push(ie))
          return;
      }
    }), Be._destroy = function(ie, we) {
      !ie && ze !== null && (ie = new O()), $e = null, ke = null, ge = null, ze === null ? we(ie) : (ze = we, q(X, ie), q(I, ie));
    }, Be;
  }
  return ji;
}
var Ui, ss;
function Vt() {
  if (ss)
    return Ui;
  ss = 1;
  const {
    ObjectDefineProperties: r,
    ObjectGetOwnPropertyDescriptor: a,
    ObjectKeys: n,
    ObjectSetPrototypeOf: l
  } = tt;
  Ui = w;
  const _ = ti(), v = Nu();
  l(w.prototype, _.prototype), l(w, _);
  {
    const O = n(v.prototype);
    for (let J = 0; J < O.length; J++) {
      const ae = O[J];
      w.prototype[ae] || (w.prototype[ae] = v.prototype[ae]);
    }
  }
  function w(O) {
    if (!(this instanceof w))
      return new w(O);
    _.call(this, O), v.call(this, O), O ? (this.allowHalfOpen = O.allowHalfOpen !== !1, O.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), O.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  r(w.prototype, {
    writable: {
      __proto__: null,
      ...a(v.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...a(v.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...a(v.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...a(v.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...a(v.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...a(v.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...a(v.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...a(v.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...a(v.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(O) {
        this._readableState && this._writableState && (this._readableState.destroyed = O, this._writableState.destroyed = O);
      }
    }
  });
  let m;
  function D() {
    return m === void 0 && (m = {}), m;
  }
  w.fromWeb = function(O, J) {
    return D().newStreamDuplexFromReadableWritablePair(O, J);
  }, w.toWeb = function(O) {
    return D().newReadableWritablePairFromDuplex(O);
  };
  let L;
  return w.from = function(O) {
    return L || (L = d_()), L(O, "body");
  }, Ui;
}
const { ObjectSetPrototypeOf: Ou, Symbol: h_ } = tt;
var ju = zt;
const { ERR_METHOD_NOT_IMPLEMENTED: p_ } = yt.codes, Aa = Vt(), { getHighWaterMark: m_ } = Fa;
Ou(zt.prototype, Aa.prototype);
Ou(zt, Aa);
const zr = h_("kCallback");
function zt(r) {
  if (!(this instanceof zt))
    return new zt(r);
  const a = r ? m_(this, r, "readableHighWaterMark", !0) : null;
  a === 0 && (r = {
    ...r,
    highWaterMark: null,
    readableHighWaterMark: a,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: r.writableHighWaterMark || 0
  }), Aa.call(this, r), this._readableState.sync = !1, this[zr] = null, r && (typeof r.transform == "function" && (this._transform = r.transform), typeof r.flush == "function" && (this._flush = r.flush)), this.on("prefinish", __);
}
function la(r) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((a, n) => {
    if (a) {
      r ? r(a) : this.destroy(a);
      return;
    }
    n != null && this.push(n), this.push(null), r && r();
  }) : (this.push(null), r && r());
}
function __() {
  this._final !== la && la.call(this);
}
zt.prototype._final = la;
zt.prototype._transform = function(r, a, n) {
  throw new p_("_transform()");
};
zt.prototype._write = function(r, a, n) {
  const l = this._readableState, _ = this._writableState, v = l.length;
  this._transform(r, a, (w, m) => {
    if (w) {
      n(w);
      return;
    }
    m != null && this.push(m), _.ended || // Backwards compat.
    v === l.length || // Backwards compat.
    l.length < l.highWaterMark ? n() : this[zr] = n;
  });
};
zt.prototype._read = function() {
  if (this[zr]) {
    const r = this[zr];
    this[zr] = null, r();
  }
};
const { ObjectSetPrototypeOf: Uu } = tt;
var Wu = Ir;
const Ia = ju;
Uu(Ir.prototype, Ia.prototype);
Uu(Ir, Ia);
function Ir(r) {
  if (!(this instanceof Ir))
    return new Ir(r);
  Ia.call(this, r);
}
Ir.prototype._transform = function(r, a, n) {
  n(null, r);
};
const Vr = hr, { ArrayIsArray: b_, Promise: y_, SymbolAsyncIterator: g_ } = tt, Un = tr, { once: w_ } = Ht, v_ = kr, us = Vt(), {
  aggregateTwoErrors: E_,
  codes: {
    ERR_INVALID_ARG_TYPE: fa,
    ERR_INVALID_RETURN_VALUE: Wi,
    ERR_MISSING_ARGS: x_,
    ERR_STREAM_DESTROYED: S_,
    ERR_STREAM_PREMATURE_CLOSE: C_
  },
  AbortError: T_
} = yt, { validateFunction: F_, validateAbortSignal: R_ } = Hn, {
  isIterable: sr,
  isReadable: $i,
  isReadableNodeStream: Nn,
  isNodeStream: ls,
  isTransformStream: Cr,
  isWebStream: A_,
  isReadableStream: Gi,
  isReadableEnded: I_
} = Yt, P_ = globalThis.AbortController || ya().AbortController;
let Vi, zi;
function fs(r, a, n) {
  let l = !1;
  r.on("close", () => {
    l = !0;
  });
  const _ = Un(
    r,
    {
      readable: a,
      writable: n
    },
    (v) => {
      l = !v;
    }
  );
  return {
    destroy: (v) => {
      l || (l = !0, v_.destroyer(r, v || new S_("pipe")));
    },
    cleanup: _
  };
}
function k_(r) {
  return F_(r[r.length - 1], "streams[stream.length - 1]"), r.pop();
}
function Hi(r) {
  if (sr(r))
    return r;
  if (Nn(r))
    return D_(r);
  throw new fa("val", ["Readable", "Iterable", "AsyncIterable"], r);
}
async function* D_(r) {
  zi || (zi = ti()), yield* zi.prototype[g_].call(r);
}
async function kn(r, a, n, { end: l }) {
  let _, v = null;
  const w = (L) => {
    if (L && (_ = L), v) {
      const O = v;
      v = null, O();
    }
  }, m = () => new y_((L, O) => {
    _ ? O(_) : v = () => {
      _ ? O(_) : L();
    };
  });
  a.on("drain", w);
  const D = Un(
    a,
    {
      readable: !1
    },
    w
  );
  try {
    a.writableNeedDrain && await m();
    for await (const L of r)
      a.write(L) || await m();
    l && a.end(), await m(), n();
  } catch (L) {
    n(_ !== L ? E_(_, L) : L);
  } finally {
    D(), a.off("drain", w);
  }
}
async function Ki(r, a, n, { end: l }) {
  Cr(a) && (a = a.writable);
  const _ = a.getWriter();
  try {
    for await (const v of r)
      await _.ready, _.write(v).catch(() => {
      });
    await _.ready, l && await _.close(), n();
  } catch (v) {
    try {
      await _.abort(v), n(v);
    } catch (w) {
      n(w);
    }
  }
}
function L_(...r) {
  return $u(r, w_(k_(r)));
}
function $u(r, a, n) {
  if (r.length === 1 && b_(r[0]) && (r = r[0]), r.length < 2)
    throw new x_("streams");
  const l = new P_(), _ = l.signal, v = n?.signal, w = [];
  R_(v, "options.signal");
  function m() {
    q(new T_());
  }
  v?.addEventListener("abort", m);
  let D, L;
  const O = [];
  let J = 0;
  function ae(ce) {
    q(ce, --J === 0);
  }
  function q(ce, ee) {
    if (ce && (!D || D.code === "ERR_STREAM_PREMATURE_CLOSE") && (D = ce), !(!D && !ee)) {
      for (; O.length; )
        O.shift()(D);
      v?.removeEventListener("abort", m), l.abort(), ee && (D || w.forEach((Te) => Te()), Vr.nextTick(a, D, L));
    }
  }
  let K;
  for (let ce = 0; ce < r.length; ce++) {
    const ee = r[ce], Te = ce < r.length - 1, Oe = ce > 0, me = Te || n?.end !== !1, Ee = ce === r.length - 1;
    if (ls(ee)) {
      let de = function(Re) {
        Re && Re.name !== "AbortError" && Re.code !== "ERR_STREAM_PREMATURE_CLOSE" && ae(Re);
      };
      if (me) {
        const { destroy: Re, cleanup: ye } = fs(ee, Te, Oe);
        O.push(Re), $i(ee) && Ee && w.push(ye);
      }
      ee.on("error", de), $i(ee) && Ee && w.push(() => {
        ee.removeListener("error", de);
      });
    }
    if (ce === 0)
      if (typeof ee == "function") {
        if (K = ee({
          signal: _
        }), !sr(K))
          throw new Wi("Iterable, AsyncIterable or Stream", "source", K);
      } else
        sr(ee) || Nn(ee) || Cr(ee) ? K = ee : K = us.from(ee);
    else if (typeof ee == "function") {
      if (Cr(K)) {
        var pe;
        K = Hi((pe = K) === null || pe === void 0 ? void 0 : pe.readable);
      } else
        K = Hi(K);
      if (K = ee(K, {
        signal: _
      }), Te) {
        if (!sr(K, !0))
          throw new Wi("AsyncIterable", `transform[${ce - 1}]`, K);
      } else {
        var he;
        Vi || (Vi = Wu);
        const de = new Vi({
          objectMode: !0
        }), Re = (he = K) === null || he === void 0 ? void 0 : he.then;
        if (typeof Re == "function")
          J++, Re.call(
            K,
            (X) => {
              L = X, X != null && de.write(X), me && de.end(), Vr.nextTick(ae);
            },
            (X) => {
              de.destroy(X), Vr.nextTick(ae, X);
            }
          );
        else if (sr(K, !0))
          J++, kn(K, de, ae, {
            end: me
          });
        else if (Gi(K) || Cr(K)) {
          const X = K.readable || K;
          J++, kn(X, de, ae, {
            end: me
          });
        } else
          throw new Wi("AsyncIterable or Promise", "destination", K);
        K = de;
        const { destroy: ye, cleanup: I } = fs(K, !1, !0);
        O.push(ye), Ee && w.push(I);
      }
    } else if (ls(ee)) {
      if (Nn(K)) {
        J += 2;
        const de = M_(K, ee, ae, {
          end: me
        });
        $i(ee) && Ee && w.push(de);
      } else if (Cr(K) || Gi(K)) {
        const de = K.readable || K;
        J++, kn(de, ee, ae, {
          end: me
        });
      } else if (sr(K))
        J++, kn(K, ee, ae, {
          end: me
        });
      else
        throw new fa(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          K
        );
      K = ee;
    } else if (A_(ee)) {
      if (Nn(K))
        J++, Ki(Hi(K), ee, ae, {
          end: me
        });
      else if (Gi(K) || sr(K))
        J++, Ki(K, ee, ae, {
          end: me
        });
      else if (Cr(K))
        J++, Ki(K.readable, ee, ae, {
          end: me
        });
      else
        throw new fa(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          K
        );
      K = ee;
    } else
      K = us.from(ee);
  }
  return (_ != null && _.aborted || v != null && v.aborted) && Vr.nextTick(m), K;
}
function M_(r, a, n, { end: l }) {
  let _ = !1;
  if (a.on("close", () => {
    _ || n(new C_());
  }), r.pipe(a, {
    end: !1
  }), l) {
    let v = function() {
      _ = !0, a.end();
    };
    I_(r) ? Vr.nextTick(v) : r.once("end", v);
  } else
    n();
  return Un(
    r,
    {
      readable: !0,
      writable: !1
    },
    (v) => {
      const w = r._readableState;
      v && v.code === "ERR_STREAM_PREMATURE_CLOSE" && w && w.ended && !w.errored && !w.errorEmitted ? r.once("end", n).once("error", n) : n(v);
    }
  ), Un(
    a,
    {
      readable: !1,
      writable: !0
    },
    n
  );
}
var Pa = {
  pipelineImpl: $u,
  pipeline: L_
};
const { pipeline: B_ } = Pa, Dn = Vt(), { destroyer: N_ } = kr, {
  isNodeStream: Ln,
  isReadable: cs,
  isWritable: ds,
  isWebStream: Yi,
  isTransformStream: or,
  isWritableStream: hs,
  isReadableStream: ps
} = Yt, {
  AbortError: O_,
  codes: { ERR_INVALID_ARG_VALUE: ms, ERR_MISSING_ARGS: j_ }
} = yt, U_ = tr;
var Gu = function(...a) {
  if (a.length === 0)
    throw new j_("streams");
  if (a.length === 1)
    return Dn.from(a[0]);
  const n = [...a];
  if (typeof a[0] == "function" && (a[0] = Dn.from(a[0])), typeof a[a.length - 1] == "function") {
    const q = a.length - 1;
    a[q] = Dn.from(a[q]);
  }
  for (let q = 0; q < a.length; ++q)
    if (!(!Ln(a[q]) && !Yi(a[q]))) {
      if (q < a.length - 1 && !(cs(a[q]) || ps(a[q]) || or(a[q])))
        throw new ms(`streams[${q}]`, n[q], "must be readable");
      if (q > 0 && !(ds(a[q]) || hs(a[q]) || or(a[q])))
        throw new ms(`streams[${q}]`, n[q], "must be writable");
    }
  let l, _, v, w, m;
  function D(q) {
    const K = w;
    w = null, K ? K(q) : q ? m.destroy(q) : !ae && !J && m.destroy();
  }
  const L = a[0], O = B_(a, D), J = !!(ds(L) || hs(L) || or(L)), ae = !!(cs(O) || ps(O) || or(O));
  if (m = new Dn({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(L != null && L.writableObjectMode),
    readableObjectMode: !!(O != null && O.writableObjectMode),
    writable: J,
    readable: ae
  }), J) {
    if (Ln(L))
      m._write = function(K, pe, he) {
        L.write(K, pe) ? he() : l = he;
      }, m._final = function(K) {
        L.end(), _ = K;
      }, L.on("drain", function() {
        if (l) {
          const K = l;
          l = null, K();
        }
      });
    else if (Yi(L)) {
      const pe = (or(L) ? L.writable : L).getWriter();
      m._write = async function(he, ce, ee) {
        try {
          await pe.ready, pe.write(he).catch(() => {
          }), ee();
        } catch (Te) {
          ee(Te);
        }
      }, m._final = async function(he) {
        try {
          await pe.ready, pe.close().catch(() => {
          }), _ = he;
        } catch (ce) {
          he(ce);
        }
      };
    }
    const q = or(O) ? O.readable : O;
    U_(q, () => {
      if (_) {
        const K = _;
        _ = null, K();
      }
    });
  }
  if (ae) {
    if (Ln(O))
      O.on("readable", function() {
        if (v) {
          const q = v;
          v = null, q();
        }
      }), O.on("end", function() {
        m.push(null);
      }), m._read = function() {
        for (; ; ) {
          const q = O.read();
          if (q === null) {
            v = m._read;
            return;
          }
          if (!m.push(q))
            return;
        }
      };
    else if (Yi(O)) {
      const K = (or(O) ? O.readable : O).getReader();
      m._read = async function() {
        for (; ; )
          try {
            const { value: pe, done: he } = await K.read();
            if (!m.push(pe))
              return;
            if (he) {
              m.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return m._destroy = function(q, K) {
    !q && w !== null && (q = new O_()), v = null, l = null, _ = null, w === null ? K(q) : (w = K, Ln(O) && N_(O, q));
  }, m;
};
const Vu = globalThis.AbortController || ya().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: W_, ERR_INVALID_ARG_TYPE: en, ERR_MISSING_ARGS: $_, ERR_OUT_OF_RANGE: G_ },
  AbortError: Ut
} = yt, { validateAbortSignal: pr, validateInteger: V_, validateObject: mr } = Hn, z_ = tt.Symbol("kWeak"), { finished: H_ } = tr, K_ = Gu, { addAbortSignalNoValidate: Y_ } = ei, { isWritable: X_, isNodeStream: Z_ } = Yt, {
  ArrayPrototypePush: q_,
  MathFloor: Q_,
  Number: J_,
  NumberIsNaN: eb,
  Promise: _s,
  PromiseReject: bs,
  PromisePrototypeThen: tb,
  Symbol: zu
} = tt, Wn = zu("kEmpty"), ys = zu("kEof");
function rb(r, a) {
  if (a != null && mr(a, "options"), a?.signal != null && pr(a.signal, "options.signal"), Z_(r) && !X_(r))
    throw new W_("stream", r, "must be writable");
  const n = K_(this, r);
  return a != null && a.signal && Y_(a.signal, n), n;
}
function ri(r, a) {
  if (typeof r != "function")
    throw new en("fn", ["Function", "AsyncFunction"], r);
  a != null && mr(a, "options"), a?.signal != null && pr(a.signal, "options.signal");
  let n = 1;
  return a?.concurrency != null && (n = Q_(a.concurrency)), V_(n, "concurrency", 1), async function* () {
    var _, v;
    const w = new Vu(), m = this, D = [], L = w.signal, O = {
      signal: L
    }, J = () => w.abort();
    a != null && (_ = a.signal) !== null && _ !== void 0 && _.aborted && J(), a == null || (v = a.signal) === null || v === void 0 || v.addEventListener("abort", J);
    let ae, q, K = !1;
    function pe() {
      K = !0;
    }
    async function he() {
      try {
        for await (let Te of m) {
          var ce;
          if (K)
            return;
          if (L.aborted)
            throw new Ut();
          try {
            Te = r(Te, O);
          } catch (Oe) {
            Te = bs(Oe);
          }
          Te !== Wn && (typeof ((ce = Te) === null || ce === void 0 ? void 0 : ce.catch) == "function" && Te.catch(pe), D.push(Te), ae && (ae(), ae = null), !K && D.length && D.length >= n && await new _s((Oe) => {
            q = Oe;
          }));
        }
        D.push(ys);
      } catch (Te) {
        const Oe = bs(Te);
        tb(Oe, void 0, pe), D.push(Oe);
      } finally {
        var ee;
        K = !0, ae && (ae(), ae = null), a == null || (ee = a.signal) === null || ee === void 0 || ee.removeEventListener("abort", J);
      }
    }
    he();
    try {
      for (; ; ) {
        for (; D.length > 0; ) {
          const ce = await D[0];
          if (ce === ys)
            return;
          if (L.aborted)
            throw new Ut();
          ce !== Wn && (yield ce), D.shift(), q && (q(), q = null);
        }
        await new _s((ce) => {
          ae = ce;
        });
      }
    } finally {
      w.abort(), K = !0, q && (q(), q = null);
    }
  }.call(this);
}
function nb(r = void 0) {
  return r != null && mr(r, "options"), r?.signal != null && pr(r.signal, "options.signal"), async function* () {
    let n = 0;
    for await (const _ of this) {
      var l;
      if (r != null && (l = r.signal) !== null && l !== void 0 && l.aborted)
        throw new Ut({
          cause: r.signal.reason
        });
      yield [n++, _];
    }
  }.call(this);
}
async function Hu(r, a = void 0) {
  for await (const n of ka.call(this, r, a))
    return !0;
  return !1;
}
async function ib(r, a = void 0) {
  if (typeof r != "function")
    throw new en("fn", ["Function", "AsyncFunction"], r);
  return !await Hu.call(
    this,
    async (...n) => !await r(...n),
    a
  );
}
async function ab(r, a) {
  for await (const n of ka.call(this, r, a))
    return n;
}
async function ob(r, a) {
  if (typeof r != "function")
    throw new en("fn", ["Function", "AsyncFunction"], r);
  async function n(l, _) {
    return await r(l, _), Wn;
  }
  for await (const l of ri.call(this, n, a))
    ;
}
function ka(r, a) {
  if (typeof r != "function")
    throw new en("fn", ["Function", "AsyncFunction"], r);
  async function n(l, _) {
    return await r(l, _) ? l : Wn;
  }
  return ri.call(this, n, a);
}
class sb extends $_ {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function ub(r, a, n) {
  var l;
  if (typeof r != "function")
    throw new en("reducer", ["Function", "AsyncFunction"], r);
  n != null && mr(n, "options"), n?.signal != null && pr(n.signal, "options.signal");
  let _ = arguments.length > 1;
  if (n != null && (l = n.signal) !== null && l !== void 0 && l.aborted) {
    const L = new Ut(void 0, {
      cause: n.signal.reason
    });
    throw this.once("error", () => {
    }), await H_(this.destroy(L)), L;
  }
  const v = new Vu(), w = v.signal;
  if (n != null && n.signal) {
    const L = {
      once: !0,
      [z_]: this
    };
    n.signal.addEventListener("abort", () => v.abort(), L);
  }
  let m = !1;
  try {
    for await (const L of this) {
      var D;
      if (m = !0, n != null && (D = n.signal) !== null && D !== void 0 && D.aborted)
        throw new Ut();
      _ ? a = await r(a, L, {
        signal: w
      }) : (a = L, _ = !0);
    }
    if (!m && !_)
      throw new sb();
  } finally {
    v.abort();
  }
  return a;
}
async function lb(r) {
  r != null && mr(r, "options"), r?.signal != null && pr(r.signal, "options.signal");
  const a = [];
  for await (const l of this) {
    var n;
    if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted)
      throw new Ut(void 0, {
        cause: r.signal.reason
      });
    q_(a, l);
  }
  return a;
}
function fb(r, a) {
  const n = ri.call(this, r, a);
  return async function* () {
    for await (const _ of n)
      yield* _;
  }.call(this);
}
function Ku(r) {
  if (r = J_(r), eb(r))
    return 0;
  if (r < 0)
    throw new G_("number", ">= 0", r);
  return r;
}
function cb(r, a = void 0) {
  return a != null && mr(a, "options"), a?.signal != null && pr(a.signal, "options.signal"), r = Ku(r), async function* () {
    var l;
    if (a != null && (l = a.signal) !== null && l !== void 0 && l.aborted)
      throw new Ut();
    for await (const v of this) {
      var _;
      if (a != null && (_ = a.signal) !== null && _ !== void 0 && _.aborted)
        throw new Ut();
      r-- <= 0 && (yield v);
    }
  }.call(this);
}
function db(r, a = void 0) {
  return a != null && mr(a, "options"), a?.signal != null && pr(a.signal, "options.signal"), r = Ku(r), async function* () {
    var l;
    if (a != null && (l = a.signal) !== null && l !== void 0 && l.aborted)
      throw new Ut();
    for await (const v of this) {
      var _;
      if (a != null && (_ = a.signal) !== null && _ !== void 0 && _.aborted)
        throw new Ut();
      if (r-- > 0)
        yield v;
      else
        return;
    }
  }.call(this);
}
ba.streamReturningOperators = {
  asIndexedPairs: nb,
  drop: cb,
  filter: ka,
  flatMap: fb,
  map: ri,
  take: db,
  compose: rb
};
ba.promiseReturningOperators = {
  every: ib,
  forEach: ob,
  reduce: ub,
  toArray: lb,
  some: Hu,
  find: ab
};
var Xi, gs;
function Yu() {
  if (gs)
    return Xi;
  gs = 1;
  const { ArrayPrototypePop: r, Promise: a } = tt, { isIterable: n, isNodeStream: l, isWebStream: _ } = Yt, { pipelineImpl: v } = Pa, { finished: w } = tr;
  Xu();
  function m(...D) {
    return new a((L, O) => {
      let J, ae;
      const q = D[D.length - 1];
      if (q && typeof q == "object" && !l(q) && !n(q) && !_(q)) {
        const K = r(D);
        J = K.signal, ae = K.end;
      }
      v(
        D,
        (K, pe) => {
          K ? O(K) : L(pe);
        },
        {
          signal: J,
          end: ae
        }
      );
    });
  }
  return Xi = {
    finished: w,
    pipeline: m
  }, Xi;
}
var ws;
function Xu() {
  if (ws)
    return Pi.exports;
  ws = 1;
  const { Buffer: r } = er, { ObjectDefineProperty: a, ObjectKeys: n, ReflectApply: l } = tt, {
    promisify: { custom: _ }
  } = Ht, { streamReturningOperators: v, promiseReturningOperators: w } = ba, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: m }
  } = yt, D = Gu, { pipeline: L } = Pa, { destroyer: O } = kr, J = tr, ae = Yu(), q = Yt, K = Pi.exports = Ta.Stream;
  K.isDisturbed = q.isDisturbed, K.isErrored = q.isErrored, K.isReadable = q.isReadable, K.Readable = ti();
  for (const he of n(v)) {
    let ee = function(...Te) {
      if (new.target)
        throw m();
      return K.Readable.from(l(ce, this, Te));
    };
    const ce = v[he];
    a(ee, "name", {
      __proto__: null,
      value: ce.name
    }), a(ee, "length", {
      __proto__: null,
      value: ce.length
    }), a(K.Readable.prototype, he, {
      __proto__: null,
      value: ee,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const he of n(w)) {
    let ee = function(...Te) {
      if (new.target)
        throw m();
      return l(ce, this, Te);
    };
    const ce = w[he];
    a(ee, "name", {
      __proto__: null,
      value: ce.name
    }), a(ee, "length", {
      __proto__: null,
      value: ce.length
    }), a(K.Readable.prototype, he, {
      __proto__: null,
      value: ee,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  K.Writable = Nu(), K.Duplex = Vt(), K.Transform = ju, K.PassThrough = Wu, K.pipeline = L;
  const { addAbortSignal: pe } = ei;
  return K.addAbortSignal = pe, K.finished = J, K.destroy = O, K.compose = D, a(K, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return ae;
    }
  }), a(L, _, {
    __proto__: null,
    enumerable: !0,
    get() {
      return ae.pipeline;
    }
  }), a(J, _, {
    __proto__: null,
    enumerable: !0,
    get() {
      return ae.finished;
    }
  }), K.Stream = K, K._isUint8Array = function(ce) {
    return ce instanceof Uint8Array;
  }, K._uint8ArrayToBuffer = function(ce) {
    return r.from(ce.buffer, ce.byteOffset, ce.byteLength);
  }, Pi.exports;
}
(function(r) {
  const a = Xu(), n = Yu(), l = a.Readable.destroy;
  r.exports = a.Readable, r.exports._uint8ArrayToBuffer = a._uint8ArrayToBuffer, r.exports._isUint8Array = a._isUint8Array, r.exports.isDisturbed = a.isDisturbed, r.exports.isErrored = a.isErrored, r.exports.isReadable = a.isReadable, r.exports.Readable = a.Readable, r.exports.Writable = a.Writable, r.exports.Duplex = a.Duplex, r.exports.Transform = a.Transform, r.exports.PassThrough = a.PassThrough, r.exports.addAbortSignal = a.addAbortSignal, r.exports.finished = a.finished, r.exports.destroy = a.destroy, r.exports.destroy = l, r.exports.pipeline = a.pipeline, r.exports.compose = a.compose, Object.defineProperty(a, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return n;
    }
  }), r.exports.Stream = a.Stream, r.exports.default = r.exports;
})(zs);
var Da = zs.exports;
class hb {
  constructor(a) {
    le(this, "_module");
    this._module = a;
  }
  allocate(a) {
    const n = this._module.canvas.getContext("webgl2"), l = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, l), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), a && n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, a), n.bindTexture(n.TEXTURE_2D, null);
    const _ = this._module.GL.getNewId(this._module.GL.textures);
    return this._module.GL.textures[_] = l, { id: _ };
  }
  release(a) {
    const n = typeof a == "number" ? a : a.id;
    this._module.canvas.getContext("webgl2").deleteTexture(this._module.GL.textures[n]), this._module.GL.textures[n] = null;
  }
}
class pb {
  constructor(a) {
    le(this, "_module");
    this._module = a;
  }
  allocate(a) {
    const n = this._module._malloc(a);
    return {
      buffer: () => this._module.HEAPU8.buffer,
      byteOffset: n,
      byteLength: a
    };
  }
  release(a) {
    const n = typeof a == "number" ? a : a.byteOffset;
    this._module._free(n);
  }
}
async function Zu(r, a) {
  let n = new pb(r), l = new hb(r);
  const _ = { width: a.displayWidth, height: a.displayHeight }, v = n.allocate(a.allocationSize({ rect: _ })), w = a instanceof Gn ? v : new DataView(v.buffer(), v.byteOffset, v.byteLength), m = a.texture ? l.allocate(a.texture).id : 0, D = a.horizontalFlip;
  switch (a.format) {
    case "RGB":
    case "RGBA":
    case "BGR":
    case "BGRA":
      const L = a.format;
      return a.copyTo(w).then(
        () => r.FrameData.makeFromBpc8WithTexID(
          m,
          v.byteOffset,
          () => {
            n.release(v), l.release(m);
          },
          _.width,
          _.height,
          r.CameraOrientation.DEG_0,
          r.PixelFormat[L],
          D,
          0
        )
      );
    case "NV12":
      return a.copyTo(w).then(
        (O) => r.FrameData.makeFromYuvNV12(
          v.byteOffset + O[0].offset,
          v.byteOffset + O[1].offset,
          () => {
            n.release(v);
          },
          _.width,
          _.height,
          r.CameraOrientation.DEG_0,
          D,
          0
        )
      );
    case "I420":
      return a.copyTo(w).then(
        (O) => r.FrameData.makeFromYuvI420(
          v.byteOffset + O[0].offset,
          v.byteOffset + O[1].offset,
          v.byteOffset + O[2].offset,
          () => {
            n.release(v);
          },
          _.width,
          _.height,
          r.CameraOrientation.DEG_0,
          D,
          0
        )
      );
    default:
      throw new Error("Unknown video frame format");
  }
}
const lr = class lr extends qr {
  constructor(n, l) {
    super();
    le(this, "readable");
    le(this, "_sdk");
    le(this, "fps", 30);
    this._sdk = n, this.readable = new Da.Readable({
      read: async () => {
        const _ = pa(lr.PRODUCED_EVENT), { done: v, value: w } = await l.next(this.fps), m = ma(_);
        if (v) {
          this.readable.push(null), this.dispatchEvent(new CustomEvent(lr.EMPTIED_EVENT));
          return;
        }
        if (this.readable.destroyed) {
          w.close();
          return;
        }
        const D = w, L = Zu(this._sdk, D);
        this.readable.push({ frame: D, frameDataPromise: L }), this.dispatchEvent(new CustomEvent(lr.PRODUCED_EVENT, { detail: m }));
      },
      objectMode: !0,
      highWaterMark: 1
    });
  }
  pipe(n) {
    return this.readable.pipe(n);
  }
  unpipe() {
    return this.readable.unpipe();
  }
  destroy() {
    this.removeAllEventListeners(), this.readable.unpipe(), this.readable.destroy();
  }
};
le(lr, "EMPTIED_EVENT", "emptied"), le(lr, "PRODUCED_EVENT", "produced");
let ur = lr;
const Yr = class Yr extends qr {
  constructor(n, l, _, v) {
    super();
    le(this, "_sdk");
    le(this, "_effectPlayer");
    le(this, "_processor");
    le(this, "_lastFrame", null);
    le(this, "transform");
    this._sdk = n, this._effectPlayer = l;
    const w = this._sdk.ProcessorConfiguration.create();
    switch (_) {
      case "image":
        w.setUseOfflineMode(!0), w.setUseFutureFilter(!1), w.setUseFutureInterpolate(!1);
        break;
      case "video":
        w.setUseOfflineMode(!1), w.setUseFutureFilter(!1), w.setUseFutureInterpolate(!1);
        break;
      case "stream":
      default:
        w.setUseOfflineMode(!1), w.setUseFutureFilter(v.useFutureFilter), w.setUseFutureInterpolate(v.useFutureInterpolate);
        break;
    }
    this._processor = _ === "image" ? this._sdk.FrameProcessor.createPhotoProcessor(w) : this._sdk.FrameProcessor.createRealtimeProcessor(
      this._sdk.RealtimeProcessorMode.SYNC,
      w
    ), w.delete(), this._effectPlayer.setFrameProcessor(this._processor), this.transform = new Da.Transform({
      transform: async ({ frame: m, frameDataPromise: D }, L, O) => {
        this._lastFrame?.close(), this._lastFrame = m;
        const J = await D;
        if (this.transform.destroyed) {
          J.delete();
          return;
        }
        const ae = this._process(J);
        this.transform.push({
          frame: {
            width: m.displayWidth,
            height: m.displayHeight
          },
          result: ae
        }), O();
      },
      flush: (m) => {
      },
      objectMode: !0,
      highWaterMark: 1
    });
  }
  _process(n) {
    const l = pa(Yr.PROCESSED_EVENT), _ = (this._processor.push(n), this._processor.pop()), v = ma(l);
    return n.delete(), this.dispatchEvent(new CustomEvent(Yr.PROCESSED_EVENT, { detail: v })), _;
  }
  async rerun() {
    if (!this._lastFrame || this.transform.destroyed)
      return !1;
    const n = { width: this._lastFrame.displayWidth, height: this._lastFrame.displayHeight }, l = await Zu(this._sdk, this._lastFrame);
    if (this.transform.destroyed)
      return l.delete(), !1;
    const _ = this._process(l);
    return this.transform.push({
      frame: n,
      result: _
    }), !0;
  }
  pipe(n) {
    return this.transform.pipe(n);
  }
  unpipe() {
    return this.transform.unpipe();
  }
  destroy() {
    this.removeAllEventListeners(), this._processor.delete(), this._lastFrame && (this._lastFrame.close(), this._lastFrame = null), this.transform.unpipe(), this.transform.destroy();
  }
};
le(Yr, "PROCESSED_EVENT", "processed");
let Hr = Yr;
const mb = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Xr = class Xr extends qr {
  constructor(n, l, _ = mb) {
    super();
    le(this, "writable");
    le(this, "fps", 30);
    le(this, "_sdk");
    le(this, "_effectPlayer");
    le(this, "_effectManager");
    le(this, "_lastResult", null);
    le(this, "_preferences");
    le(this, "_width", 0);
    le(this, "_height", 0);
    le(this, "_then", 0);
    this._sdk = n, this._effectPlayer = l, this._effectManager = l.effectManager(), this._preferences = { devicePixelRatio: _ }, this.writable = new Da.Writable({
      write: async (v, w, m) => {
        this._lastResult?.result.delete(), this._lastResult = v, await new Promise(Zr), this._render(v), m();
      },
      objectMode: !0
    });
  }
  get frameSize() {
    return {
      width: this._width,
      height: this._height
    };
  }
  get renderSize() {
    return {
      width: this._sdk.canvas.width,
      height: this._sdk.canvas.height
    };
  }
  updateSurfaceSize() {
    this._width = this._height = 0;
  }
  _render({ frame: n, result: l }) {
    if (l.isDeleted())
      return;
    const _ = l.frameData;
    if (this._width !== n.width || this._height !== n.height) {
      this._width = n.width, this._height = n.height;
      const { width: m, height: D } = _b(
        n.width,
        n.height,
        this._preferences.devicePixelRatio
      );
      this._sdk.setCanvasSize(m, D), this._effectManager.setEffectSize(m, D), this._effectPlayer.surfaceChanged(m, D);
    }
    const v = pa(Xr.RENDERED_EVENT);
    this._effectPlayer.drawWithExternalFrameData(_), _.delete();
    const w = ma(v);
    this._sdk.ctx.bindFramebuffer(this._sdk.ctx.READ_FRAMEBUFFER, null), this.dispatchEvent(new CustomEvent(Xr.RENDERED_EVENT, { detail: w }));
  }
  async rerun() {
    if (!this._lastResult)
      return !1;
    let n = 0;
    const l = this._then, _ = 1e3 / this.fps, v = 0.1 * _;
    for (; (n = await new Promise(Zr)) - l < _ - v; )
      ;
    return this._then = n, this._render(this._lastResult), !0;
  }
  destroy() {
    this.removeAllEventListeners(), this._effectManager.delete(), this._lastResult && (this._lastResult.result.delete(), this._lastResult = null), this.writable.end(), this.writable.destroy();
  }
};
le(Xr, "RENDERED_EVENT", "rendered");
let Kr = Xr;
function _b(r, a, n) {
  const l = Math.round(self.devicePixelRatio), [_, v] = [screen.width * l, screen.height * l], w = Math.max(1, _ / r), m = Math.max(1, v / a), D = Math.max(w, m);
  n = Math.min(n, D);
  const L = r * n, O = a * n;
  return { width: L, height: O };
}
const Jt = class Jt extends qr {
  constructor(n, l, _) {
    super();
    le(this, "_sdk");
    le(this, "_effectPlayer");
    le(this, "_state", ht.Paused);
    le(this, "_producer");
    le(this, "_processor");
    le(this, "_renderer");
    le(this, "_preferences", {
      fps: 30,
      idleOnEmpty: !0,
      useFutureFilter: !0,
      useFutureInterpolate: !1
    });
    this._sdk = n, this._effectPlayer = l, this._preferences.useFutureFilter = _.useFutureFilter, this._preferences.useFutureInterpolate = _.useFutureInterpolate, this._producer = new ur(n, /* @__PURE__ */ async function* () {
    }()), this._processor = new Hr(
      n,
      l,
      "stream",
      this._preferences
    ), this._renderer = new Kr(n, l, _.devicePixelRatio), this._renderer.addEventListener(
      Kr.RENDERED_EVENT,
      ({ detail: v }) => this.dispatchEvent(new CustomEvent(Jt.FRAME_RENDERED_EVENT, { detail: v }))
    );
  }
  get state() {
    return this._state;
  }
  get frameSize() {
    return this._renderer.frameSize;
  }
  get preferences() {
    return this._preferences;
  }
  /** Changes the pipeline frames generator */
  use(n, l) {
    const _ = this._sdk, v = this._effectPlayer;
    this._producer.destroy(), this._processor.destroy(), this._producer = new ur(_, n[Symbol.asyncIterator](l)), this._producer.addEventListener(
      ur.PRODUCED_EVENT,
      ({ detail: w }) => this.dispatchEvent(new CustomEvent(Jt.FRAME_RECEIVED_EVENT, { detail: w }))
    ), this._processor = new Hr(
      _,
      v,
      n.kind,
      this._preferences
    ), this._processor.addEventListener(
      Hr.PROCESSED_EVENT,
      ({ detail: w }) => this.dispatchEvent(new CustomEvent(Jt.FRAME_PROCESSED_EVENT, { detail: w }))
    ), this._producer.addEventListener(ur.EMPTIED_EVENT, () => this._state = ht.Idle, {
      once: !0
    }), this._producer.addEventListener(
      ur.EMPTIED_EVENT,
      () => {
        this._renderer.addEventListener(
          Kr.RENDERED_EVENT,
          async () => {
            for (; this._state === ht.Idle && !this._preferences.idleOnEmpty; )
              if (!await this._renderer.rerun())
                return;
          },
          { once: !0 }
        );
      },
      { once: !0 }
    ), this._state === ht.Idle && (this._state = ht.Running), this._state === ht.Running && this._producer.pipe(this._processor.transform).pipe(this._renderer.writable);
  }
  /** Runs loop of processing of input frames as well as rendering */
  run({ fps: n = this._preferences.fps, idleOnEmpty: l = !0 }) {
    Object.assign(this._preferences, { fps: n, idleOnEmpty: l }), this._producer.fps = n, this._renderer.fps = n, !(this._state === ht.Running || this._state === ht.Idle) && (this._producer.pipe(this._processor.transform).pipe(this._renderer.writable), this._state = ht.Running);
  }
  /** Runs on-off re-run of the last processing and rendering */
  pause() {
    this._state !== ht.Paused && (this._producer.unpipe(), this._processor.unpipe(), this._state = ht.Paused);
  }
  /** Runs on-off re-run of the last rendering */
  async rerun() {
    this._state === ht.Idle && await this._processor.rerun();
  }
  /** Pauses inputâ€˜s frames retrieval, processing and rendering */
  async rerender() {
    this._state === ht.Idle && await this._renderer.rerun();
  }
  /** Cleans up the pipeline resources like received frames, allocated memory and gl resources */
  destroy() {
    this.pause(), this._producer.destroy(), this._processor.destroy(), this._renderer.destroy();
  }
  updateSurfaceSize() {
    this._renderer.updateSurfaceSize();
  }
};
le(Jt, "FRAME_RECEIVED_EVENT", "framereceived"), le(Jt, "FRAME_PROCESSED_EVENT", "frameprocessed"), le(Jt, "FRAME_RENDERED_EVENT", "framerendered");
let Tr = Jt;
class bb {
  /** @internal */
  constructor(a) {
    le(this, "_fd");
    le(this, "_cache", /* @__PURE__ */ new Map());
    this._fd = a;
  }
  get(a) {
    if (Array.isArray(a))
      return a.map((w) => this.get(w));
    const n = a.split("."), l = n.length;
    let _ = l, v = this._fd;
    for (let w = !1; !w && _ > 0; --_) {
      const m = n.slice(0, _).join(".");
      this._cache.has(m) && (w = !0, v = this._cache.get(m), ++_);
    }
    for (; v != null && _ < l; ++_) {
      const w = n[_];
      let m = v[w];
      if (typeof m > "u") {
        const L = "get" + w[0].toUpperCase() + w.slice(1);
        m = v[L];
      }
      if (typeof m > "u" && ko(v)) {
        const L = parseInt(w);
        isNaN(L) || (m = v.get(L));
      }
      if (typeof m == "function")
        try {
          m = m.apply(v);
        } catch {
          m = void 0;
        }
      const D = n.slice(0, _ + 1).join(".");
      if (a === D && ko(m)) {
        const L = m;
        m = new Array(L.size());
        for (let O = 0, J = L.size(); O < J; ++O)
          m[O] = L.get(O);
      }
      this._cache.set(D, v = m);
    }
    return _ === l ? v : void 0;
  }
  /** @hidden */
  addTimestampUs(a) {
    this._fd.addTimestampUs(a);
  }
}
class vs {
  constructor(a) {
    le(this, "_module");
    this._module = a;
  }
  exists(a) {
    try {
      return this._module.FS.lstat(a), !0;
    } catch (n) {
      if (n.errno === 44 || n.code === "ENOENT")
        return !1;
      throw n;
    }
  }
  writeFile(a, n) {
    const l = a.split("/");
    l[0] === "" && l.shift(), l.length > 1 && l.reduce((_, v) => (this.exists(_) || this._module.FS.mkdir(_), `${_}/${v}`)), !(a.endsWith("/") && n.length === 0) && this._module.FS.writeFile(a, n);
  }
}
var yb = Object.defineProperty, gb = Object.getOwnPropertyDescriptor, wb = (r, a, n, l) => {
  for (var _ = l > 1 ? void 0 : l ? gb(a, n) : a, v = r.length - 1, w; v >= 0; v--)
    (w = r[v]) && (_ = (l ? w(a, n, _) : w(_)) || _);
  return l && _ && yb(a, n, _), _;
};
const vb = {
  useFutureFilter: !0,
  useFutureInterpolate: !1,
  logger: console
};
var Qe;
const qu = (Qe = class extends qr {
  constructor(n, l = {}) {
    super();
    le(this, "_sdk");
    le(this, "_effectPlayer");
    le(this, "_effectManager");
    le(this, "_pipeline");
    le(this, "_preferences");
    this._sdk = n, this._preferences = {
      ...vb,
      ...l
    };
    const _ = this._sdk.EffectPlayerConfiguration.create(
      this._sdk.canvas.width,
      this._sdk.canvas.height
    );
    this._effectPlayer = this._sdk.EffectPlayer.create(_), _.delete(), this._effectManager = this._effectPlayer.effectManager(), this._effectPlayer.surfaceCreated(this._sdk.canvas.width, this._sdk.canvas.height), this._effectPlayer.addFrameDataListener((v) => {
      this.dispatchEvent(
        new CustomEvent(Qe.FRAME_DATA_EVENT, { detail: new bb(v) })
      );
    }), this._effectManager.addEffectActivatedListener(() => {
      const v = this._effectManager.current();
      this.dispatchEvent(new CustomEvent(Qe.EFFECT_ACTIVATED_EVENT, { detail: v }));
    }), this._effectManager.addEffectEventListener(async (v) => {
      v === Dp && (await new Promise((w) => As(w)), this._pipeline.rerun());
    }), this._pipeline = new Tr(
      this._sdk,
      this._effectPlayer,
      this._preferences
    ), this._pipeline.addEventListener(
      Tr.FRAME_RECEIVED_EVENT,
      ({ detail: v }) => this.dispatchEvent(new CustomEvent(Qe.FRAME_RECEIVED_EVENT, { detail: v }))
    ), this._pipeline.addEventListener(
      Tr.FRAME_PROCESSED_EVENT,
      ({ detail: v }) => this.dispatchEvent(new CustomEvent(Qe.FRAME_PROCESSED_EVENT, { detail: v }))
    ), this._pipeline.addEventListener(
      Tr.FRAME_RENDERED_EVENT,
      ({ detail: v }) => this.dispatchEvent(new CustomEvent(Qe.FRAME_RENDERED_EVENT, { detail: v }))
    ), this.canvas.addEventListener("webglcontextlost", async (v) => {
      v.preventDefault(), this._effectPlayer.playbackStop(), this.pause(), this._effectPlayer.surfaceDestroyed();
    }), this.canvas.addEventListener("webglcontextrestored", () => {
      Vs(this._sdk.ctx), this._effectPlayer.surfaceCreated(this._sdk.canvas.width, this._sdk.canvas.height), this._pipeline.updateSurfaceSize(), this.play(), this._effectPlayer.playbackPlay();
    }), this.setVolume(0);
  }
  /**
   * Creates {@link Player} instance.
   *
   * See {@link SDKOptions} and {@link PlayerOptions} for all the possible parameters.
   *
   * @example
   * ```ts
   * const player = await Player.create({ clientToken: "xxx-xxx-xxx", devicePixelRatio: 1 })
   * ```
   */
  static async create(n) {
    const l = await Lp(n);
    return new this(l, n);
  }
  /**
   * Underlying HTMLCanvasElement
   * @internal
   */
  get canvas() {
    return this._sdk.canvas;
  }
  /**
   * The size of the last rendered frame.
   *
   * May be bigger then {@link Player.canvas} size. See {@link calculateSurfaceSize}
   * @internal
   */
  get frameSize() {
    return this._pipeline.frameSize;
  }
  /** @internal */
  get preferences() {
    return {
      ...this._preferences,
      pauseOnEmpty: this._pipeline.preferences.idleOnEmpty
    };
  }
  get isPlaying() {
    return this._pipeline.state === ht.Running;
  }
  /**
   * Uses the input as frames source
   * @example
   * ```ts
   * player.use(new Webcam())
   * ```
   */
  use(n, l) {
    this._pipeline.use(n, l);
  }
  /**
   * Adds additional modules like `face_tracker`, `background` and {@link Module | many others} to the Player and makes them available for effects
   * @example
   * ```ts
   * const frx = new Module("/path/to/face_tracker.zip")
   *
   * await player.addModule(frx)
   * ```
   */
  async addModule(...n) {
    await Promise.all(n.map((l) => l._bind({ FS: new vs(this._sdk) })));
  }
  /**
   * Applies an effect to input
   * @example
   * ```ts
   * const octopus = new Effect("/path/to/Octopus.zip")
   *
   * await player.applyEffect(octopus)
   * ```
   */
  async applyEffect(n) {
    const l = this, _ = n.name;
    return await n._bind({
      FS: new vs(this._sdk),
      evalJs: this._evalJs.bind(this),
      callJsMethod: this._callJsMethod.bind(this)
    }), new Promise((v) => {
      this.addEventListener(Qe.EFFECT_ACTIVATED_EVENT, w, { once: !0 }), this.addEventListener(Qe.EFFECT_ACTIVATED_EVENT, m);
      try {
        this._effectManager.load(_);
      } catch (D) {
        this.removeEventListener(Qe.EFFECT_ACTIVATED_EVENT, w), this.removeEventListener(Qe.EFFECT_ACTIVATED_EVENT, m), n._unbind(), this.clearEffect(), this._preferences.logger.warn?.("The effect was force cleared due to the exception:"), this._preferences.logger.error?.(D);
      }
      function w({ detail: D }) {
        v(D);
      }
      function m({ detail: D }) {
        D.url() !== `/${_}/` && (l.removeEventListener(Qe.EFFECT_ACTIVATED_EVENT, m), n._unbind());
      }
    });
  }
  /** Clears effect applied to input */
  async clearEffect() {
    return new Promise((n) => {
      this.addEventListener(Qe.EFFECT_ACTIVATED_EVENT, () => n(), { once: !0 }), this._effectManager.load("");
    });
  }
  callJsMethod(n, l = "") {
    return this._callJsMethod(n, l);
  }
  /** Sets effect volume from 0 to 1 */
  setVolume(n) {
    this._effectManager.setEffectVolume(n), this.dispatchEvent(new CustomEvent("volumechange", { detail: n }));
  }
  /**
   * Starts input processing.
   *
   * Accepts playback options object with optional `fps` and `pauseOnEmpty` keys.
   *
   * @example
   * ```ts
   * /// The `fps` playback option persists between invocations:
   *
   * const desiredFps = 25
   *
   * player.play({ fps: desiredFps })
   * player.play() // same as passing `{ fps: desiredFps }`
   * ```
   * @example
   * ```ts
   * /// The `pauseOnEmpty` playback option resets to `true` between invocations:
   *
   * await player.use(new Image(file))
   * player.applyEffect(new Effect("path/to/Spider.zip")) // an effect with animations
   *
   * player.play({ pauseOnEmpty: false })
   * player.play() // same as passing `{ pauseOnEmpty: true }`
   * ```
   */
  play(n = {}) {
    this._pipeline.run({
      fps: n.fps,
      idleOnEmpty: n.pauseOnEmpty
    });
  }
  /** Stops input processing */
  pause() {
    this._pipeline.pause();
  }
  /** Destroys the {@link Player} instance, clears all the resources used */
  async destroy() {
    this.pause(), this.removeAllEventListeners(), await this.clearEffect(), this._pipeline.destroy(), this._effectPlayer.surfaceDestroyed(), this._effectManager.delete(), this._effectPlayer.delete();
    for (const n in this)
      n.startsWith("_") && Object.defineProperty(this, n, {
        get() {
          throw new Error("The player is destroyed.");
        },
        set() {
          throw new Error("The player is destroyed.");
        }
      });
  }
  async _evalJs(n) {
    return new Promise(async (l) => {
      const _ = this._effectManager.current().evalJsSync(n);
      await this._pipeline.rerender(), l(_);
    });
  }
  /** @deprecated */
  async _callJsMethod(n, l = "") {
    this._effectManager.current().callJsMethod(n, l), await this._pipeline.rerender();
  }
}, /**
 * Triggered when a frame is received from the specified {@link Input}
 * @event
 */
le(Qe, "FRAME_RECEIVED_EVENT", "framereceived"), /**
 * Triggered when a frame is processed by underlying neural networks
 * @event
 */
le(Qe, "FRAME_PROCESSED_EVENT", "frameprocessed"), /**
 * Triggered when a frame is rendered
 * @event */
le(Qe, "FRAME_RENDERED_EVENT", "framerendered"), /**
 * Triggered when a new {@link FrameData} is ready
 * @example
 * ```ts
 * player.addEventListener("framedata", ({ detail: frameData }) => {
 *   const hasFace = frameData.get("frxRecognitionResult.faces.0.hasFace")
 *   if (!hasFace) return
 *
 *   const landmarks = frameData.get("frxRecognitionResult.faces.0.landmarks")
 *   console.log(landmarks)
 * })
 * ```
 * @event
 */
le(Qe, "FRAME_DATA_EVENT", "framedata"), /**
 * Triggered when an {@link Effect} is activated
 *
 * Note: By default the {@link Player} starts with an "empty" {@link Effect} applied
 * which does nothing but rendering
 *
 * @event
 */
le(Qe, "EFFECT_ACTIVATED_EVENT", "effectactivated"), Qe);
wb([
  Is("Please, use Effect.evalJs() instead.")
], qu.prototype, "callJsMethod", 1);
let Wb = qu;
const ni = (r) => {
  if (!(r && "canvas" in r))
    throw new Error(
      `The "player" must be a Player instance, but "${r}" is received. Make sure you haven't forgot to place "await" before Player.create() call.`
    );
}, ca = /* @__PURE__ */ new WeakMap(), Eb = (r, a) => {
  ni(r);
  const n = typeof a == "string" ? document.querySelector(a) : a;
  if (!(n instanceof HTMLElement))
    throw new Error("Target container is not a DOM element");
  if (n instanceof HTMLMediaElement || n instanceof HTMLCanvasElement)
    throw new Error("Target container must be a plain html element like `div`");
  ca.set(n, r), n.appendChild(r.canvas);
  const { pauseOnEmpty: l } = r.preferences;
  r.play({ pauseOnEmpty: l });
}, xb = (r) => {
  const a = typeof r == "string" ? document.querySelector(r) : r;
  if (!(a instanceof HTMLElement))
    throw new Error("Target container is not a DOM element");
  const n = ca.get(a);
  n && a.removeChild(n.canvas), ca.delete(a);
}, $b = { render: Eb, unmount: xb };
class Gb {
  constructor(a) {
    le(this, "_player");
    ni(a), this._player = a;
  }
  /**
   * @param settings - Output photo settings
   * @returns Snapshot of the current {@link Player} state
   */
  async takePhoto(a) {
    const n = this._player.canvas, { width: l, height: _ } = this._player.frameSize, v = Sb(n, a?.width ?? l, a?.height ?? _);
    return await new Promise(
      (w, m) => v.toBlob(
        (D) => D ? w(D) : m(new Error("Unexpected error: Unable to create Blob")),
        a?.type ?? "image/jpeg",
        a?.quality
      )
    );
  }
}
const Sb = (r, a = r.width, n = r.height) => {
  if (a !== r.width || n !== r.height) {
    const _ = Cb(a, n);
    return _.getContext("2d").drawImage(r, 0, 0, _.width, _.height), _;
  }
  return r;
}, Cb = (r, a) => {
  let n;
  return Ps ? (n = new OffscreenCanvas(r, a), n.toBlob = function(l, _, v) {
    this.convertToBlob({ type: _, quality: v }).then(l).catch((w) => l(null));
  }) : (n = document.createElement("canvas"), n.width = r, n.height = a), n;
}, Tb = typeof MediaStream < "u" ? MediaStream : class {
  constructor() {
    throw new Error("The environment does not support MediaStream API");
  }
}, Fr = class Fr extends Tb {
  constructor(a) {
    ni(a), super();
    const n = Fr.cache.get(a);
    if (!n || !n.active) {
      let l = a.canvas;
      if (((l.getContext("webgl2") || l.getContext("webgl")).getContextAttributes() || {}).alpha) {
        const w = l, m = (l = document.createElement("canvas")).getContext("2d", {
          alpha: !1
        });
        a.addEventListener("framerendered", () => {
          m.canvas.width = w.width, m.canvas.height = w.height, m.drawImage(w, 0, 0, w.width, w.height);
        });
      }
      l.captureStream().getTracks().forEach((w) => this.addTrack(w)), Fr.cache.set(a, this);
    }
    return Fr.cache.get(a);
  }
  /**
   * @returns
   * Video {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack | MediaStreamTrack}
   * of given index from {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/getVideoTracks | MediaStream.getVideoTracks()} list
   */
  getVideoTrack(a = 0) {
    return this.getVideoTracks()[a];
  }
  /**
   * @returns
   * Audio {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack | MediaStreamTrack}
   * of given index from {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/getAudioTracks | MediaStream.getAudioTracks()} list
   */
  getAudioTrack(a = 0) {
    return this.getAudioTracks()[a];
  }
  /** Stops the capture */
  stop() {
    this.getTracks().forEach((a) => a.stop());
  }
};
le(Fr, "cache", /* @__PURE__ */ new WeakMap());
let Es = Fr;
const Fb = typeof MediaRecorder < "u" ? MediaRecorder : class {
  constructor() {
    throw new Error("The environment does not support MediaRecorder API");
  }
};
class Vb extends Fb {
  constructor(a, n) {
    ni(a);
    const l = a.canvas.captureStream();
    super(l, n);
  }
  /**
   * Stops video recording
   * @returns The recorder video
   */
  async stop() {
    return new Promise((a, n) => {
      const l = (v) => {
        super.removeEventListener("dataavailable", l), super.removeEventListener("error", _), a(v.data);
      }, _ = (v) => {
        super.removeEventListener("dataavailable", l), super.removeEventListener("error", _), n(v);
      };
      super.addEventListener("dataavailable", l), super.addEventListener("error", _), super.stop();
    });
  }
}
const zb = "1.16.4";
export {
  $b as Dom,
  mp as Effect,
  bb as FrameData,
  Xh as Image,
  Gb as ImageCapture,
  Ri as MediaStream,
  Es as MediaStreamCapture,
  Lb as Module,
  Wb as Player,
  zb as VERSION,
  np as Video,
  Vb as VideoRecorder,
  kb as Webcam,
  Lp as createSDK,
  vb as defaultPlayerOptions,
  qi as defaultVideoConstraints,
  rp as defaultVideoOptions,
  jh as isBrowserSupported,
  vp as isSimdSupported,
  Ab as timers,
  Db as utils
};
